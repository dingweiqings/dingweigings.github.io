<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>系统编程</title>
    <url>//2023/09/19/linux/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>生活</title>
    <url>//2023/09/15/%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="生活">生活</h1>
<p>保持一颗淡泊的心,自己会变的很轻松愉快. 坚持一项运动，会一生受益. 坚持早睡早起,会一生受益.</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文化理解</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc的虚函数表</title>
    <url>//2023/09/25/C++/gcc%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="虚函数表">虚函数表</h1>
<p>所谓虚函数表，是编译器自动为一个带有虚函数的类生成的一块内存空间，其中存储着每一个虚函数的入口地址。由于函数的入口地址可以看成一个指针类型，因此这些虚函数的地址间隔为四个字节。而每一个带有虚函数类的实例，都拥有一个虚函数指针——vptr，在类的对象初始化完毕后，它将指向虚函数表。 ## 相关概念 1. vbase offset vbase offset全称为(Virtual Base offsets), 也即虚基类偏移。当一个class存在虚基类时，gcc编译器便会在 primary virtual table中安插相应的vbase offset。 其主要作用为： 用于访问对象的虚基类子对象。 这样的条目被添加到派生类对象vtable，以获取虚拟基类子对象的地址。每个虚基类都需要这样一个条目。这些值可以是正的，也可以是负的。 2. top offset top offset ，也即到class顶部的偏移，指的该class的vptr到对象顶部的位移，其类型为 ptrdiff_t。 它总是存。 偏移量提供了一种使用vptr从任何基类对象中查找对象顶部的方式。 这对于 dynamic_cast&lt;void*&gt; 尤其必要。</p>
<ol start="3" type="1">
<li>typeinfo指针 typeinfo 指针指向用于 RTTI 的 typeinfo 对象。 它总是存在的。 给定类的每个vtable中的所有typeinfo 指针都必须指向相同的 typeinfo 对象。 typeinfo 相等性的正确实现是检查指针相等性，但指向不完整类型的指针（直接或间接）除外。 typeinfo 指针在多态类的场景下是有效指针，对于非多态类为零。</li>
<li>virtual function 指针 函数指针用于虚函数调度。 每个指针要么保存类的虚函数的地址，要么保存在将控制权转移到虚函数之前执行某些调整的辅助入口点的地址。 先有个初步的了解 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int a;</span><br><span class="line">    virtual ~A(void) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class B : virtual public A</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 对于上面的代码,执行<code>g++ -fdump-lang-class code.cc</code>，并执行c++命名反修饰<code>cat code.001.class | c++filt</code>会得到下面的输出,其中的VTT下面会解释 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class A</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">A (0x0x7fb9e6855d80) 0</span><br><span class="line">    vptr=((&amp; A::vtable for A)   16)</span><br><span class="line"></span><br><span class="line">Vtable for B</span><br><span class="line">B::vtable for B: 8 entries</span><br><span class="line">0     16</span><br><span class="line">8     (int (*)(...))0</span><br><span class="line">16    (int (*)(...))(&amp; typeinfo for B)</span><br><span class="line">24    (int (*)(...))B::bf</span><br><span class="line">32    0</span><br><span class="line">40    (int (*)(...))-16</span><br><span class="line">48    (int (*)(...))(&amp; typeinfo for B)</span><br><span class="line">56    (int (*)(...))A::af</span><br><span class="line"></span><br><span class="line">VTT for B</span><br><span class="line">B::VTT for B: 2 entries</span><br><span class="line">0     ((&amp; B::vtable for B)   24)</span><br><span class="line">8     ((&amp; B::vtable for B)   56)</span><br><span class="line"></span><br><span class="line">Class B</span><br><span class="line">   size=32 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">B (0x0x7fb9e66fe1a0) 0</span><br><span class="line">    vptridx=0 vptr=((&amp; B::vtable for B)   24)</span><br><span class="line">  A (0x0x7fb9e6855e40) 16 virtual</span><br><span class="line">      vptridx=8 vbaseoffset=-24 vptr=((&amp; B::vtable for B)   56)</span><br></pre></td></tr></table></figure> # gcc查看虚函数表 做些设置 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set print asm-demangle on</span><br><span class="line">set print demangle on </span><br><span class="line">set print pretty on</span><br></pre></td></tr></table></figure> 查看对象结构：p 对象名 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p p1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = &#123;_vptr<span class="variable">$Parent</span> = 0x400bb8 &lt;vtable <span class="keyword">for</span> Parent+16&gt;&#125;</span></span><br><span class="line">(gdb) p p2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;_vptr<span class="variable">$Parent</span> = 0x400bb8 &lt;vtable <span class="keyword">for</span> Parent+16&gt;&#125;</span></span><br><span class="line">(gdb) p d1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = &#123;&lt;Parent&gt; = &#123;_vptr<span class="variable">$Parent</span> = 0x400b50 &lt;vtable <span class="keyword">for</span> Derived+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br><span class="line">(gdb) p d2</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = &#123;&lt;Parent&gt; = &#123;_vptr<span class="variable">$Parent</span> = 0x400b50 &lt;vtable <span class="keyword">for</span> Derived+16&gt;&#125;, &lt;No data fields&gt;&#125;</span></span><br></pre></td></tr></table></figure> dump内存: x/字节数 起始位置 x/300xb 0x400b40 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) x/300xb 0x400b40</span><br><span class="line">0x400b40 &lt;vtable for Derived&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b48 &lt;vtable for Derived+8&gt;:	0x90	0x0b	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b50 &lt;vtable for Derived+16&gt;:	0x80	0x0a	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b58 &lt;vtable for Derived+24&gt;:	0x90	0x0a	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b60 &lt;typeinfo name for Derived&gt;:	0x37	0x44	0x65	0x72	0x69	0x76	0x65	0x64</span><br><span class="line">0x400b68 &lt;typeinfo name for Derived+8&gt;:	0x00	0x36	0x50	0x61	0x72	0x65	0x6e	0x74</span><br><span class="line">0x400b70 &lt;typeinfo name for Parent+7&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b78 &lt;typeinfo for Parent&gt;:	0x90	0x20	0x60	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b80 &lt;typeinfo for Parent+8&gt;:	0x69	0x0b	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b88:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b90 &lt;typeinfo for Derived&gt;:	0x10	0x22	0x60	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400b98 &lt;typeinfo for Derived+8&gt;:	0x60	0x0b	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400ba0 &lt;typeinfo for Derived+16&gt;:	0x78	0x0b	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400ba8 &lt;vtable for Parent&gt;:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400bb0 &lt;vtable for Parent+8&gt;:	0x78	0x0b	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400bb8 &lt;vtable for Parent+16&gt;:	0xa0	0x0a	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">0x400bc0 &lt;vtable for Parent+24&gt;:	0x90	0x0a	0x40	0x00	0x00	0x00	0x00	0x00</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="单继承的虚函数表">单继承的虚函数表</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Parent &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual void Foo() &#123;&#125;</span><br><span class="line">  virtual void FooNotOverridden() &#123;&#125;</span><br><span class="line">  int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Parent &#123;</span><br><span class="line"> public:</span><br><span class="line">  void Foo() override &#123;&#125;</span><br><span class="line">  int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  Parent p1, p2;</span><br><span class="line">  Derived d1, d2;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; &quot;done&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类的内存布局 <img src="/img/vtable-single.png" alt="gdb中查看" /> |子类布局| |-------| |_vptr$Parent| |int a (Parent data)| |int b (Child data)| 虚函数表,Drived只有一个函数表，但Parent和Derived都指向Derived的虚函数表,Derived复用了父类的vptr。下面是vtable布局 <img src="/img/vable-single-desc.png" alt="vtable布局" /></p>
<h1 id="多继承的虚函数表">多继承的虚函数表</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Mother &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual void MotherFoo() &#123;&#125;</span><br><span class="line">   int mother_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Father &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual void FatherFoo() &#123;&#125;</span><br><span class="line">   int father_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Mother, public Father &#123;</span><br><span class="line"> public:</span><br><span class="line">  void FatherFoo() override &#123;&#125;</span><br><span class="line">   int child_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照上面gdb的查看步骤，可以得到: <img src="/img/vtable-multi-memory.png" alt="内存布局" /> <img src="/img/vtable-multi-function.png" alt="vtable" /> 这里是把Monther当做主基类,Child复用Monther的vptr.观察可以发现，父类的vptr指针对于被覆盖的函数，实际上指向的子类的地址。 当做下面转换时， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Father f  = Child();</span><br><span class="line">f.fatherFoo();</span><br></pre></td></tr></table></figure> 实际上调用的一段汇编的桩代码，类似于 gdb执行<code>info vtbl c</code>查看vtable有: <img src="/img/gdb-vtbl-info.png" alt="查看vtable" /> 实际的内存地址可能和上面表格有出入，但顺序是一致的 得到函数地址再反汇编,有 <img src="/img/vtable-multi-adjust-this.png" alt="反汇编覆盖的虚函数" /> 第一行<code>sub $0x10 %rdi</code>就是在调整this指针，rdi寄存器一般用来保存成员函数的第一个参数，也就是this指针.偏移量有前面的top_offset得到 <strong>注意</strong> 为什么需要调整this指针呢？ 因为Father实际上基类，但调用的实例是Child，成员函数的this指针必须指向当前实际类型的内存空间,因为在被覆盖的成员函数可能会访问子类成员数据，this指针如果不设置正确，则可能访问错误。所有的多态调用都必须调整this指针,主基类由于和子类共用vptr不需要调整。在我们这个例子中Mother是主基类，调佣Mother的虚函数，不需要调整this指针</p>
<h1 id="虚拟继承的虚函数表">虚拟继承的虚函数表</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandparent</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">grandparent_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> grandparent_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Grandparent &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">parent1_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> parent1_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Grandparent &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">parent2_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> parent2_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Parent1, <span class="keyword">public</span> Parent2 &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">child_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="type">int</span> child_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Child child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是按照上面步骤来看,打印Child的内存布局 <img src="/img/gdb-object-virtual.png" alt="gdb内存布局" /> <img src="/img/vtable-virtual.png" alt="内存布局" /> 可以发现，实际上虚继承的每个父类都只有一份内存拷贝，相当于直接继承GrandParent。下面是vtable <img src="/img/vtable-virtual-layout.png" alt="vtable布局" /> <img src="/img/vtable-virtual-layout-gdb.png" alt="gdb内存布局" /> 实际的内存地址可能和上面表格有出入，但顺序是一致的 这里多出来了construct table和vtt。这篇<a href="https://github.com/bingseclab/VirtAnalyzer/blob/master/paper.pdf">反汇编gcc编译bin的论文</a>有提到这些是干什么的.下面我也会解释这两个的作用。 <strong>注意</strong> construct table和vtt在内存中实际存在的,要占用内存空间 construct table是在实例化Child需要用到的,比如在实例化Child时，会最先实例化GrandParent(相当于Child直接继承),然后再实例化Parent1,Parent2.但GrandParent已经有了，如何告诉Parent1呢？这里就用到了virtual base offset和construct table，告诉Parent1，GrandParent已经在this-32的位置(这里this是指向Child的内存首地址,因为是构造Child).这样就可以把类拼起来了。top_offset还是子类到Child数据成员首地址的偏移量。 <img src="/img/vtable-parent1-construct.png" alt="Parent1 construct table" /> 还有一个东西就是Vtable table，用来记录多个vtable的位置，充当一个索引的作用 <img src="/img/vtable-vtt.png" alt="vtt" /></p>
<h1 id="虚函数表如何解决面向对象中的问题">虚函数表如何解决面向对象中的问题</h1>
<h2 id="实现多态">实现多态</h2>
<ol type="1">
<li>基类的vptr指向子类的虚函数</li>
<li>在调用时，根据子类记录的基类偏移量来调整this指针 ## 遗留的问题 我搞不懂既然vptr是指向function pointer，那编译器怎么直到vptr前面有几个才是vtable的首地址呢，第几项是vbase offset呢？如果有多个虚继承的类，又当怎么vbase offset呢？ # 继承结构可视化 在有一篇反汇编gcc编译出的bin论文中有提到说可以可视化vtable,但我是没跑通，最后需要下载ida pro这个反编译工具,没跑通 https://github.com/bingseclab/VirtAnalyzer/blob/master/README.md</li>
</ol>
<h1 id="引用">引用</h1>
<ol type="1">
<li>深入探索C++对象-候捷</li>
<li><a href="https://github.com/bingseclab/VirtAnalyzer/blob/master/paper.pdf">反汇编gcc编译bin的论文</a></li>
<li><a href="https://llvm.org/devmtg/2021-11/slides/2021-RelativeVTablesinC.pdf">LLVM虚函数表</a></li>
<li><a href="https://shaharmike.com/cpp/vtable-part1/">vtable单继承详解</a></li>
<li><a href="https://shaharmike.com/cpp/vtable-part2/">vtable多重继承详解</a></li>
<li><a href="https://shaharmike.com/cpp/vtable-part3/">vtable虚继承详解</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ 虚函数 编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11新特性</title>
    <url>//2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="lambda函数">lambda函数</h1>
<p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[]：默认不捕获任何变量；</span><br><span class="line">[=]：默认以值捕获所有变量；</span><br><span class="line">[&amp;]：默认以引用捕获所有变量；</span><br><span class="line">[x]：仅以值捕获x，其它变量不捕获；</span><br><span class="line">[&amp;x]：仅以引用捕获x，其它变量不捕获；</span><br><span class="line">[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</span><br><span class="line">[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</span><br><span class="line">[this]：通过引用捕获当前对象（其实是复制指针）；</span><br><span class="line">[*this]：通过传值方式捕获当前对象；</span><br></pre></td></tr></table></figure> # 智能指针 C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。实现原理是通过类达到作用域后的构造和析构来实现的 ## 独占指针 unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：</p>
<p>1、拥有它指向的对象</p>
<p>2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作</p>
<p>3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象</p>
<h2 id="共享指针">共享指针</h2>
<p>多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h2 id="弱指针">弱指针</h2>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<h1 id="移动语义">移动语义</h1>
<p>编译器通过参数的类型实现重载函数决断，对于右值入参，优先调用形参为右值引用的函数。形参为右值引用类型的接口实现方式一般和传统接口（例如拷贝构造、拷贝赋值）实现方式不同，简单来说前者为浅拷贝，后者为深拷贝，即前者为“窃取”后者为副本复制，形如本文开篇那张图片所示（class string）</p>
<h1 id="多线程支持">多线程支持</h1>
<p>原子类,thread类，条件变量类</p>
<p><strong>注意</strong> 本文测试代码见 https://github.com/dingweiqings/study/tree/master/cpp_study/src/smartpoiner https://github.com/dingweiqings/study/tree/master/cpp_study/src/thread</p>
<p># 引用 1. 移动语义 https://cloud.tencent.com/developer/article/1385969 2. 多线程 https://immortalqx.github.io/2021/12/04/cpp-notes-3/ 3. C++智能指针 https://www.cnblogs.com/tenosdoit/p/3456704.html 4. lambda函数 https://www.jianshu.com/p/d686ad9de817</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>//2023/01/17/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="面向对象的软件设计方式">面向对象的软件设计方式</h1>
<p>大型软件工程中是根据需求中的实体来建模的,对象往往代表了这些实体。具有这些实体的属性，并以提供和其他对象交互的函数。有以下的优势： 1. 逻辑容易设计和理解 2. 可以提高代码功能逻辑的复用 3. 代码上高内聚低耦合，面向接口依赖 4. 提供了运行时的动态绑定 # 面向对象的基本概念和模式 类：类是描述一类对象的特征和提供特定功能的代码实体，同时也是实例的模板，实例以类为模板 实例: 具体的一个对象，具有实例变量，是类的一个具体化。 类有静态属性和动态属性之分，静态属性是所有实例共享的，动态属性是每个实例特有的，又称实例属性 ## 举个例子，以人为例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usingnamespace std::string;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private:</span><br><span class="line">      int age;</span><br><span class="line">      string name;</span><br><span class="line">      string work;</span><br><span class="line">    public:  </span><br><span class="line">      static string motherland;</span><br><span class="line">    private:</span><br><span class="line">      string doWork()&#123;</span><br><span class="line">        std::cout&gt;&gt;&quot;我在做xxxjob&quot;;</span><br><span class="line">      &#125;  </span><br><span class="line">    public:</span><br><span class="line">      string buy(string car)&#123;</span><br><span class="line">        std::cout&gt;&gt;&quot;买了&quot;&gt;&gt;car;</span><br><span class="line">      &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">Person::motherland = &quot;中国&quot;;</span><br><span class="line">Person zhangsan = Person(10,&quot;张三&quot;,&quot;学生&quot;);</span><br><span class="line">Person lisi = Person(25,&quot;李四&quot;,&quot;程序员&quot;);</span><br></pre></td></tr></table></figure> 来验证前面的理论，类是实体的建模，成员是对实体属性的抽象。两个实例zhangsan和lisi是类Person的具体化，动态属性的值各不相同。但都有一个共享的静态变量。类有特定功能的函数或者说有特定行为的函数，这些函数用来和其他对象交互. ## 进一步的概念 经过上面的例子，就可以归纳出在代码实体上的概念： - 成员变量,类的属性 - 方法，类的特定行为的函数 - 成员变量和方法的权限 - 普通函数，和c中函数类似，不在类的代码块内部 - 构造函数和析构函数 - 继承，对象的树级关系 - 虚函数，子类可以重写的方法，编译器用virtual关键字来识别 - 纯虚函数，用来定义接口，带有纯虚函数的不能实例化,编译器用virtual关键字+方法体=0来定义 - 抽象基类,用做接口定义,包含纯虚函数的类是抽象基类，不能实例化，只能被继承，实例化成他的子类 ## 类型兼容原则 所指的替代包括以下情况： 1. 子类对象可以当作父类对象使用 2. 子类对象可以直接赋值给父类对象 3. 子类对象可以直接初始化父类对象 4. 父类指针可以直接指向子类对象 5. 父类引用可以直接引用子类对象 ### 下面介绍构造函数和析构函数 #### 默认构造函数和无参构造函数 默认构造函数是创建对象时默认调用的,如果没有声明，则编译器会按照一定条件来默认创建一个无参的构造函数，当然自己也可以声明无参的。自己声明了，编译器则不会再创建。<strong>编译器创建的构造函数并不会赋初始值</strong>。编译器的创建策略主要是 1. 有非基本类型的成员(自定义类型或者string类型),并且这些成员本身有默认构造函数。这种情况是如果只有基本类型在拷贝对象时，直接拷贝内存块即可 2. 有虚函数和虚继承，这种情况是需要虚函数表 3. 继承的父类有默认构造函数 这里推荐一个网站，可以用来查看编译后的汇编代码。https://godbolt.org/ 引用1中的结论我是验证过的，在gcc13.2上。记住要加-O0(减号大o后面跟个优化等级)才可以得到结果</p>
<ul>
<li>如果自己只定义了默认构造函数，编译器是否会生成拷贝/赋值/移动构造函数？ 如果程序中有用到对象拷贝赋值则会生成并调用默认的构造函数，没有用到则不会生成</li>
<li>如果只定义了拷贝构造函数，还会生成默认构造函数吗？ 这种不会，编译会报错 #### 析构函数 在释放对象时，编译调用的函数。如果是用来继承的类，必须声明为虚函数 #### 父子类的构造函数和析构函数顺序 构造：先基类，再子类 析构：先子类，再基类 对上面继承时析构函数需要声明为虚函数做些说明，因为虚函数再调用时才会根据运行时状态，调用子类对象的析构函数。编译器又会自动释放基类，从而可以完整的释放这条继承链上的所有对象。不是虚函数的话，会直接调用基类的析构函数，发生<strong>内存泄露</strong> #### 拷贝构造函数 形如下面的code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//调用拷贝构造生成对象</span><br><span class="line">A a ;</span><br><span class="line">A b = A(a);</span><br><span class="line">//函数返回值</span><br><span class="line">A doSomeWork()&#123;</span><br><span class="line">  A work;</span><br><span class="line">  ...</span><br><span class="line">  return work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数参数</span><br><span class="line">void doSomeWork(A other)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 拷贝构造是一定会生成新对象的，可能是临时的，过一会被删除。这也解释了为啥函数参数推荐使用引用或者指针，避免了重复创建临时对象。 关于函数的2种情况实际上可以统一，从程序的内存布局来理解，都是在调用者和被调用者栈帧之间拷贝对象，因为栈帧内的内存会用完就被释放。</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<p>形如下面的code <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line">c=b=a;</span><br></pre></td></tr></table></figure> 赋值号左右两边都是已经存在的对象，不会产生新对象</p>
<h4 id="移动构造函数">移动构造函数</h4>
<p>这个函数还是为了减少内存拷贝带来的特性。在编程中，有些类中会包含大的成员数组，或者大的成员变量。如果在拷贝赋值时可以直接将这个大的成员 直接移动给目标对象，可以减少很多拷贝开销。语义上理解很像是移动或者所有权转移。那怎么去实现他呢？需要一种标志来表示程序员啥时候可以使用移动语义，现在的引用是无法转移的。于是，那些C++大牛们提出了一个另外一种引用，当参数中以这种形式的引用出现时，编译器就会按照移动语义来实现。 一般文献中会称为右值引用,就可以理解为一种引用，不过是用来标志支持移动语义的。左值和右值可以相互转换 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A (A&amp;&amp; other)&#123;</span><br><span class="line">  array  = other.array; //移动</span><br><span class="line">  other.array = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="移动运算符">移动运算符</h4>
<p>和上面类似的，运算符两边都是已经存在的对象，并且是移动语义</p>
<p><strong>注意</strong> 拷贝构造/拷贝赋值与移动构造和移动赋值如果自己提供了其中一个，则编译不会提供另一个。因为只要有一种就都可以编译通过。可通过=default来声明</p>
<p>前面的测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/construct ### 汇编验证 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person()&#123;&#125;</span><br><span class="line">	Person(const Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; operator=(const Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Assign&quot; &lt;&lt; endl;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void f(Person p)</span><br><span class="line">&#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person f1()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Person p1 = p;    // 1</span><br><span class="line">	Person p2;</span><br><span class="line">	p2 = p;           // 2</span><br><span class="line">	f(p2);            // 3</span><br><span class="line"></span><br><span class="line">	p2 = f1();        // 4</span><br><span class="line"></span><br><span class="line">	Person p3 = f1(); // 5</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将上面代码拷贝到https://godbolt.org/ <img src="/img/copy-construct.png" alt="结果" /> # C++的对象模型 面向对象的语言都需要解决下面几个问题: 1. 对象的成员数据存储和访问 2. 对象的成员函数存储和访问 3. 对象的静态成员和方法的存储的访问 4. 在有继承的情况下，前面1，2，3怎么处理 5. 对于多态的运行时绑定策略 6. 对象的创建和释放 ## 几种可能的实现 - 简单对象模型 暴力一点，对每个实例，都把成员数据和成员函数都都拷贝一份，这样不就都可以访问到了吗？静态成员还是要单独存储。 继承把父类的成员数据和函数都拷贝一份，因为每个实例有自己独立的拷贝，所以多态是自然支持的 - 基于表格的模型 第一种的内存消耗太大，虽然访问都是固定时间.于是，我们产生了第二种想法，可以将成员函数和成员数据分开来存储。把成员函数放入一个表格之中，这样成员函数就可以被所有实例共享。成员数据还是随每个实例存储，每个成员额外增加一个指向成员函数表格的指针。想法是根据成员函数有共享性，成员数据是独立性。这里先记住2个名字，函数表指针和函数表 ## C++的成员变量存储和访问 ### 静态变量和静态函数 静态变量是转变成global变量，但会由编译器控制可见性。就类似于普通定义的全局变量.所以访问也是和普通变量类似,通过地址直接访问</p>
<h3 id="无继承的情况">无继承的情况</h3>
<p>类似于c结构体的存储,按照声明变量的顺序和大小，从低地址到高地址存储。当然中间可能会由于体系结构要求的对齐。这里C++并未规定，变量必须连续存储，只要按照变量声明的顺序即可。也就是说，可以在成员变量缝隙间插入特定的内容.详细可见《深入探索对象模型》的第3章3.2节 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  public:</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  virtual void function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 先忽略虚函数表的内容，后面会再介绍 <img src="/img/object-data.png" alt="单一对象" /></p>
<h3 id="单一继承的情况">单一继承的情况</h3>
<p>子类会将父类实例成员拷贝一份.类似于包馅饼。因为这样才可以完整的实现多态，否则向上转型取字段就不对了。 <img src="/img/object-single.png" alt="单一继承" /></p>
<h3 id="多重继承继承树上无重复">多重继承(继承树上无重复)</h3>
<p>就包多次馅饼,从小到大包. 所以此时,如果有重名变量和方法，需要明确指定基类.比如: 两个基类中有重名的方法和变量,SetWeight,则需要用完全限定名称 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SleepSofa a;</span><br><span class="line">a.Bed::SetWeight(1);</span><br><span class="line">a.Sofa::SetWeight(2);</span><br></pre></td></tr></table></figure> <img src="/img/object-multi.png" alt="多重继承" /></p>
<h3 id="多重继承继承树上有重复">多重继承(继承树上有重复)</h3>
<p>这种情况，如果还是包馅饼,对于继承树上重复出现会被多个子节点包进去,造成内存的浪费，也会导致访问和修改的歧义。C++大佬们又想了个办法，(后面你会发现和虚函数的处理策略是类似的).增加了共享继承的机制，用现有的关键字virtual，语义同虚函数相同。在类对象中增加一个虚基类指针，用以指向虚基类在实例中的偏移量。 虚基类指针在内存中放在哪里呢？有2种放置策略 1. 将所有虚继承的父类都搞一个指针放在实例中,指向基类在实例中的内存位置，以用来访问成员。这种每个实例都有额外的指针存储，在基类很多的情况下，开销较大 2. 多个虚继承的父类就搞一个虚继承表(和虚函数表很像),指代基类在实例中的偏移量。由于类的布局是固定的，所以只需要准备一份这个表即可。(根据候捷大佬《深入探索C++模型》原文中说微软编译器是这样做的) 3. 和虚函数表放在一起，gcc和clang是这样做的，下面会详细分析gcc的虚函数表</p>
<figure>
<img src="/img/object-multi-offset.png" alt="共享继承" /><figcaption>共享继承</figcaption>
</figure>
<h2 id="c的成员函数存储和调用">C++的成员函数存储和调用</h2>
<h3 id="静态函数">静态函数</h3>
<p>静态函数就是只能访问静态变量的函数，除此之外函数的存储和调用和其他成员函数无区别，静态函数不能是虚函数，编译期就可以得到地址. ### 继承树中所有类都无虚函数 这种和普通非成员函数调用无区别，编译期就可以确定</p>
<h3 id="虚函数">虚函数</h3>
<h4 id="无继承">无继承</h4>
<p>编译器会创建一个虚函数表,在实例中增加一个隐藏成员,这个成员指向虚函数表的位置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">   Base() = default;</span><br><span class="line">   virtual ~Base() = default;</span><br><span class="line">   </span><br><span class="line">   void FuncA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   virtual void FuncB() &#123;</span><br><span class="line">       printf(&quot;FuncB\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   int a;</span><br><span class="line">   int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   Base a;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/img/function-single.png" alt="无继承" /> <strong>注意</strong> 详细介绍一下虚函数表中的概念， 1. 整个虚函数表,是一个数组,每一项8字节（64位架构下）固定长度,所以可以按照偏移量来索引 1. function pointer 存储虚函数的区域,每一项都是一个内存地址,指向函数的入口,按照源码顺序来排列 2. virtual base offset 虚函数表中有些项存储的是虚基类的偏移量 3. offset to top 这种项记录的是和当前实际类型的开头的偏移量 下面给出一个简单vtable例子,有个简单的印象 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vtable for A</span><br><span class="line">A::vtable for A: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; typeinfo for A)</span><br><span class="line">16    (int (*)(...))A::af</span><br></pre></td></tr></table></figure></p>
<h4 id="单继承的情况这种很重要平常用的最多而且是理解后续模型的基础">单继承的情况(这种很重要,平常用的最多,而且是理解后续模型的基础)</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">   Base() = default;</span><br><span class="line">   virtual ~Base() = default;</span><br><span class="line">   </span><br><span class="line">   void FuncA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   virtual void FuncB() &#123;</span><br><span class="line">       printf(&quot;Base FuncB\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   int a;</span><br><span class="line">   int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   Base a;</span><br><span class="line">   Derive d;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/function-single-no.png" alt="无覆盖" /> <img src="/img/function-single-override.png" alt="有覆盖" /></p>
<p><strong>注意</strong> 这里可以发现,父类的vptr指针指向的也是子类的vtable.如果子类有覆盖父类的方法,虚函数表中就填子类的,如果没有就把父类的拷贝过来.每个类都有自己的虚函数表,并不是通过共享虚函数表来实现继承的.</p>
<h4 id="多重继承">多重继承</h4>
<p>这种是每个继承树上的每一个类在实例内存中指向自己类的function pointer,这样在调用基类虚函数时，会查找到实际类型的函数地址,从而实现多态 下面会详细介绍如果根据虚函数表查找实际类型的函数地址 <strong>注意</strong> 这里有个主基类的说法，编译器会在继承的父类中找一个有虚方法的父类，复用他的vptr,在调用主基类的方法时不需要调整this指针。下面虚函数表的会详细解释 <img src="/img/object-multi-function.png" alt="多重继承" /></p>
<h4 id="虚继承">虚继承</h4>
<p>在继承树上有重复类的时候,根据前面对象数据成员内存布局,需要添加一个基类的偏移量来表示每个基类在实例中的内存位置.gcc是把基类指针放在虚函数表中,下面会详细介绍虚函数表</p>
<figure>
<img src="/img/object-multi-offset.png" alt="虚继承" /><figcaption>虚继承</figcaption>
</figure>
<figure>
<img src="/img/object-multi-offset-2.png" alt="虚继承" /><figcaption>虚继承</figcaption>
</figure>
<h1 id="虚函数表">虚函数表</h1>
<p>这些内容比较复杂,另起一篇文章 <a href="/2023/09/25/C++/gcc的虚函数表">gcc的虚函数表</a></p>
<h1 id="gcc查看虚函数表">gcc查看虚函数表</h1>
<p><a href="/2023/09/25/C++/gcc的虚函数表">gcc的虚函数表</a></p>
<h1 id="gdb打印对象内存布局">gdb打印对象内存布局</h1>
<h2 id="gdb命令">gdb命令</h2>
<ol type="1">
<li><p>每行打印一个结构体成员 可以执行set print pretty on命令，这样每行只会显示结构体的一名成员，而且还会根据成员的定义层次进行缩进</p></li>
<li><p>按照派生类打印对象 set print object on</p></li>
<li><p>查看虚函数表 通过如下设置：set print vtbl on</p></li>
</ol>
<p>之后执行如下命令查看虚函数表：info vtbl 对象或者info vtbl 指针或引用所指向或绑定的对象</p>
<ol start="4" type="1">
<li>c++名称转换 GNU提供的从name mangling后的名字来找原函数的方法，c++filt工具,执行c++filt _ZTV1A 在线反修饰名称的网站http://demangler.com/</li>
</ol>
<figure>
<img src="/img/object-in-memory.png" alt="对象布局" /><figcaption>对象布局</figcaption>
</figure>
<figure>
<img src="/img/object-vtbl.png" alt="对象布局" /><figcaption>对象布局</figcaption>
</figure>
<h1 id="汇编查看实例函数调用">汇编查看实例函数调用</h1>
<p>汇编中会额外增加一个this指针,一般是放在rdi寄存器中</p>
<h1 id="总结">总结</h1>
<p>基本要解决的问题是下面几个？ 1. 如何保证子类可以继承父类的成员和非虚方法？这两种是编译期就可以决定访问地址的,主要思想是包馅饼，vtable和成员都是类似的思想 2. 如何保证子类调用自己重载的虚方法？每个基类都有一个指针，指向子类的vtable,并在调用非主要基类的子类方法时调整this指针</p>
<h1 id="补充">补充</h1>
<p>MSVC ABI和Itanium ABI(gcc和clang遵循这个标准) C++ Itanium ABI 主要分为四大板块：</p>
<p>指导程序中的各种数据结构如何正确而一致地在内存中布局（Data Layout）； 指导在二进制层面如何调用其他函数（调用约定，Calling Convention）； 为 C++ 的异常处理机制提供正确的实现（Exception Handling）； 定义输入到链接器的对象文件的格式（Linkage &amp; Object Files）</p>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a href="https://blog.csdn.net/qiuguolu1108/article/details/114797246">gcc生成默认构造器的策略</a></li>
<li><a href="https://blog.csdn.net/shltsh/article/details/45959271">gcc生成拷贝构造和默认构造的策略</a></li>
<li>深入探索C++对象模型-候捷</li>
<li><a href="https://www.cnblogs.com/qg-whz/p/4909359.html">图解对象内存模型</a></li>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Developer-Options.html">gcc deveploper option 打印对象vtable内存布局</a></li>
<li><a href="https://github.com/v4if/blog/issues/15">gdb 打印内存布局</a></li>
<li><a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">Itanuim ABI</a></li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>//2023/09/19/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="类之间的运算">类之间的运算</h1>
<p>这里可以利用抽象代数的观点来看待这种处理,把运算扩充到任意的集合上,而不是只在数集上.运算可以对应于某个集合下元素之间的关系,可以在运算的世界中表达逻辑.在软件工程观点来看,让代码变得简洁</p>
<h1 id="c运算符重载用同一个运算符完成不同的运算功能">C++运算符重载：用同一个运算符完成不同的运算功能。</h1>
<h2 id="限制">限制</h2>
<h3 id="基本原则">基本原则</h3>
<p>C++运算符重载的相关规定如下： 1.不能改变运算符的优先级。 2.不能改变运算符的结合性。 3.默认参数不能和重载的运算符一起使用，也就是说，在设计运算符重载成员函数时不能使用默认函数。 4.不能改变运算符的操作数的个数。 5.不能创建新的运算符，只有已有运算符可以被重载 6.运算符作用于C++内部提供的数据类型时，原来含义保持不变 7. 重载的运算符至少有一个操作数是自定义类型 ### C++中可被重载的运算符： <img src="/img/override.png" alt="可被重载" /> ### 不可被重载的运算符 - sizeof - .: 成员运算符 - .* 成员指针运算符 - :: 作用域运算符 - ?:: 条件运算符 - typeid: 运行时信息运算符 - const_cast/dynamic_cast/static_cast/reinterpret_cast 类型转换运算符 上面这些并不是表达元素之间的运算关系,而是取成员和类型转换,这些由类的元数据决定,当一个类确定之后,这些的运算结果就应该是确定的</p>
<h3 id="只可通过成员函数重载">只可通过成员函数重载</h3>
<ul>
<li>= 赋值</li>
<li>() 函数调用</li>
<li>[] 下表</li>
<li>-&gt; 通过指针访问类成员</li>
</ul>
<h3 id="格式">格式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数类型   	operator	重载运算符（形参表）</span><br><span class="line">&#123;</span><br><span class="line">	函数体；</span><br><span class="line">&#125;</span><br><span class="line">//非成员函数</span><br><span class="line">friend	函数类型	operator	重载运算符（形参表）</span><br><span class="line">&#123;</span><br><span class="line">	函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原理">原理</h2>
<p>实际上都是编译器做了特定表达式/类型下运算符-&gt;函数的转换.最终都被编译器转换成函数 ## 实例 ### 重载自增自减运算符 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using	namespace	std;</span><br><span class="line">class MyClass2</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">public:</span><br><span class="line">	MyClass2(int i)&#123; n = i; &#125;</span><br><span class="line">	int operator ++()&#123; n++; return n; &#125;</span><br><span class="line">	int operator ++(int)&#123; n += 2; return n; &#125;</span><br><span class="line">	void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	MyClass2 A(5), B(5);</span><br><span class="line">	A++;</span><br><span class="line">	++B;</span><br><span class="line">	A.display();</span><br><span class="line">	B.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 重载双目运算符 ### 成员函数 假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。 若把op重载为A类的成员函数，该函数只有一个形参，形参的类型是obj2所属的类型。是把op前面的看成对象,op右边的看出函数参数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1.operator op(obj2)</span><br></pre></td></tr></table></figure> ### 友元函数 假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。 若把op重载为A类的友元函数，该函数有两个形参，经过重载之后，表达式“obj1 op obj2”解释为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj1 op(obj1,obj2)</span><br></pre></td></tr></table></figure></p>
<h2 id="重载赋值运算符">重载赋值运算符</h2>
<p>哈哈,这里不就是我们熟悉的拷贝构造函数和赋值运算符.找到理论和实际的结合点了 ## 重载下标运算符 下标运算符“[ ]”通常用于获取数组的某个元素，重载下标运算符可以实现数组下标的越界检测等。下标运算符重载只能作为类的成员函数，不能作为类的友元函数。 ## 重载new delete换运算符 new和delete只能被重载为类的成员函数，不能重载为友元。而且，无论是否使用关键字static进行修饰，重载了的new和delete均为类的静态成员函数。 运算符new重载的一般格式如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void	*类名：：operator	new(size_t,参数表)；</span><br><span class="line">void* operator new(size_t size,int x,int y,int z)</span><br><span class="line">&#123;……</span><br><span class="line">&#125;</span><br><span class="line">void *类名“::operator delete(void*,参数表);</span><br></pre></td></tr></table></figure> 使用如下: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x*pX=new(1,2,3) X;</span><br></pre></td></tr></table></figure> ## 重载类型转换运算符 这个特性是和拷贝构造函数对应的,比如有一个类Stock可以根据传入的double来构造, <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Stock&#123;</span><br><span class="line">    public:</span><br><span class="line">     Stock(double t)&#123;</span><br><span class="line">        value = t;</span><br><span class="line">     &#125;</span><br><span class="line">    int value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 那么如果要将Stock转出double呢,就要用到下面的类型转换运算符.这两个函数是一一对应的 格式: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">operator 类型名（）</span><br><span class="line">&#123;</span><br><span class="line">	函数体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 重载函数调用运算符 函数调用运算符“（）”只能说明成类的非静态成员函数，该函数具有以下的一般格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数类型 类名：：operator()(参数表)</span><br></pre></td></tr></table></figure> ## 重载移位运算符 按照输入流和输出流的概念,如果能有一种运算符可以让对象直接和输入流输出流交互,就不用再写printf(&quot;%s&quot;)这种冗余代码了,还要记类型的format. 于是我们想,把移位看出向输入流和输出流传递数据,正好有左移和右移.开口大的流向开口小的.于是会有下面的代码: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出流 &lt;&lt;  obj</span><br><span class="line">输入流 &gt;&gt;  obj </span><br></pre></td></tr></table></figure> 幸运的是,C++大佬们设计出了这样的特性. 根据友元函数运算符重载的特点,对于双目操作符是将 obj1 op opj2转换成 op(obj1,obj2); 并且这样还可以支持任意一种自定义类型却不用修改std库中输入流和输出流的代码.这实际上也是友元函数重载解决的问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person &#123;</span><br><span class="line">	friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	Person(int a, int b)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;m_A = a;</span><br><span class="line">		this-&gt;m_B = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="line">	//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">	//&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int m_A;</span><br><span class="line">	int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//全局函数实现左移重载</span><br><span class="line">//ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; </span><br><span class="line">    		//ostream是标准的输出流，全局只能有一个，所以用引用引用的方式</span><br><span class="line">	out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">	return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">	Person p1(10, 20);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	test();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="运算符重载的坑">运算符重载的坑</h2>
<h3 id="意外的类型转换">意外的类型转换</h3>
<p>在编程实践中,对于类型转换和拷贝构造函数有可能发生了意外的隐式转换,导致bug,所以最好是加上explict关键字,告诉编译器不要做隐式转换 ### 重载双目运算符不满足交换律 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using	namespace	std;</span><br><span class="line">class MyClass2</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">public:</span><br><span class="line">	MyClass2(int i)&#123; n = i; &#125;</span><br><span class="line">	MyClass2 operator +(int a)&#123; n+=a; return n; &#125;</span><br><span class="line">	void display()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    friend  MyClass2 operator +(MyClass2 a, int  b)&#123; </span><br><span class="line">       a.n += b;</span><br><span class="line">       return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	MyClass2 A(5), B(5);</span><br><span class="line">    A = 5 + A;// 会报错</span><br><span class="line">	A.display();</span><br><span class="line">	B.display();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 例子中会无法通过编译,因为双目运算符成员函数左边必须是对象，友元重载必须参数类型要匹配(按照前面双目运算符的等价函数调用来理解)。这就导致的加法不满足交换律.</p>
<h3 id="过多的转换函数导致的二义性">过多的转换函数导致的二义性</h3>
<p>假定Stock有形参为double的拷贝构造函数,并且重载了Stock类之间的加法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stock a(1.0);</span><br><span class="line">double b = 2.0;</span><br><span class="line">Stock total;</span><br><span class="line">total = a + b;// 将b转成Stock，再相加</span><br></pre></td></tr></table></figure> 如果此时还又定义了Stock到double的转换函数,那么最后一行将不知道是将a转成double还是将b转成Stock,导致歧义</p>
<h1 id="测试代码见">测试代码见</h1>
<p><a href="https://github.com/dingweiqings/study/tree/master/cpp_study/src/operator">我的github</a> # 引用 1. C++ Prime Plus 2. <a href="https://cloud.tencent.com/developer/article/1688289">C++重载运算符实例</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>std库</title>
    <url>//2023/09/20/C++/std/</url>
    <content><![CDATA[<p>正文见我的有道云笔记 https://note.youdao.com/s/TzGJhYmG</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>std库 模板</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>//2022/11/22/java/HashMap/</url>
    <content><![CDATA[<h1 id="哈希表">哈希表</h1>
<p>是一种kv的数据结构，插入查找都是O(1)的</p>
<h1 id="哈希函数">哈希函数</h1>
<p>用来生成key的哈希值的函数,一般都是根据类成员的哈希值再相加</p>
<h1 id="jdk中的hashmap">jdk中的HashMap</h1>
<p>哈希表的一种实现,插入和查找都是依据 key的哈希函数生成的哈希值来确定位置的。冲突时使用的是拉链法</p>
<h1 id="put">put</h1>
<p>主要流程: 1. 调用哈希函数获取哈希值，对数组长度取余，找到对应的桶。 如果桶中无元素，直接放入 如果桶中有元素，再看是否和当前元素和已有元素是否相同， 如果相同，则覆盖原有的值 如果不相同，则使用拉链法，在链表尾部插入一个节点或者把链表变成树 下面结合代码来解释：<br />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">         <span class="type">int</span> h;</span><br><span class="line">         <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)<span class="comment">//如果还没有初始化数组,则初始化一个</span></span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)<span class="comment">//如果对应的桶处没有元素,则创建一个</span></span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//p是对应桶处的元素,这里是在判断是否是同一个key</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//冲突的元素，链表法或者转成树(一般不会走到)</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//在最后面加上一个节点</span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果相同，则覆盖原有的值</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">//如果达到阈值则扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> # get 主要流程是 1. 先用哈希函数找到对应的桶，如果已经存在，再遍历链表或者树 下面结合代码来解释： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">              ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="扩容">扩容</h1>
<p>主要流程 1. 扩容大小为原来2倍，更新阈值为容量*loadFactor 2. 找到在新数组中的位置,这个有个简单的数学原理 由于扩容是总是扩容2倍，一开始大小也是2的幂次，故大小总是为2的幂次 设当前大小为newsize，则 <code>hash % newsize = hash &amp; (newsize-1)</code>; 因为比newsize低的位都会是余数的位。 更进一步,设某个桶在原数组中下标为x，在新数组中下标为y，原数组大小为oldsize,则x,y满足 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hash % oldsize=x</span><br><span class="line"><span class="title function_">if</span> <span class="params">(hash &amp; oldsize ==<span class="number">1</span> )</span>&#123;</span><br><span class="line">    y = x + oldsize<span class="comment">//分支1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    y = x<span class="comment">//分支2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 原因还是因为比数组大小低的位哪些会对余数产生贡献。</p>
<p>根据上面原理，在拷贝原数组的元素时，只需要将桶后面的链表拆分成2部分，一部分属于分支1，一部分属于分支2，放入对应的桶中即可 下面结合代码来解释 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">       <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   <span class="comment">//将原来的链表拆分成2部分,先叫做low和high吧</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">//根据最后一位来判断是要放入low部分还high部分</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                       <span class="comment">// //把low部分的链表头部放入 newTab[j]位置</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//把high部分的链表头部放入 newTab[j + oldCap]位置</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>hashmap 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap</title>
    <url>//2022/11/22/java/TreeMap/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树 平衡搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>//2022/11/22/java/ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="线程安全">线程安全</h1>
<h1 id="线程安全的哈希表">线程安全的哈希表</h1>
<h1 id="成员变量">成员变量</h1>
<h1 id="put">put</h1>
<h1 id="get">get</h1>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrent hash map</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>//2022/11/22/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="java的执行流模型">java的执行流模型</h1>
<p>java应用是单进程多线程模式,执行流的实体是线程，每个线程拥有自己独立的调用栈,堆和打开文件是共享的。线程实际上是对体系结构中的多线程的支持。</p>
<h1 id="java的多线程">java的多线程</h1>
<p>线程是一个对象，这个对象可以执行某个函数，我暂且叫他运行函数。此外线程还有休眠,中断,加入，和线程私有存储等功能。实际上线程更像是一个worker,worker有执行task的能力，并且worker还可以和其他worker协作。当程序员需要另起一个执行流的时候，就需要使用线程.大白话就是你用一个线程来放歌，一个线程来浏览网页,一个线程来下载电影. 在大数据技术栈中的zk,es,hadoop等等都是这种多线程模式,一组线程负责心跳,一组线程负责内部rpc，一组线程提供外部访问</p>
<h2 id="简单介绍下jvm的线程实现">简单介绍下jvm的线程实现</h2>
<p>jvm实际上是一个c++程序,在linux中被执行后就进入jvm的入口函数,这里会封装env,开辟堆内存,初始化jit等等，最后会启动一个main线程，来执行程序员编写的main函数。Main线程和普通线程的执行模型区别并不大。下面是创建普通线程的代码. 只有在调用线程start方法时，才会真正在linux中创建线程 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;);<span class="comment">//这里Thread实际是一个普通对象,对其中的parent,线程id做了一些赋值</span></span><br><span class="line">      thread.start();<span class="comment">//这里才真正在操作系统中创建线程，并加入linux的就绪队列</span></span><br></pre></td></tr></table></figure> <strong>注意</strong> 判断在jvm主进程中还是在java虚拟机中： 1. 只要是调用了native方法，都是在jvm主进程中直接执行的.普通的java方法都是经过jvm字节码翻译/编译后执行的。比如gc和jdk库中的一些native方法. 2. 如果要访问java虚拟机外的资源就只能在jvm主进程中 Main线程是jvm主进程帮忙创建,并调用start方法. 这里借用一下网上的一张时序图.start0() 这个本地方法，最终映射到了 JVM_StartThread 这个方法中，在`<code>hotspot\src\share\vm\prims\jvm.cpp</code> <img src="/img/thread-start.png" alt="线程启动" /> 如果你对C++比较熟悉的话，会发现java的线程实际上还是pthread_create出来的，所以线程的sleep,interput都是调用的native方法，因为需要访问linux的线程，在jvm中是做不到的。</p>
<h2 id="线程中断">线程中断</h2>
<p>和cpu中断类似，对于执行流模型来说，都需要一个中断机制来中断执行流.cpu通过中断来响应外部事件，陷入操作系统等.* 线程中断可以用做终止线程的标志位;对于线程阻塞在某些可中断方法的场景，中断会抛出中断异常，让程序员来处理中断阻塞方法的后置处理 <strong>注意</strong> 1. 线程中断标志位并不会终止线程，只是设置了一个标志位 2. Thread.interupted() 方法会有副作用，清空当前的标志位。我觉得这个叫clearInterupted更好,返回值是当前的中断标志位。因为需要提供一个方法来清空标志位.</p>
<h1 id="线程池的作用">线程池的作用</h1>
<p>线程池是一种资源池，可以达到复用的效果.此外，还可以增加并行度(因为线程是一个worker). - 常见的资源线程池有：数据库链接池等. - 常见的任务线程池有：tomcat的service线程池,netty的event事件处理线程池,spring的定时任务线程池等 线程池在软件工程上来说，也实现了线程调度和业务逻辑的分离。 # jdk的线程池框架 采用的还是抽象基类的模式.Executor是最顶层接口. AbstractExecutorService是抽象基类.常见的线程池实现有定时任务线程池ScheduledThreadPoolExecutor,实时线程池ThreadPoolExecutor <img src="/img/thread-pool-h.png" alt="继承" /></p>
<h2 id="jdk线程池的特性">jdk线程池的特性</h2>
<p>如何描述一个线程池？自然的是池里面有多少个线程,因此有核心线程数(最小线程数)，最大线程数,线程存活时间.线程池还需要给定一个异常处理策略，否则线程池不知道该如何处理执行发生时的异常.线程池也是一个资源池，访问资源会出现排队的情况，因此也需要指定线程池的队列大小 1. 核心线程数，最大线程数 2. 异常处理策略 3. 队列大小 4. 线程存活时间</p>
<h2 id="threadpoolexecutor详解基于jdk11">ThreadPoolExecutor详解(基于jdk11)</h2>
<p>先提出几个问题？ 如何维护线程keepAlive？ 如何执行任务？ 线程池如何退出？ ### 线程池状态维护 线程池维护了几个成员,corePoolSize,maxinumPoolSize,keepAliveTime,rejectHandler,workQueue(保存任务的阻塞队列),mainLock(主要是用来控制对线程池成员的并发访问的),ctl(是个int,但是分段使用的,高位保存的是线程池的状态,低位保存的是线程的woker数量)</p>
<p>线程池总共有5个状态,所以用到了int的高3位. 状态机是 RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED,越往后数字越大。 正常关闭是RUNNING -&gt; SHUTDOWN -&gt; TIDYING -&gt; TERMINATED; 立即关闭是RUNNING -&gt; STOP -&gt; TIDYING -&gt; TERMINATED <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>; <span class="comment">//29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;<span class="comment">//1向右移动29位，来到第30位,再 减1变成, 连续的29个1  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 111, 补码，最低位是3个1 ,这个状态是里面最小的,</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 011</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比SHUTDOWN小的就只有RUNNING，也可以用runStateOf(ctl) == RUNNING 来比较,搞不懂为啥这样写,逻辑反而更复杂了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">    runStateAtLeast(c, TIDYING) ||</span><br><span class="line">    (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">    interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125; <span class="comment">//state对应的是work count那一段全部为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125; <span class="comment">// work count对应的是取mask</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125; <span class="comment">//ctl = runState + workCount ,位运算的知识</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="执行任务">执行任务</h3>
<p>当在调用submit/execute时，主要流程如下: 1. 先检查线程池状态，如果已经处于SHUTDOWN或者更高级别，则不往线程池里面加;如果是running，并且小于coreSize，则新创建线程来执行 2. 如果大于coreSize，则看能否加到队列里去 3. 如果加不到队列里去，如果没有大于max线程数，则开启一个线程去处理 下面对照代码来解释前面的流程: <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">//小于coreSize，则直接addWorker；</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//addWorker内部会检查线程池状态，如果处于SHUTDOWN就不再加了</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是运行中,则尝试加入到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// //并发访问控制在在addWorker中已经做了，这里主要是在shutdown状态下，不再加入任务，将先前加入的并移出去</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果是running,并且没有大于maxSize则开启一个线程    </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">//这里第二参数表示非核心线程的意思</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是running,并且没有大于maxSize则开启一个线程;如果队列满了并且没有大于maxSize则开启一个线程；</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 接下来看addWorker方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">//这里如果是SHUTDOWN以上的，就直接终止流程</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="literal">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//校验最大线程数在这里</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//如果修改workerCount成功了,就表示增加woker成功了,</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">//如果workerCount没有修改成功，继续获取状态，继续修改</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建worker</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        <span class="comment">//用锁保护的woker set</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让worker开始执行</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 接下来看worker类,worker继承了AQS.它的lock逻辑上表达的是正在执行的,非idle的.主要流程是： 1. 如果是第一个task,则取出来， 2. 不断循环从队列中取数据,不断执行任务.如果在<strong>keepAliveTime时间内没有取到任务，线程就自动退出了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不断取任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//前置后置钩子函数</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//执行</span></span><br><span class="line">                        task.run();</span><br><span class="line">                        afterExecute(task, <span class="literal">null</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        afterExecute(task, ex);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">                &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//超过keepAliveTIme，就返回</span></span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="线程池退出">线程池退出</h3>
<p>主要流程是： 1. 修改线程池状态 2. 中断idle的线程 3. 等待原先加入到线程中的任务被执行完 下面对照代码来解释前面的流程： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置下一个状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">//中断那些idle的,</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">//设置state</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这里设置线程中断标志好像并不是必要的，因为只要线程池处于TERMINATED状态(在调用shutdown之后,线程池的SHUTDOWN状态是内部状态),无法再提交任务，队列中的任务总会被执行完。这也是线程池设计的目标，不会丢掉任何一个没有执行的任务。并且中断标志并不会终止线程，只是设置标志。所以我理解这里是保持一致性，在线程池被调用shutdown之后，需要保持线程的中断标志都被设置。可能在<strong>提交的任务里有根据中断来作为终止条件的</strong>.</p>
<h1 id="总结">总结</h1>
<p>开头提出的问题： 1. 如何保持线程的keepAlive? 如果在keepAlive时间内，在阻塞队列中没有取到任务，线程就执行完毕并退出 2. 如何执行任务? 用一个while循环，不断从阻塞队列中取任务，并调用task.run() 3. 如何退出？ 线程池会维护内部的状态，在调用shutdown之后，就设置为TERMINATED,等待阻塞队列中已有任务执行完，线程会挨个终止，自然线程池也就退出了</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列</title>
    <url>//2022/11/22/java/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="队列">队列</h1>
<p>fifo的一种数据结构</p>
<h1 id="jdk中的阻塞队列">jdk中的阻塞队列</h1>
<p><img src="/img/block-queue.png" alt="block queue" /> <img src="/img/block-queue-impl.png" alt="jdk中的block queue" /></p>
<h2 id="下面以linkedblockingqueue为例来讲解">下面以LinkedBlockingQueue为例来讲解</h2>
<p>主要是利用ReentrantLock和条件变量来实现并发安全的,有一个AtomicInteger成员，记录容量。有插入锁和获取锁.对于队满和队空不管是offer还是take都会做通知 ## offer 主要流程 1. 在入队前先获取锁，在入队后释放锁.如果队满和队空做下通知 下面结合代码讲解 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">      <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">      <span class="comment">//获取put锁</span></span><br><span class="line">      putLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//如果满了，则直接失败</span></span><br><span class="line">          <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              <span class="comment">//入队</span></span><br><span class="line">          enqueue(node);</span><br><span class="line">          <span class="comment">//这里是先get再add</span></span><br><span class="line">          c = count.getAndIncrement();</span><br><span class="line">          <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">              notFull.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//释放锁</span></span><br><span class="line">          putLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为上面是先get再add,只有当从不空变为空时才通知消费者</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">          signalNotEmpty();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure> ## offer限定时间 主要流程和前面的offer一样，主要是获取put锁变成了支持中断,如果在队满的时候,就加个超时等待，给定时间内队列依旧是满的，则失败 下面结合代码讲解 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">       <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">       putLock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               nanos = notFull.awaitNanos(nanos);</span><br><span class="line">           &#125;</span><br><span class="line">           enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">           c = count.getAndIncrement();</span><br><span class="line">           <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">               notFull.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           putLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">           signalNotEmpty();</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure> ## poll 主要流程 1. 获取take锁，然后出队，并在队空和队满时做通知 下面结合代码讲解 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">      <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">final</span> E x;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">      <span class="comment">//获取take锁</span></span><br><span class="line">      takeLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          x = dequeue();</span><br><span class="line">          c = count.getAndDecrement();</span><br><span class="line">          <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//通知</span></span><br><span class="line">              notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == capacity)<span class="comment">//如果前一步是等于队列容量，现在取出来了一个，就不满了，通知在入队的生产者</span></span><br><span class="line">          signalNotFull();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="poll限定时间">poll限定时间</h2>
<p>和前面poll的流程差不多，主要是加了个在队空时的超时等待 下面结合代码讲解 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="keyword">final</span> E x;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line">      <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">      takeLock.lockInterruptibly();<span class="comment">//可中断获取锁</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">              nanos = notEmpty.awaitNanos(nanos);<span class="comment">//等待</span></span><br><span class="line">          &#125;</span><br><span class="line">          x = dequeue();</span><br><span class="line">          c = count.getAndDecrement();</span><br><span class="line">          <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">              notEmpty.signal();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == capacity)</span><br><span class="line">          signalNotFull();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>阻塞队列 java queue</tag>
      </tags>
  </entry>
  <entry>
    <title>非阻塞队列</title>
    <url>//2022/11/22/java/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="队列">队列</h1>
<p>fifo的一种数据结构</p>
<h1 id="jdk中的非阻塞队列">jdk中的非阻塞队列</h1>
<h2 id="concurrentlinkedqueue">ConcurrentLinkedQueue</h2>
<p>主要流程 下面结合代码来解释 ### offer <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(Objects.requireNonNull(e));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (NEXT.compareAndSet(p, <span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time; failure is OK</span></span><br><span class="line">                    TAIL.weakCompareAndSet(<span class="built_in">this</span>, t, newNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ### poll 主要流程 下面结合代码来解释 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        restartFromHead: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123;</span><br><span class="line">                <span class="keyword">final</span> E item;</span><br><span class="line">                <span class="keyword">if</span> ((item = p.item) != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> &#123;</span><br><span class="line">        <span class="comment">// assert h != null &amp;&amp; p != null &amp;&amp; (h == p || h.item == null);</span></span><br><span class="line">        <span class="keyword">if</span> (h != p &amp;&amp; HEAD.compareAndSet(<span class="built_in">this</span>, h, p))</span><br><span class="line">            NEXT.setRelease(h, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="linkedtransferqueue">LinkedTransferQueue</h2>
<p>LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。 ### 核心方法 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">xfer</span><span class="params">(E e, <span class="type">boolean</span> haveData, <span class="type">int</span> how, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (haveData &amp;&amp; (e == <span class="literal">null</span>))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"></span><br><span class="line">    restart: <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>, t = <span class="literal">null</span>, h = <span class="literal">null</span>;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> (t != (t = tail) &amp;&amp; t.isData == haveData) ? t</span><br><span class="line">                 : (h = head);; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node q; <span class="keyword">final</span> Object item;</span><br><span class="line">            <span class="keyword">if</span> (p.isData != haveData</span><br><span class="line">                &amp;&amp; haveData == ((item = p.item) == <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (h == <span class="literal">null</span>) h = head;</span><br><span class="line">                <span class="keyword">if</span> (p.tryMatch(item, e)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (h != p) skipDeadNodesNearHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> (E) item;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (how == NOW) <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="literal">null</span>) s = <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">                <span class="keyword">if</span> (!p.casNext(<span class="literal">null</span>, s)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (p != t) casTail(t, s);</span><br><span class="line">                <span class="keyword">if</span> (how == ASYNC) <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">return</span> awaitMatch(s, p, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == (p = q)) <span class="keyword">continue</span> restart;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="offer">offer</h3>
<p>主要流程 下面结合代码来解释</p>
<h3 id="poll">poll</h3>
<p>主要流程 下面结合代码来解释 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> xfer(<span class="literal">null</span>, <span class="literal">false</span>, NOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="poll超时">poll超时</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> xfer(<span class="literal">null</span>, <span class="literal">false</span>, TIMED, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> || !Thread.interrupted())</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>非阻塞队列 java queue</tag>
      </tags>
  </entry>
  <entry>
    <title>可重入锁</title>
    <url>//2023/10/05/java/%E9%94%81%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="锁框架">锁框架</h1>
<p>基于抽象基类的设计模式，抽象基类是AbstractQ # jdk</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jdk 锁框架</tag>
      </tags>
  </entry>
  <entry>
    <title>gc</title>
    <url>//2023/10/04/jvm/gc/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>x86体系结构</title>
    <url>//2023/10/06/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="x86实模式">x86实模式</h1>
<p>x86实模式的内存模型是物理地址=段地址*16+偏移地址 # x86保护模式 这是另外一种分段的内存模型.由于实模式下有20根地址线,在x86-32架构下有32位地址线，那么如何去使用和管理这4g的内存？并且现在机器都是多任务的，需要任务之间隔离内存访问。于是，x86-32的保护模式，采用了表格登记分配的方式。段先在全局的一张表格中登记.表格实际上是一个数组，每个元素8字节，里面保存的段的基地址和段的界限，基地址+界限就可以确定一个段</p>
<p>然后在访问内存时，段寄存器不再表示基地址，而表示在表格中的序号,通过序号查找到在内存中的区块.这样表示有很多好处，可以对段加权限标记,x86-32是有2位来表示段权限，总共有4个权限.cpu在访问时，<strong>用sp的权限(当前代码段的权限)</strong>表示当前cpu的权限,如果比要访问的段权限高，就可以访问，否则拒绝访问;也可以对16位程序保持兼容;也可以对任务实现内存隔离</p>
<p>一般把这个表格叫做GDT，cpu会有一个寄存器记录GDT的首地址</p>
<h1 id="x64长模式">x64长模式</h1>
<p>有2种子模式，纯的64位模式和兼容模式(kernel工作在64位，在返回应用时工作在32位) # 引用 1. <a href="https://blog.csdn.net/abc123lzf/article/details/109289567">x86保护模式</a></p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>即时编译</title>
    <url>//2023/10/04/jvm/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>elasticsearch查询</title>
    <url>//2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/elasticsearch/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>文件系统源码</title>
    <url>//2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>spark</title>
    <url>//2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>mysql查询源码</title>
    <url>//2023/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9F%A5%E8%AF%A2%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>LSM树</title>
    <url>//2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LSM%E6%A0%91/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LSM</tag>
      </tags>
  </entry>
  <entry>
    <title>x86-16汇编</title>
    <url>//2023/09/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86-16%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h1 id="计算模型">计算模型</h1>
<p>计算模型是一种表达计算方式的模型，是我们日常见到的物理计算机的计算方式的抽象。有穷自动机和图灵机是计算模型。 ## 有穷自动机 可以从我们常见的状态机来理解，比如tcp网络状态机，缓存一致性状态机，编译原理中的DFA,业务中的订单流转状态机都属于状态机。自动机是一种模型机，它根据系统当前状态和一个给定的输入来确定系统下一步将进入哪个状态或者下一步执行哪个动作。但它只会从一个状态进入另一个状态，并不会有其他额外的数据存储。于是，我们根据自动机的特点，构建出一种模型,这种模型可以用来识别和判断字符串是否符合正则表达式，状态转换是否合法等等. 用一个寄存器来存储当前状态，预先给这个模型设定好状态转化图。让模型一开始处于Start状态,然后不断读取输入字符串/状态转换路线，因为是有限的状态机，最终会终止.如果终止状态可以被Accept，则是合法. <strong>注意</strong> 有穷自动机的计算能力是很有限的，只能根据给定的状态机来判断输入是否合法 ## 图灵机 仔细思考我们可以发现，上面的计算模型： 1. 只能保存一个状态，而且不可保存数据，只能读取外部输入.于是我们可以增加另外一块存储区域,用来支持写数据。 2. 在读取输入字符串只能不断向前移动，不能向后移动. 于是，设计这样一种模型.这时输入字符串(不再是固定的状态转换路线)就可以是下面几种操作: - 读存储区的数据 - 向存储区写数据 - 数据运算 - 读指针向后跳转 这就是经常说的图灵机纸带，读写头可以向前移动(不断读取新指令),向后移动(重新执行先前执行过的指令),移动到空白纸带(读写存储区) <strong>注意</strong> 图灵机已经拥有很强大的计算能力</p>
<h2 id="通用图灵机">通用图灵机</h2>
<p>仔细思考我们可以发现，图灵机的模型，给定一个问题的算法后，便可以解决这一类问题。但是对于输入字符串该如何编写，如何用指令来描述解决问题的算法？所以需要对图灵机支持的指令进行规定。于是，我们又有一个新的模型，把指令集也作为一种输入给图灵机，这样图灵机就可以根据指令集和预先给定的算法来自动的处理和解决问题。这种将算法和指令集作为输入的模型称为通用图灵机(和图灵机的计算模型和计算能力并无不同)，这样，我们就可以不需要让模型依赖于解决问题的算法. ## 冯诺依曼机 下面，我们将图灵机做进一步的组件拆分，把读写输入指令的叫做控制器，支持存储的区域叫做存储器，把运算指令单独作为一个部件，再加上输入和输出设备，这样图灵机就可以根据预先给定的指令，来处理输入数据，并将结果传输到输出设备中。</p>
<p><strong>注意</strong> 冯诺依曼机拥有和图灵机一样的计算能力，此外还具备和输入输出能力。这也是现代计算机的组成模型</p>
<figure>
<img src="/img/冯诺依曼机.png" alt="冯诺依曼机" /><figcaption>冯诺依曼机</figcaption>
</figure>
<h1 id="计算机软硬协同">计算机软硬协同</h1>
<p>代入上面的理论，可以发现，具体的一个物理计算机实际上是通用图灵机的实现，物理计算机所支持的指令集就是通用图灵机的输入，相当于预先给定了一个输入，算法的输入就交给程序员。计算机系统分为硬件和软件，那么软件如何驱动硬件呢，就要根据机器支持的指令集,访问内存模型，访问输入输出设备模型来编写指令，硬件就只管读取输入的指令串，就实现了软件编程。一般的指令集有intel和AMD的x86，AArch64,mips等 <strong>注意</strong> x86分为32位和64位,一般叫做x86_32和x86_64(简称为x64)。AArch32和AArch64是arm架构下的32位和64位指令集。IA64是intel不兼容的x86_32的64位指令集，安装在安腾处理器上，主流市场不常见.</p>
<h1 id="计算机算术">计算机算术</h1>
<p>整数表示:补码表示(原理是溢出截断情况下运算的等价性)<a href="https://segmentfault.com/a/1190000038969769">参考</a> 浮点表示: 科学计数法的表示，尾数和指数<a href="https://zhuanlan.zhihu.com/p/358417700">参考</a></p>
<h1 id="计算机体系结构">计算机体系结构</h1>
<h2 id="cpu">cpu</h2>
<p>cpu包含了冯诺依曼机中的运算器和控制器(CS,IP).CPU不断执行取出指令，解码指令，执行指令。cpu让IP寄存器始终指向指令区域的下一条，每执行一条指令，ip就指向下一条指令，直到碰到异常或者程序退出。CPU会支持中断，当外部设备或者使用中断指令中断cpu时(外中断)，cpu会跳转到中断处理函数处。cpu内部在遇到运算异常，访问内存权限异常也会发生中断(内中断),并转到中断处理函数处。CPU和其他部件通过总线来相连，总线包括地址总线(用来对内存单元寻址)，数据总线(传输数据)，控制总线(发送控制信号) ## 内存 内存以字节为基本单位划分为内存单元，cpu通过地址总线来确定访问哪个内存单元。内存地址范围是从0-最大值</p>
<h2 id="输入输出设备">输入输出设备</h2>
<p>比如磁盘，GPIO，flash等，cpu通过读写寄存器并按照固定的协议和外部设备交互。</p>
<h1 id="x86-16汇编">x86-16汇编</h1>
<h2 id="x86-16寄存器">x86-16寄存器</h2>
<p>分为通用寄存器，段寄存器,标志寄存器等。 通用寄存器包括：ax,bx,cx,dx 段寄存器包括:ds,cs,ss,es 标志寄存器： eflags(用来存储执行指令过程中溢出，是否为0等标志) ## x86实模式访存模型 cpu一加电就进入实模式，实模式的内存模型是下面这样的 <img src="/img/8086CPU-visit.png" alt="内存模型" /> 物理地址=段地址<em>16+偏移地址 cpu访问内存按照实际地址来访问，比如访问0x01就是访问从ds</em>16+0x01位置开始向递增方向一个字节的内容。偏移地址最多使用4个部分来指定(应对不同的数据结构) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target address = BaseReg + IndexReg + Disp</span><br></pre></td></tr></table></figure> 可以按照实际中常用的访问类型来理解： 1. 最简单的就是只有一个Disp,实际上就是绝对地址访问，比如 Disp = 0x01 1. 要用到BaseReg一般是访问某个内存块内部的单元 1. 要用到IndexReg部分的一般是数组访问,比如BaseReg指向数组首地址，IndexReg指向数组第几个元素，当数组存的是结构体时，Disp可以表示结构体内的成员</p>
<p><strong>注意</strong> x86实模式下如果不加段前缀，则默认使用的数据段前缀DS.保护模式下分段策略由GDT,LDT和段选择子决定</p>
<h2 id="传送指令前面是目的操作数后面是源操作数">传送指令(前面是目的操作数，后面是源操作数)</h2>
<p>向寄存器传输立即数 <code>mov ax,01H</code> 把内存单元传输到寄存器 <code>mov ax,[01]</code> 把寄存器传输到内存单元 <code>mov [01],ax</code> 寄存器之间传参 <code>mov ax,bx</code>,把bx传输给ax <strong>注意</strong> 段寄存器只能从通用寄存器传送</p>
<h2 id="运算指令">运算指令</h2>
<p>add和sub，<code>sub ax,bx</code>是 ax= ax - bx，这两个是无进位/借位的加减 <img src="/img/add-sub.png" alt="add-sub" /> adc和sbb , 这两个是无进位/借位的加减 mul和div 这两个是无符号乘法除法,并且是单操作数 被乘数放在AL/AX中，这是x86的默认寄存器规则，有些指令会默认使用特定的寄存器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MUL reg/mem8</span><br><span class="line">MUL reg/meml6</span><br></pre></td></tr></table></figure> |被乘数| 乘数| 乘积| |----|---|---| |AL |reg/mem8| AX| |AX|reg/mem16| DX:AX|</p>
<p>如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置1。例如，当AX乘以一个 16 位操作数时，乘积存放在 DX和AX(从高到低)寄存器对中。其中，乘积的高16位存放在DX，低16位存放在AX。如果DX不等于零，则进位标志位置1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。 被除数都是放在DX:AX中 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DIV reg/mem8</span><br><span class="line">DIV reg/meml6</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AX</td>
<td>reg/mem8</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr class="even">
<td>DX:AX</td>
<td>reg/mem16</td>
<td>AX</td>
<td>DX</td>
</tr>
</tbody>
</table>
<p>imul和idiv是有符号乘除法，基本行为和无符号乘除法一致 and和or <code>and ax,bx</code>逻辑与和逻辑或</p>
<p><strong>问题</strong> x86乘除法支持多操作数码？</p>
<h2 id="控制跳转指令">控制跳转指令</h2>
<p>跳转分为近转移(只修改ip，段内跳转)和远转移(同时改变cs和ip,段间跳转)， - 标号跳转: <code>jmp short 标号(jmp near pt 标号)</code> 近转移 <code>jmp far ptr 标号</code> 远转移 - 绝对地址跳转,跳转地址由寄存器或者内存单元给出 <code>jmp reg</code> <code>jmp word ptr [内存单元]</code> <code>jmp dword ptr [内存单元]</code>, 从内存单元开始处存放着2个字(x86字是16位),高位是目的段地址，低位目的偏移地址 - 有条件跳转 jcxz 如果cx==0就跳转 跳转可以用来实现分支和循环 ## 入栈和出栈指令 push ax push 01h pop ax ## 调用子过程指令 call 和ret/retf call 标号 相当于 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip </span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure> ret相当于 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ip</span><br></pre></td></tr></table></figure></p>
<p>因此也对应近跳转和远跳转，标号跳转和绝对地址跳转。绝对地址跳转和上面类似，同时支持寄存器和内存单元</p>
<h2 id="中断指令">中断指令</h2>
<p>int n,向cpu发起中断.cpu便会查找中断表中的中断号n所在的位置，跳转到中断号n对应的处理函数去处理 int n 相当于 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushf </span><br><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line"># 查中断表得到中断处理函数</span><br><span class="line">call cs:ip</span><br></pre></td></tr></table></figure> iret从中断处返回,相当于 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure> ## 汇编语法 - intel语法 1. 寄存器前无前缀 1. 源操作数在后，目的操作数在前 2. 内存单元用方括号表示,并且地址是[INDEX * WIDTH + BASE + OFFSET] 3. 立即数无前缀，十六进制以h结尾 - AT&amp;T 语法 1. 寄存器前有百分号 2. 源操作数在前，目的操作数在后 3. 内存单元用圆括号表示,并且地址是offset(base, index, width)的格式 4. 立即数前被冠以“$”,十六进制数前被冠以“0x” ## 汇编器 ### gnu汇编 主要是as汇编器，gcc将c语言编译后也是调用的as汇编器 ### nasm汇编 另外一种汇编器,同时支持intel和AT&amp;T语法 ### 伪指令 伪指令是汇编器支持的指令，比如有IF,DD等。这些不会翻译成机器指令，和编译器的宏和include有点类似</p>
<h1 id="使用qemu学习汇编">使用qemu学习汇编</h1>
<h2 id="安装qemu我是ubuntu系统">安装qemu(我是ubuntu系统)</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu</span><br></pre></td></tr></table></figure>
<p>如果机器上出现了<code>qemu-system-x86_64</code> <code>qemu-system-i386</code>就表示安装成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">org 0x7c00 ;告诉汇编器程序的入口地址</span><br><span class="line">mov ax,1</span><br><span class="line">mov bx,2</span><br><span class="line">add ax,bx				  </span><br><span class="line">db 0x55,0xaa  ;结束表示，整个段程序的大小正好为510字节，占满一个扇区。</span><br></pre></td></tr></table></figure>
<h2 id="编译汇编代码并制作启动盘">编译汇编代码并制作启动盘</h2>
<p>这里原理就是机器加电bios自检通过后，bios会加载磁盘上第一个扇区(MBR扇区),并执行其中的代码。第一个扇区是用来引导操作系统。把咱们写的汇编程序放入这个扇区，bios会加载并执行这段代码 ### 编译boot代码 要加-f bin nasm fat.s -f bin -o ../out/boot.bin ### 制作软盘(用linux的loop设备将文件模拟成设备) dd if=/dev/zero of=../out/floopy bs=512 count=2880 sudo losetup /dev/loop11 ../out/floopy sudo mkfs.fat /dev/loop11 这步会留出主分区 sudo losetup -d /dev/loop11 卸载设备</p>
<p>将上面编译得到的bin写入mbr,写入上面软盘的第一个扇区 dd if=../out/boot.bin ibs=512 of=../out/floopy obs=512 count=1 seek=0 conv=notrunc</p>
<h2 id="使用qemu启动并使用gdb-debug">使用qemu启动，并使用gdb debug</h2>
<p>-ex 表示启动时执行的命令, -fda指定启动的软盘 qemu-system-i386 -fda ../out/floopy -s -S gdb -ex 'set architecture i8086' -ex 'target remote :1234' -ex 'b *0x7c00' -ex 'layout asm' 这里加的断点0x7c00是x86架构加电后ip指向的位置，咱们编写汇编程序也是放在0x7c00. <strong>注意</strong> 如果你是使用qemu-system-x86_64平台启动的,需要把架构设置成i386:x86-64即 <code>set architecture i386:x86-64</code>,具体看gdb报错信息 <img src="/img/qemu-gdb-dir.png" alt="目录结构" /> <img src="/img/qemu-mbr.png" alt="qemu-gdb" /> ### 后续 你就可以写更多的汇编，并用qemu，gdb调试了,此时汇编是跑在裸机上.后面你会发现，这步实际上就是操作系统boot.但这对于底层的学习才是万里长征第一步，后面还有x86-32,x86-64,x86-64的AVX，保护模式和长模式 # 汇编的用处 在操作系统内核中，经常要用到，比如机器加电引导操作系统(裸机上)，并设置保护模式，在网卡接收数据触发中断，陷入内核时，做的上下文切换(这种一般是被c调用)。</p>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a href="https://zhuanlan.zhihu.com/p/435426287">从图灵机到冯诺依曼机</a></li>
<li>计算复杂性-现代方法</li>
<li>汇编语言-王爽</li>
<li><a href="https://github.com/liracle/codeOfAssembly/blob/master/x86%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E4%BB%8E%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%88%B0%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F.pdf">x86汇编语言从实模式到保护模式</a></li>
<li><a href="https://www.felixcloutier.com/x86/">x86指令手册</a></li>
</ol>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>x86-16汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>循环码</title>
    <url>//2023/09/26/%E7%BC%96%E7%A0%81/%E5%BE%AA%E7%8E%AF%E7%A0%81/</url>
    <content><![CDATA[<h1 id="通信">通信</h1>
<p>主流的理解是将通信看成信息编码+信息传输+信息解码,这里不涉及到应用层的具体协议解读.只是将源产生的信息在经过不可靠信道传输之后,目的端能够接收并正确还原到多少.</p>
<h1 id="编码定理">编码定理</h1>
<p>TODO</p>
<h1 id="循环码">循环码</h1>
<p>这块内容涉及到相当多的理论证明,等我后面慢慢研究再补充</p>
]]></content>
      <categories>
        <category>信号与编码</category>
      </categories>
      <tags>
        <tag>CRC</tag>
      </tags>
  </entry>
  <entry>
    <title>crc算法实现</title>
    <url>//2022/11/21/%E7%AE%97%E6%B3%95/crc%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="奇偶校验">奇偶校验</h1>
<p>校验位只有一位,根据编码长度中1的个数来确定这1位的数值 有两种校验方法：奇校验和偶校验,实际上是根据看奇数为1还是偶数为1,可以在接收端模2来校验 奇校验：原始码流+校验位 总共有奇数个1 偶校验：原始码流+校验位 总共有偶数个1 <img src="/img/odd.png" alt="图示" /></p>
<h1 id="数学原理">数学原理</h1>
<h2 id="编码的数学推导">编码的数学推导</h2>
<h3 id="模2除法">模2除法</h3>
<p>无进位的相加/无进位的相减/异或这些说的都是一个东西，以4bit长度为例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1101</span><br><span class="line">+ 1011</span><br><span class="line">--------</span><br><span class="line">  0110 </span><br></pre></td></tr></table></figure> 模2除法就是二进制除法，但是在相减时采用无进制相减</p>
<figure>
<img src="/img/module-2.png" alt="除法" /><figcaption>除法</figcaption>
</figure>
<h3 id="多项式代数和多项式除法">多项式代数和多项式除法</h3>
<p>高等代数中的多项式代数知识 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M/N=Q...R </span><br><span class="line"></span><br></pre></td></tr></table></figure> 这里容易得到，R会比N幂次要低，就和整数除法m/n=q..r ，0&lt;=r&lt;n 一样 1. 除法规则-竖式除法 每次消去余数最高项，直到余数最高次项小于除数 <a href="../../assets/divide.png">!除法</a></p>
<h3 id="编码算法">编码算法</h3>
<p>将二进制看成多项式,这里是整个crc想法来源. 比如 1101可以看成<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.226ex" height="2.072ex" role="img" focusable="false" viewBox="0 -833.9 4962 915.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(722.2,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(2953.2,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="msup" transform="translate(3953.4,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="33" xlink:href="#MJX-1-TEX-N-33"></use></g></g></g></g></g></svg></mjx-container>,从高到低的第i个数字为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="4.078ex" height="1.912ex" role="img" focusable="false" viewBox="0 -833.9 1802.6 844.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1123,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g></g></g></svg></mjx-container>.因为网络序是大端序,高位先传输</p>
<p>设校验码+原信息长度共n位,其中校验码长度为k.在msg长度为n位的前提下，介绍一个除式,记作G(x),其最高项次数为k,并记原信息叫做S(x),最高项次数为n-k-1.</p>
<p>则根据多项式的带余除法,知一定存在一对唯一的P(x)和R(x)使得<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="29.174ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 12894.8 1103.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-1-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(1378,0)"><use data-c="1D458" xlink:href="#MJX-1-TEX-I-1D458"></use></g></g></g><g data-mml-node="mi" transform="translate(1997.8,0)"><use data-c="1D446" xlink:href="#MJX-1-TEX-I-1D446"></use></g><g data-mml-node="mo" transform="translate(2642.8,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(3031.8,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(3603.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(4270.6,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(5326.4,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(6077.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(6466.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7038.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mi" transform="translate(7427.4,0)"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(8213.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(8602.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(9174.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(9785.6,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(10785.8,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(11544.8,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(11933.8,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(12505.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,其中R(x)的次数小于Q(x)的次数,<strong>存在性和唯一性对模2带余除法也成立(后面会做证明)</strong>. 于是将原先的多项式带余除法推广到模2带余除法，自然就有</p>
<p>此时再令<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="24.337ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 10756.8 1103.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-1-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1138,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1710,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2376.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="msup" transform="translate(3432.6,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(1378,0)"><use data-c="1D458" xlink:href="#MJX-1-TEX-I-1D458"></use></g></g></g><g data-mml-node="mi" transform="translate(5430.4,0)"><use data-c="1D446" xlink:href="#MJX-1-TEX-I-1D446"></use></g><g data-mml-node="mo" transform="translate(6075.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(6464.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7036.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7647.6,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(8647.8,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(9406.8,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(9795.8,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(10367.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>，这一步是关键,因为模2除法相加和相减结果是一样的,是可以被整除的，余式为0.即由<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="24.337ex" height="2.497ex" role="img" focusable="false" viewBox="0 -853.7 10756.8 1103.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-1-TEX-I-1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1138,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1710,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2376.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="msup" transform="translate(3432.6,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(600,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(1378,0)"><use data-c="1D458" xlink:href="#MJX-1-TEX-I-1D458"></use></g></g></g><g data-mml-node="mi" transform="translate(5430.4,0)"><use data-c="1D446" xlink:href="#MJX-1-TEX-I-1D446"></use></g><g data-mml-node="mo" transform="translate(6075.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(6464.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7036.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7647.6,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(8647.8,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(9406.8,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(9795.8,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(10367.8,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,可得 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="24.889ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11001 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1138,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1710,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2321.2,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(3321.4,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(4080.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4469.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(5041.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(5708.2,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(6764,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(7515,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(7904,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(8476,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mi" transform="translate(8865,0)"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(9651,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(10040,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(10612,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,可得.</p>
<p>于是当接收端收到数据后，再做<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.238ex;" xmlns="http://www.w3.org/2000/svg" width="8.561ex" height="3.607ex" role="img" focusable="false" viewBox="0 -1047.1 3783.9 1594.2" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(233.1,516.8) scale(0.707)"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1138,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1710,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g><g data-mml-node="mrow" transform="translate(220,-370.3) scale(0.707)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(786,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1175,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1747,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g><rect width="1710.4" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2228.2,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(3283.9,0)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g></g></svg></mjx-container></p>
<h3 id="模2带余除法存在性和唯一性">模2带余除法存在性和唯一性</h3>
<h4 id="存在性">存在性</h4>
<p>因为与普通带余除法每区别，不管是无进位相减还是带进位相减，最终都会得到一个结果，故存在性比较显然</p>
<h4 id="唯一性">唯一性</h4>
<p>设另外存在P(x)和T(x)，也满足条件.则有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="34.157ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 15097.4 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(786,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1175,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1747,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2136,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(2525,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(3276,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(3665,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(4237,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(4848.2,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(5848.4,0)"><use data-c="1D444" xlink:href="#MJX-1-TEX-I-1D444"></use></g><g data-mml-node="mo" transform="translate(6639.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(7028.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7600.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7989.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(8656.2,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(9712,0)"><use data-c="1D447" xlink:href="#MJX-1-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(10416,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(10805,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(11377,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11988.2,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(12988.4,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(13747.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(14136.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(14708.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,因为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.511ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7298 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path><path id="MJX-1-TEX-N-2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(751,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1140,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1712,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2323.2,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(3323.4,0)"><use data-c="1D444" xlink:href="#MJX-1-TEX-I-1D444"></use></g><g data-mml-node="mo" transform="translate(4114.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4503.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(5075.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(5742.2,0)"><use data-c="2260" xlink:href="#MJX-1-TEX-N-2260"></use></g><g data-mml-node="mn" transform="translate(6798,0)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g></g></svg></mjx-container>,故<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="16.333ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 7219 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-1-TEX-I-1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path><path id="MJX-1-TEX-N-2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-1-TEX-I-1D447"></use></g><g data-mml-node="mo" transform="translate(704,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1093,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1665,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2276.2,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mi" transform="translate(3276.4,0)"><use data-c="1D445" xlink:href="#MJX-1-TEX-I-1D445"></use></g><g data-mml-node="mo" transform="translate(4035.4,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4424.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(4996.4,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(5663.2,0)"><use data-c="2260" xlink:href="#MJX-1-TEX-N-2260"></use></g><g data-mml-node="mn" transform="translate(6719,0)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g></g></svg></mjx-container> <strong>注意这里用的是模2加减法</strong></p>
<h3 id="能检测哪些错误">能检测哪些错误</h3>
<p>这里最主要的是一个建模,核心在这里。是沟通理论和实际的桥梁。接下来就是理论上的证明了.所以我们思考问题的时候，是需要去寻找理论中的概念和原理，并将其和实际对应起来.对于包含错误的bit流可以看成 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.378ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9007 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D43B" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 219 683Q260 681 355 681Q389 681 418 681T463 682T483 682Q499 682 499 672Q499 670 497 658Q492 641 487 638H485Q483 638 480 638T473 638T464 637T455 637Q416 636 405 634T387 623Q384 619 355 500Q348 474 340 442T328 395L324 380Q324 378 469 378H614L615 381Q615 384 646 504Q674 619 674 627T617 637Q594 637 587 639T580 648Q580 650 582 660Q586 677 588 679T604 682Q609 682 646 681T740 680Q802 680 835 681T871 682Q888 682 888 672Q888 645 876 638H874Q872 638 869 638T862 638T853 637T844 637Q805 636 794 634T776 623Q773 618 704 340T634 58Q634 51 638 51Q646 48 692 46H723Q729 38 729 37T726 19Q722 6 716 0H701Q664 2 567 2Q533 2 504 2T458 2T437 1Q420 1 420 10Q420 15 423 24Q428 43 433 45Q437 46 448 46H454Q481 46 514 49Q520 50 522 50T528 55T534 64T540 82T547 110T558 153Q565 181 569 198Q602 330 602 331T457 332H312L279 197Q245 63 245 58Q245 51 253 49T303 46H334Q340 38 340 37T337 19Q333 6 327 0H312Q275 2 178 2Q144 2 115 2T69 2T48 1Q31 1 31 10Q31 12 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D43B" xlink:href="#MJX-1-TEX-I-1D43B"></use></g><g data-mml-node="mo" transform="translate(888,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1277,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1849,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2515.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3571.6,0)"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(4320.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4709.6,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(5281.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(5892.8,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(6893,0)"><use data-c="1D438" xlink:href="#MJX-1-TEX-I-1D438"></use></g><g data-mml-node="mo" transform="translate(7657,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(8046,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(8618,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,其中F(x)是加上校验码的bit,E(x)是信道传输过程中可能错误的bit. 如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.238ex;" xmlns="http://www.w3.org/2000/svg" width="10.321ex" height="3.607ex" role="img" focusable="false" viewBox="0 -1047.1 4561.9 1594.2" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(227.8,516.8) scale(0.707)"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-1-TEX-I-1D438"></use></g><g data-mml-node="mo" transform="translate(764,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1153,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1725,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g><g data-mml-node="mrow" transform="translate(220,-370.3) scale(0.707)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(786,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1175,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1747,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g><rect width="1710.4" height="60" x="120" y="220"></rect></g><g data-mml-node="mo" transform="translate(2228.2,0)"><g data-mml-node="text"><use data-c="2260" xlink:href="#MJX-1-TEX-N-2260"></use></g><g data-mml-node="text" transform="translate(778,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g></g><g data-mml-node="mn" transform="translate(4061.9,0)"><use data-c="30" xlink:href="#MJX-1-TEX-N-30"></use></g></g></g></svg></mjx-container>,则表示存在错误.如果选择的G(x)能够使下面命题成立,则表示可以检测出错误. <strong>当余数为0等价于E(x)为0</strong> ...(命题1) <strong>E(x)不为0时等价余数不为0</strong> ...(命题2) 解释：余数为0也可能是G(x)整除E(x).命题1和命题2也是等价的 #### 定理1 如果G(x)至少有2项,则可以检测出所有的单bit错误 证明: 单bit错误表示<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.834ex" height="2.444ex" role="img" focusable="false" viewBox="0 -830.4 4346.5 1080.4" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D438" xlink:href="#MJX-1-TEX-I-1D438"></use></g><g data-mml-node="mo" transform="translate(764,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1153,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1725,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2391.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="msup" transform="translate(3447.6,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g></g></g></g></g></svg></mjx-container>,那么只有当G(x)形如<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.034ex" height="1.904ex" role="img" focusable="false" viewBox="0 -830.4 899 841.4" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="TeXAtom" transform="translate(605,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g></g></g></g></g></svg></mjx-container>时才E(x)会被整除。只要G(x)至少有2项那么就无法整除E(x). 命题1成立 #### 定理2 如果<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.191ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2294.4 748" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(722.2,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(1722.4,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g></g></g></svg></mjx-container>是G(x)因式,则可以被检测所有的奇数个bit错误 证明:假定通过G(x)生成的编码信息为F(x),</p>
<p>则<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="53.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 23727.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1138,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(1710,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2376.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3432.6,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(4183.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(4572.6,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(5144.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mi" transform="translate(5533.6,0)"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(6319.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(6708.6,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(7280.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(7947.3,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(9003.1,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(9754.1,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(10143.1,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(10715.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11104.1,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(11493.1,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(12215.3,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(13215.6,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(13787.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(14176.6,0)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(15399.1,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(15788.1,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(16360.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(17026.9,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(18082.7,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(18471.7,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(19193.9,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(20194.1,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(20766.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(21155.1,0)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="mo" transform="translate(22377.7,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(22766.7,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(23338.7,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container> 其中 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="41.038ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 18138.9 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-I-1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path><path id="MJX-1-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="mo" transform="translate(1222.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1611.6,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(2183.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2850.3,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(3906.1,0)"><use data-c="1D443" xlink:href="#MJX-1-TEX-I-1D443"></use></g><g data-mml-node="mo" transform="translate(4657.1,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(5046.1,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(5618.1,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(6007.1,0)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="mo" transform="translate(7229.7,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(7618.7,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(8190.7,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(8579.7,0)"><use data-c="2C" xlink:href="#MJX-1-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(9024.3,0)"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(9810.3,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(10199.3,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(10771.3,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(11438.1,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(12493.9,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(12882.9,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(13605.1,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mi" transform="translate(14605.3,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(15177.3,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(15566.3,0)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g></g><g data-mml-node="mo" transform="translate(16788.9,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(17177.9,0)"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(17749.9,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,</p>
<p>令x=1可得<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="20.049ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8861.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D439" xlink:href="#MJX-1-TEX-I-1D439"></use></g><g data-mml-node="mo" transform="translate(749,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1138,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1638,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="mo" transform="translate(2304.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(3360.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(3749.6,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(4471.8,0)"><use data-c="2B" xlink:href="#MJX-1-TEX-N-2B"></use></g><g data-mml-node="mn" transform="translate(5472,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(5972,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g><g data-mml-node="msub" transform="translate(6361,0)"><g data-mml-node="mi"><use data-c="1D43A" xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="TeXAtom" transform="translate(819,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g></g><g data-mml-node="mo" transform="translate(7583.6,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(7972.6,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(8472.6,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,</p>
<p>故F(1)一定是偶数,F(x)又是多项式,故F(x)一定有偶数项.所以当发生奇数个错误时余式一定不为0.命题2成立</p>
<h4 id="剩下的定理">剩下的定理</h4>
<p>原论文中总共给出了8条定理,目前水平有限,等待后续领悟。</p>
<h3 id="原论文">原论文</h3>
<p>原论文是大牛<a href="https://en.wikipedia.org/wiki/W._Wesley_Peterson">Peterson</a>在1961年发布的论文<a href="https://apt.cs.manchester.ac.uk/ftp/pub/apt/papers/Peterson-Brown_61.pdf">Cyclic Code for Error Detection</a>.</p>
<h3 id="crc碰撞">crc碰撞</h3>
<p>这里介绍2个单词,在编码领域会经常要讨论的一个问题.冲突概率conflict collisions.我之前其实一直想不通,既然会有概率冲突，为啥还可以用来做校验呢？</p>
<p>后面我想明白了，<strong>加密安全和传输校验不一样</strong>，信息传输过程中<strong>即使碰到了冲突也是可以接受的，接收端就认为这是源端发送的数据</strong>。但是当校验错误，接收端就要求源端重新发送。还有一个特性就是，信道一般发生错误集中在某一段内，不会产生各种各样的花式错误.</p>
<p>就像md5一样，虽然大家一直在用，但md5也会有冲突，愿意使用就表示接受冲突带来的结果。md5由我国的王小云院士优化了破解算法<a href="http://merlot.usc.edu/csac-f06/papers/Wang05a.pdf">md5冲突</a><a href="https://zh.wikipedia.org/zh-sg/%E7%8E%8B%E5%B0%8F%E9%9B%B2">王院士</a>,感兴趣的同学可以看下<a href="https://infosec.sdu.edu.cn/info/1043/1121.htm">王院士的主页</a>.</p>
<h4 id="碰撞分析">碰撞分析</h4>
<p>这块涉及到比较复杂的数学知识，留作自己后续的研究方向.</p>
<h3 id="常用的除数多项式">常用的除数多项式</h3>
<p>所以检测错误的能力和选择多项式的特性有关，不是随便瞎选的 见wiki<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Polynomial_representations_of_cyclic_redundancy_checks">常用的多项式</a></p>
<h2 id="算法实现">算法实现</h2>
<ol type="1">
<li><p>朴素的竖式多项式除法的翻译 这里主要思路是用商消去最高位，然后在输入的数组上减去商*生成多项式，因此余数也是保存在输入的被除多项式位置 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int divide( double num[], int nlen,</span><br><span class="line">            double den[], int dlen,</span><br><span class="line">            double quotient[], int *qlen )</span><br><span class="line">&#123;</span><br><span class="line">    int n, d, q;</span><br><span class="line">    // The lengths are one more than the last index; decrement them</span><br><span class="line">    // here so the call is less confusing</span><br><span class="line">    nlen--;</span><br><span class="line">    dlen--;</span><br><span class="line">    q = 0;</span><br><span class="line">    // when n &gt; dlen, the result is no longer a polynomial</span><br><span class="line">    // (e.g. trying to divide x by x^2)</span><br><span class="line">    for ( n = nlen; n &gt;= dlen; n-- )</span><br><span class="line">    &#123;</span><br><span class="line">      // First, divide the nth element of numerator with the last element</span><br><span class="line">      // of the denominator</span><br><span class="line">      quotient[ n - dlen ] = num[ n ] / den[ dlen ];</span><br><span class="line">      q++;</span><br><span class="line">      // Now, multiply each element of the denominator by each</span><br><span class="line">      // corresponding element of the numerator and subtract the</span><br><span class="line">      // result</span><br><span class="line">      for ( d = dlen; d &gt;= 0; d-- )</span><br><span class="line">      &#123;</span><br><span class="line">        num[ n - ( dlen - d ) ] -= den[ d ] * quotient[ n - dlen ];</span><br><span class="line">        //采用模2除法，需要修改成这行代码</span><br><span class="line">        num[ n - ( denlen - d ) ] = fabs( num[ n - ( denlen - d ) ] );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *qlen = q;</span><br><span class="line"></span><br><span class="line">    return ( nlen - *qlen + 1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用异或来计算 这里比较难理解，让我想了很久，还是基于竖式除法的思路，从竖式除法我们可以发现，32位的生成多项式最高位可以不存储，因为每次都是消去最高项；可以用一个32位int来保存余数，长度小于32位的二进制序列余数就是它自己，因此需要在右端补上32位；从竖式除法中我们可以发现，做减法的次数等于被除数长度-除数长度+1； <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned long int compute_crc( unsigned long input,</span><br><span class="line">                               int len,</span><br><span class="line">                               unsigned long divisor )</span><br><span class="line">&#123;</span><br><span class="line">  //要做被除数长度-除数长度+1=24+32-33+1=24  </span><br><span class="line">  while ( len-- )</span><br><span class="line">  &#123;</span><br><span class="line">    //如果最高位是1，那么这位是要被消去，余数等于剩下的和除数异或；如果最高位是0，我们发现最高位死0，实际上是</span><br><span class="line">    //商为0，和全0异或等于它自己，等效于直接左移</span><br><span class="line">    input = ( input &amp; 0x80000000 ) ? divisor ^ ( input &lt;&lt; 1 ) : ( input &lt;&lt; 1 );</span><br><span class="line">  &#125;</span><br><span class="line">  //余数存储在32位，这里实际上等价于竖式多项式的低32位；因为运算过程中，余数始终保存在input位置</span><br><span class="line">  return input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  unsigned long int crc32_divisor = 0x04C11DB7;</span><br><span class="line">  //下面的input按ABC实际上的值字节做了反转，多项式是低字节在低位，为了位对齐</span><br><span class="line">  //   0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, // C</span><br><span class="line">  //   0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, // B</span><br><span class="line">   //  0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0  // A</span><br><span class="line">  unsigned long int input = 0x8242C200; // ABC; backwards &amp; left aligned</span><br><span class="line"></span><br><span class="line">  printf( &quot;%lx\n&quot;, compute_crc( input, 24, crc32_divisor ); // 5A5B433A</span><br></pre></td></tr></table></figure> ## crc查表法 https://www.cnblogs.com/esestt/archive/2007/08/09/848856.html</p></li>
</ol>
<h2 id="常见组件关于crc的实现">常见组件关于crc的实现</h2>
<ol type="1">
<li>mariadb中用的是查表，或者使用cpu的sse来计算 <a href="https://github.com/MariaDB/server/blob/905c3d61e18ae6222d0d195c43d335046eec65d9/mysys/crc32/crc32c.cc">mariadb crc</a></li>
<li>gcc中zlib <a href="https://github.com/gcc-mirror/gcc/blob/36eec7995b4d53083c3ee7824bd765b5eba8b1a1/zlib/crc32.c#L237">gcc中zlib</a></li>
</ol>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a href="https://pdfs.semanticscholar.org/44c1/4780d58015f8411fb85efa58a4aa3747a6ad.pdf">这是大牛的ppt讲解</a></li>
<li><a href="https://apt.cs.manchester.ac.uk/ftp/pub/apt/papers/Peterson-Brown_61.pdf">crc原论文</a></li>
<li><a href="https://www.shuxuele.com/algebra/polynomials-division-long.html">多项式除法</a></li>
<li><a href="https://blog.csdn.net/weixin_39450145/article/details/83987836">模2除法</a></li>
<li><a href="https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art008">crc32校验和</a></li>
<li><a href="https://github.com/komrad36/CRC">更详细的crc doc</a></li>
</ol>
]]></content>
      <categories>
        <category>信号与编码</category>
      </categories>
      <tags>
        <tag>crc 校验码</tag>
      </tags>
  </entry>
  <entry>
    <title>素数判定和素数筛</title>
    <url>//2022/11/22/%E7%AE%97%E6%B3%95/%E7%B4%A0%E6%95%B0/</url>
    <content><![CDATA[<h1 id="素数判定">素数判定</h1>
<h2 id="埃氏筛法">埃氏筛法</h2>
<ol type="1">
<li>整体流程是从小到大遍历，并将利用小的因数将后面大的合数剔除掉</li>
<li>原理就是合数和素数的判定条件</li>
<li>边界条件就是不能超过n,可以从i*i开始比较</li>
<li>复杂度是O(nloglogn) 埃氏筛的时间复杂度为O(n log log n)，其中n是要筛选质数的范围。具体地，该算法的复杂度可以分为两部分： 1.标记合数的复杂度：O(n)。因为每个数最多只会被标记一次，而每个数最多有log log n个质因数，所以总共需要进行O(n log log n)次操作。 2.枚举质数的复杂度：O(n log log n)。因为每个质数最多只会被枚举一次，而n个数中质数的个数约为n/ln n，所以总共需要进行O(n/ln n)次操作。 因此，总的时间复杂度为O(n log log n)。</li>
</ol>
<h3 id="版本1">版本1</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//初始化标记数组,先标记成都是素数,后面是合数就擦掉</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    is_prime[i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;  <span class="comment">// prime[p]是</span></span><br><span class="line">      <span class="keyword">if</span> (i * i &lt;= n &amp;&amp; i*i &gt; <span class="number">0</span>)<span class="comment">//防溢出</span></span><br><span class="line">      <span class="comment">//i的倍数都是合数,实际上也是i*2,i*3，但由于在2-i-1时已经处理过了,</span></span><br><span class="line">      <span class="comment">//所以接下来从i*i,i*(i+1)=i*i+i,....</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">          is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只筛奇数的版本">只筛奇数的版本</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    is_prime[i] = <span class="number">1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// i * i &lt;= n 说明 i &lt;= sqrt(n)</span></span><br><span class="line">  <span class="comment">//只需要筛一半</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime[p++] = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">        is_prime[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只保留奇数的版本">只保留奇数的版本</h3>
<p>is_prime可以只申请n/2一半，因为偶数肯定是合数</p>
<h1 id="线性筛">线性筛</h1>
<p>如果能让每个合数只被标记一次，复杂度就来到了O(n) <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">      pri[cnt++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">long</span> <span class="type">long</span>)(i * pri[j]) &gt; n)&#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// i 之前被 pri[j] 筛过了</span></span><br><span class="line">        <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i乘上其他的质数的结果一定会被</span></span><br><span class="line">        <span class="comment">// pri[j]的倍数筛掉</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>线性同余</title>
    <url>//2022/11/22/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99/</url>
    <content><![CDATA[<h1 id="随机数算法">随机数算法</h1>
<p>生成真正随机数是比较难的，下面介绍一种常用的伪随机数算法 <img src="/img/lcg.png" alt="lcg" /> <img src="/img/lcg-周期.png" alt="lcg-周期" /> 取到模数n的称为满周期 <img src="/img/lcg-条件.png" alt="lcg-证明" /> # code实现 java中java.util.Random类的实现中，发生器的关键代码如下： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">multiplier</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">addend</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">        <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">        <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldseed = seed.get();</span><br><span class="line">            nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));<span class="comment">//丢弃低比特位，保留高比特位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure> 同时可以看到，上面实现中特意对比特位进行了截取，丢弃低比特位，保留高比特位。 # 数学原理 下面根据<a href="/file/混合线性同余发生器的周期分析.pdf">线性同余满周期的充分性证明中文版</a>论文中来介绍一下充分性,主要思想是得出递推式和x0的关系,将模数m做素数分解,这样会得到一个重要的简化定理，模数m的周期等于模数m素数分解得到的所有因数周期的最小公倍数. - 引理1 设 <figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">x<span class="built_in">_</span>&#123;k&#125;=a<span class="built_in">^</span>&#123;k&#125;x<span class="built_in">_</span>&#123;i&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a href="https://www.icst.pku.edu.cn/zlian/docs/20181023161643742238.pdf">随机数课件</a></li>
<li><a href="https://books.google.com.sg/books?hl=zh-CN&amp;lr=&amp;id=Zu-HAwAAQBAJ&amp;oi=fnd&amp;pg=PT17&amp;ots=9ojjXoVxe_&amp;sig=BqdI06kVqktyfMnAGL8MpvvQyns&amp;redir_esc=y#v=onepage&amp;q&amp;f=false">线性同余满周期充分必要条件的证明</a></li>
<li><a href="/file/混合线性同余发生器的周期分析.pdf">线性同余满周期的充分性证明中文版</a></li>
<li><a href="https://www.cnblogs.com/qcblog/p/8450427.html">线性同余随机数</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title>goyacc</title>
    <url>//2023/09/19/%E7%BC%96%E8%AF%91%E5%99%A8/goyacc%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简单介绍下编译原理">简单介绍下编译原理</h1>
<p>词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码 编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。 AST啥的也理解不透彻. # 词法分析 ## token 解析字符串流,确定一个个的token,比如在c语言中,确定是if,while这些关键字还是变量名,运算符等.最终会生成符号表。 语言中关键字：这些关键字会被保存在一种表中，在解析字符流的时候，如果碰到关键字则直接保留。 ## 词法框架 根据正则表达式来定义某种特定token的规则,在解析字符串流的时候，根据正则来判断属于哪种token ## 常见的词法框架/工具 lex/flex,是通过正则表达式和自定义解析字符串综合工作的</p>
<h1 id="语法分析">语法分析</h1>
<p>主要在于如何表达语法规则和检验语法规则. ## 语法规则 编译器大佬提出了一种文法，只关注字符串的变换.并定义终结符号和非终结符号的概念.非终结符号则可以继续产生新符号,从而用字符串实体表达出了语言的语法规则.非终结符号到另外一个符号串叫做产生式. ## 产生式 比如程序一开始会有一个非终结符号S,对于C语言这个语法来说,会有下面的产生式.下面给出部分产生式做说明 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S -&gt; void main()&#123;B&#125;</span><br><span class="line">B -&gt; Y;</span><br><span class="line">Y -&gt; Y;STATEMENT | e</span><br><span class="line">STATEMENT -&gt; D | A | BLOCK</span><br><span class="line">D -&gt; TYPE id | TYPE* id</span><br><span class="line">BLOCK -&gt; IF(C)&#123;B&#125; ELSE&#123;B&#125; | while(C)&#123;B&#125;</span><br><span class="line">A -&gt; id + id | id -id | id * id | id /id </span><br></pre></td></tr></table></figure> 解释一下上面的产生式,id和e,type这些是终结符. 第1行: S是非终结符号,可以变成main函数,里面是函数体 第2行: 表示函数体可以是分号组成的各种语句 第3行: 表示语句之间是可以不断拼接的,从而理论上可写出无限长度的程序 第4行：表示语句可以有声明语句,算术运算和语句块 第5行: 表示声明语句只能是类型名空格+标志符组成 第6行: 表示语句块可以有条件块和循环块 第7行: 表示算数运算可以有加减乘除 ## 语法分析的实现 给定一组字符串可以是递归去判断,看最终会不会达到终结符,然后比对终结符是否和字符串中的相同.但在实际中采用的是更有效率的DFA表格,预先对产生式处理,然后可以对扫一遍字符串就可以判定是否合法,并构建出语法树</p>
<h2 id="语法树">语法树</h2>
<p>TODO,这块我目前还没搞懂</p>
<h1 id="语法分析框架">语法分析框架</h1>
<p>好在大佬们已经写出来好的工具来给咱们使用了.yacc是语法分析的一种实现，根据用户定义的语法规则，做对应的动作.所有的查询引擎都有这个模块,比如mysql,prometheus.根据不同语言的yacc(c语言),javacc还有goyacc</p>
<h1 id="goyacc做一个简单的计算器">goyacc做一个简单的计算器</h1>
<p>我们来2步走，主要是这2个方法 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type exprLexer interface &#123;</span><br><span class="line">	Lex(lval *exprSymType) int</span><br><span class="line">	Error(s string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type exprParser interface &#123;</span><br><span class="line">	Parse(exprLexer) int</span><br><span class="line">	Lookahead() int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> expr函数前缀,goyacc中可以自定义. 在自己的app中可以直接调用Parser来分析。但要提供lex的实现.下面实例中就可以看到 ## 分析词法 细心的同学就会发现,这里实际上实现了上面lexer的2个接口 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (x *exprLex) Lex(yylval *exprSymType) int &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		c, _, err := x.input.ReadRune()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return eof</span><br><span class="line">		&#125;</span><br><span class="line">		switch c &#123;</span><br><span class="line">		case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;:</span><br><span class="line">			return x.num(c, yylval)</span><br><span class="line">		case &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;:</span><br><span class="line">			return int(c)</span><br><span class="line">		case &#x27;×&#x27;:</span><br><span class="line">			return &#x27;*&#x27;</span><br><span class="line">		case &#x27;÷&#x27;:</span><br><span class="line">			return &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">		case &#x27; &#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\r&#x27;:</span><br><span class="line">		default:</span><br><span class="line">			log.Printf(&quot;unrecognized character %q&quot;, c)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Lex a number.</span><br><span class="line">func (x *exprLex) num(c rune, yylval *exprSymType) int &#123;</span><br><span class="line">	var b bytes.Buffer</span><br><span class="line">	b.WriteRune(c)</span><br><span class="line">L:</span><br><span class="line">	for &#123;</span><br><span class="line">		c, _, err := x.input.ReadRune()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return eof</span><br><span class="line">		&#125;</span><br><span class="line">		switch c &#123;</span><br><span class="line">		case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;e&#x27;, &#x27;E&#x27;:</span><br><span class="line">			b.WriteRune(c)</span><br><span class="line">		default:</span><br><span class="line">			_ = x.input.UnreadRune()</span><br><span class="line">			break L</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	yylval.num = &amp;big.Float&#123;&#125;</span><br><span class="line">	_, ok := yylval.num.SetString(b.String())</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		log.Printf(&quot;bad number %q&quot;, b.String())</span><br><span class="line">		return eof</span><br><span class="line">	&#125;</span><br><span class="line">	return NUM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (x *exprLex) Error(s string) &#123;</span><br><span class="line">	log.Println(&quot;parse error: &quot;, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分析语法">分析语法</h2>
<h3 id="产生式">产生式</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;math/big&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%union &#123;</span><br><span class="line">    num *big.Float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%type &lt;num&gt; expr expr1 expr2 expr3 //  定义在后面的符号比定义在前面的符号具有更好的优先级</span><br><span class="line"></span><br><span class="line">%token &#x27;+&#x27; &#x27;-&#x27; &#x27;*&#x27; &#x27;/&#x27; &#x27;(&#x27; &#x27;)&#x27;</span><br><span class="line"></span><br><span class="line">%token	&lt;num&gt; NUM</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">expr</span><br><span class="line">&#123;</span><br><span class="line">    if $1.IsInt() &#123;</span><br><span class="line">	fmt.Println($1.String())</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fmt.Println($1.String())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expr:</span><br><span class="line">expr1</span><br><span class="line">&#123;&#125;</span><br><span class="line">|</span><br><span class="line">&#x27;+&#x27; expr</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $2</span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">&#x27;-&#x27; expr</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $2.Neg($2)</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr1:</span><br><span class="line">expr2</span><br><span class="line">&#123;&#125;</span><br><span class="line">|</span><br><span class="line">expr1 &#x27;+&#x27; expr2</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $1.Add($1, $3)</span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">expr1 &#x27;-&#x27; expr2</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $1.Sub($1, $3)</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr2:</span><br><span class="line">expr3</span><br><span class="line">&#123;&#125;</span><br><span class="line">|</span><br><span class="line">expr2 &#x27;*&#x27; expr3</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $1.Mul($1, $3)</span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">expr2 &#x27;/&#x27; expr3</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $1.Quo($1, $3)</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">expr3:</span><br><span class="line">NUM</span><br><span class="line">|</span><br><span class="line">&#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">&#123;</span><br><span class="line">    $$ = $2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="应用中如何调用分析器">应用中如何调用分析器</h2>
<p>读取命令行的输入,并调用分析器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	in := bufio.NewReader(os.Stdin)</span><br><span class="line">	a := big.Float&#123;&#125;</span><br><span class="line">	a.String()</span><br><span class="line">	for &#123;</span><br><span class="line">		if _, err := os.Stdout.WriteString(&quot;&gt; &quot;); err != nil &#123;</span><br><span class="line">			log.Println(&quot;WriteString: &quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">		line, err := in.ReadBytes(&#x27;\n&#x27;)</span><br><span class="line">		if err == io.EOF &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalf(&quot;ReadBytes: %s&quot;, err)</span><br><span class="line">		&#125;</span><br><span class="line">    //调用分析器</span><br><span class="line">		exprParse(newExprLex(line))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 运行 ### 安装 go install golang.org/x/tools/cmd/goyacc@latest</p>
<h3 id="goyacc使用">goyacc使用</h3>
<p>Usage of goyacc: -l disable line directives -o string parser output (default &quot;y.go&quot;) -p string name prefix to use in generated code (default &quot;yy&quot;) -v string create parsing tables (default &quot;y.output&quot;) 会根据你的语法规则(.y后缀的)生成.go文件. -o指定文件的名称 -p 指定生成parse函数前缀,默认是叫yyParse,以供外部调用 goyacc -o expr.go -p expr expr.y ### 构建 go build expr.go lexer.go main.go</p>
<h3 id="执行">执行</h3>
<figure>
<img src="/img/caculator.png" alt="运行结果" /><figcaption>运行结果</figcaption>
</figure>
<h1 id="goyacc-做json-parser">goyacc 做json parser</h1>
<p>最主要是整理出json的产生式,然后理解下yacc框架下的整体工作流程，就可以搞出来 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">package jsonparser</span><br><span class="line"></span><br><span class="line">type pair struct &#123;</span><br><span class="line">  key string</span><br><span class="line">  val interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func setResult(l yyLexer, v map[string]interface&#123;&#125;) &#123;</span><br><span class="line">  l.(*lex).result = v</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%union&#123;</span><br><span class="line">  obj map[string]interface&#123;&#125;</span><br><span class="line">  list []interface&#123;&#125;</span><br><span class="line">  pair pair</span><br><span class="line">  val interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token LexError</span><br><span class="line">%token &lt;val&gt; String Number Literal</span><br><span class="line"></span><br><span class="line">%type &lt;obj&gt; object members</span><br><span class="line">%type &lt;pair&gt; pair</span><br><span class="line">%type &lt;val&gt; array</span><br><span class="line">%type &lt;list&gt; elements</span><br><span class="line">%type &lt;val&gt; value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%start object</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">object:</span><br><span class="line">&#x27;&#123;&#x27; members &#x27;&#125;&#x27;</span><br><span class="line">&#123;</span><br><span class="line">	$$=$2</span><br><span class="line">	setResult(yylex, $$)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">members:</span><br><span class="line">&#123;</span><br><span class="line">	$$ = map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">| pair</span><br><span class="line">&#123;</span><br><span class="line">	$$ = map[string]interface&#123;&#125;&#123;$1.key: $1.val&#125;</span><br><span class="line">&#125;</span><br><span class="line">| members &#x27;,&#x27; pair</span><br><span class="line">&#123;</span><br><span class="line">	$1[$3.key] = $3.val</span><br><span class="line">	$$ = $1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair:</span><br><span class="line">String &#x27;:&#x27; value</span><br><span class="line">&#123;</span><br><span class="line">	$$ = pair&#123;key: $1.(string), val: $3&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">array: &#x27;[&#x27; elements &#x27;]&#x27;</span><br><span class="line">&#123;</span><br><span class="line">	$$ = $2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elements:</span><br><span class="line">&#123;</span><br><span class="line">	$$=[]interface&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">| value</span><br><span class="line">&#123;</span><br><span class="line">	$$=[]interface&#123;&#125;&#123;$1&#125;</span><br><span class="line">&#125;</span><br><span class="line">|</span><br><span class="line">elements &#x27;,&#x27; value</span><br><span class="line">&#123;</span><br><span class="line">	$$=append($1, $3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value:</span><br><span class="line">  String</span><br><span class="line">| Number</span><br><span class="line">| Literal</span><br><span class="line">| object</span><br><span class="line">  &#123;</span><br><span class="line">    $$ = $1</span><br><span class="line">  &#125;</span><br><span class="line">| array</span><br></pre></td></tr></table></figure> # 测试代码见 https://github.com/dingweiqings/study/tree/master/goyacc-study</p>
<h1 id="引用">引用</h1>
<ol type="1">
<li>龙书 编译原理</li>
<li><a href="/2023/09/25/编译器/yacc/">yacc使用</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>yacc</tag>
      </tags>
  </entry>
  <entry>
    <title>yacc使用</title>
    <url>//2023/09/25/%E7%BC%96%E8%AF%91%E5%99%A8/yacc/</url>
    <content><![CDATA[<h1 id="简单介绍下编译原理">简单介绍下编译原理</h1>
<p>词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码 编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。 AST啥的也理解不透彻. # 词法分析和语法分析框架 lex和yacc是unix下的词法/语法分析框架, flex/bison是词法/语法分析框架 bison和yacc实际上用途是同一种，不过在不同平台下,yacc已经成为语法分析框架的代名词。下文统一使用lex/yacc</p>
<h1 id="lex和yacc内部是如何工作的">Lex和YACC内部是如何工作的？</h1>
<p>main -&gt;yyparse() -&gt; yylex() yylex 会读取在yyin这个变量中的文件(没有则默认是stdin), yylex不断解析输入流,yyparse不断推导产生式并执行相应动作(在语法文件中定义),直到结束. <strong>注意：所以现在语法推导和lex解析算法大多都是O(N),只扫描一遍输入流不回退</strong> # lex ## hello world 这个框架实际上会根据给定的配置,来解析字符串 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">stop       printf(“Stop command received\n”);</span><br><span class="line">start      printf(“Start command received\n”);</span><br><span class="line">%%</span><br></pre></td></tr></table></figure> 第一部分，位于%{和%}对之间直接包含了输出程序(stdio.h).我们需要这个程序，因为使用了printf函数，它在stdio.h中定义.</p>
<p>第二部分用’%%’分割开来，所以第二行起始于’stop’，一旦在输入参数中遇到了’stop’，接下来的那一行(printf()调用)将被执行. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配的字符串名称 执行动作</span><br></pre></td></tr></table></figure> 我们这里是固定字符串stop,start</p>
<p>除此之外，还有’start’，其跟stop的行为差不多. 执行以下命令： 编译时，我们增加『-ll』编译选项，因为libl会提供main函数.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex helloworld.lex</span><br><span class="line">gcc lex.yy.c –o example –ll</span><br></pre></td></tr></table></figure>
<p><img src="/img/hello-lex.png" alt="输出" /> ## 正则表达式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[0123456789]+     printf(“NUMBER\n”);</span><br><span class="line">[a-zA-Z][a-zA-Z0-9]*  printf(“word\n”);</span><br></pre></td></tr></table></figure> 执行以下命令： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex regex.lex</span><br><span class="line">gcc lex.yy.c –o example –ll</span><br></pre></td></tr></table></figure> <img src="/img/regex.png" alt="输出" /> ## lex中的函数和变量 - ytext char * 当前匹配的字符串 - yleng int 当前匹配的字符串长度 - yin FILE * lex当前的解析文件，默认为标准输出 - yout FILE * lex解析后的输出文件，默认为标准输入 - ylineno int 当前的行数信息 - 宏<br />
CHO #define ECHO fwrite(yytext, yyleng, 1, yyout) 也是未匹配字符的默认动作 - int yylex(void) 调用Lex进行词法分析 - int yywrap(void) 在文件(或输入)的末尾调用。如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。代码可以写在第三段，这样可以解析多个文件。 方法是使用 yyin 文件指针指向不同的文件，直到所有的文件都被解析。最后，yywrap() 可以返回1来表示解析的结束。</p>
<h1 id="yacc">yacc</h1>
<p>YACC可以解析输入流中的标识符(token)，这就描述了YACC和LEX的关系，YACC并不知道『输入流』为何物，它需要事先就将输入流预加工成标识符，我们也可以自己手工写一个Tokenizer. ## yacc中的函数 - yyerror()在YACC发现一个错误的时候被调用，我们只是简单的输出错误信息. - yywrap()函数用于不断的从一个文件中读取数据，当遇到EOF时，你可以再输入一个文件，然后返回0，你也可以使得其返回1，暗示着输入结束 - 这里有一个main()函数，它基本什么也不做，只是调用一些函数.可以单独定义也可以就放在grammer.y中 - yyparse() 会解析输入流中的token,并结合产生式推导 ## 产生式 编译原理中的表达语法的上下文无关文法,确定了字符串的生成变换规则.这里需要将固定的语法拆分成字符串变换规则来理解,如果一个字符串没办法从终结符号结合变换规则得到，则该字符串不符合语法,需要抛出sytnax error.常见的语法分析算法有递归下降,LALR等 # 实例(实现一个固定语法的温度控制器) 我们希望实现下面的功能,如果用户输入heat on 就打开温度控制器,输入heat off就关闭温度控制器,用户还可以通过target temperature set xxx来设定温度值 ## lexer <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">[0-9]+         &#123; yylval = atoi(yytext); return NUMBER;&#125;</span><br><span class="line">heat           return TOKHEAT;</span><br><span class="line">on|off         return STATE;</span><br><span class="line">target         return TOKTARGET;</span><br><span class="line">temperature    return TOKTEMPERATURE;</span><br><span class="line">\n             /* ignore end of line */;</span><br><span class="line">[ \t]+         /* ignore whitespace */</span><br><span class="line">%%</span><br></pre></td></tr></table></figure> lex根据正则来确定TOKEN,这个也是在yacc产生式中的终结符 ## grammer <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void yywrap()</span><br><span class="line">&#123;</span><br><span class="line">    return  1;</span><br><span class="line">&#125;</span><br><span class="line">void yyerror(char * errmsg)&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,errmsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line">//这里需要和lex中返回的token一致</span><br><span class="line">%token  NUMBER TOKHEAT STATE TOKTARGET TOKTEMPERATURE</span><br><span class="line">%%</span><br><span class="line">commands: /* empty */</span><br><span class="line">    | commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command: heat_switch</span><br><span class="line">    | target_set</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">heat_switch:</span><br><span class="line">    TOKHEAT STATE</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\tHeat turned on or off\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">target_set:</span><br><span class="line">    TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">    &#123;</span><br><span class="line">        //展示区别,这里给输入参数+5</span><br><span class="line">        printf(&quot;\tTemperature set %d\n&quot;,$3 + 5);</span><br><span class="line">    &#125;</span><br><span class="line">;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure></p>
<h2 id="输出">输出</h2>
<p>对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑 执行下列命令 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex heat.lex</span><br><span class="line">bison -d heat-grammer.y  --file-prefix y</span><br><span class="line">gcc y.tab.c lex.yy.c</span><br></pre></td></tr></table></figure> <img src="/img/heat-output.png" alt="温度控制" /></p>
<h2 id="yacc中的union类型这种是实际工程中才使用的">yacc中的union类型(这种是实际工程中才使用的)</h2>
<h3 id="温度控制器的新语法">温度控制器的新语法</h3>
<p>用下面方式控制，先选择heater，再设置温度 heater mainbuilding</p>
<pre><code>Selected ‘mainbuilding’ heater</code></pre>
<p>Target temperature 23</p>
<pre><code>‘mainbuilding’ heater target temperature now 23</code></pre>
<h3 id="yacc中的变量">yacc中的变量</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">extern int yydebug = 1;</span><br><span class="line">char * heater=NULL;</span><br><span class="line">void yywrap()</span><br><span class="line">&#123;</span><br><span class="line">    return  1;</span><br><span class="line">&#125;</span><br><span class="line">void yyerror(char * errmsg)&#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,errmsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token  TOKHEAT TOKTARGET TOKTEMPERATURE  TOKHEATER </span><br><span class="line">%union</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int number;</span><br><span class="line"></span><br><span class="line">    char *string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;number&gt; STATE</span><br><span class="line"></span><br><span class="line">%token &lt;number&gt; NUMBER</span><br><span class="line"></span><br><span class="line">%token &lt;string&gt; WORD</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">commands: /* empty */</span><br><span class="line">    | commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command: heat_switch</span><br><span class="line">    | target_set | heater_select</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">heat_switch:</span><br><span class="line">    TOKHEAT STATE</span><br><span class="line">    &#123;</span><br><span class="line">         if ($2)</span><br><span class="line">            printf(&quot;\tHeat turned on\n&quot;);</span><br><span class="line">         else</span><br><span class="line">            printf(&quot;\tHeat turned off\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">target_set:</span><br><span class="line">    TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">    &#123;</span><br><span class="line">        //展示区别,这里给输入参数+5</span><br><span class="line">        printf(&quot;\tHeater &#x27;%s&#x27; temperature set to %d\n&quot;, heater, $3+5);</span><br><span class="line">    &#125;</span><br><span class="line">;</span><br><span class="line">heater_select :</span><br><span class="line"></span><br><span class="line">    TOKHEATER WORD</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">       printf(&quot;\tSelected heater ‘%s’\n&quot;, $2);</span><br><span class="line"></span><br><span class="line">       heater = $2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>这次我们在command产生式增加了heater_select,并且定义了一个全局变量来接收选择的温度控制器.token处，我们定义了一个union变量,用于处理输入中不同的数据类型.此处表示yylval是一个union类型,可用来处理不同的数据类型</p>
<h3 id="语法">语法</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;y.tab.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">[0-9]+         &#123; yylval.number = atoi(yytext); return NUMBER;&#125;</span><br><span class="line">heater         return TOKHEATER;</span><br><span class="line">heat           return TOKHEAT;</span><br><span class="line">on|off         &#123; yylval.number = !strcmp(yytext,  &quot;on&quot;); return STATE; &#125;</span><br><span class="line">target         return TOKTARGET;</span><br><span class="line">temperature    return TOKTEMPERATURE;</span><br><span class="line">[a-z0-9]+     yylval.string = strdup(yytext); return WORD;</span><br><span class="line">\n             /* ignore end of line */;</span><br><span class="line">[ \t]+         /* ignore whitespace */</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>细心的同学可能已经发现了,这次对于yylval的赋值已经是具体到成员了</p>
<h3 id="输出-1">输出</h3>
<p>对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑 <img src="/img/yacc-with-union.png" alt="输出" /></p>
<h1 id="yacc-debug">yacc debug</h1>
<p>当调试你的语法时，在YACC命令行中添加—debug和—verbose选项，在你的C文件头中添加以下语句： int yydebug = 1;这将生成一个y.output文件，其中说明了所创建的那个状态机. 可以开启debug语法信息,详细查看yacc状态机和根据产生式推导的过程.这里我mark一下,以便后续自己查阅. <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t(--debug) -v</span><br><span class="line">bison -t -v -d heat-grammer.y -b y </span><br></pre></td></tr></table></figure> # 测试代码见 <a href="https://github.com/dingweiqings/study/tree/master/compiler_study/src/yacc">我的github代码</a></p>
<h1 id="推广">推广</h1>
<p>我们发现lex和yacc可以用来处理有固定语法的字符串,那么我们可以用其来解析配置文件,解析sql,解析json等等.好啦,现在你可以去看mysql和pg的sql解析啦,为学到新知识开心. <a href="https://github.com/mysql/mysql-server/blob/8.0/sql/sql_yacc.yy">mysql yacc</a> <a href="https://github.com/postgres/postgres/blob/master/src/backend/parser/gram.y">Postgres yacc</a></p>
<h1 id="更深入的学习">更深入的学习</h1>
<p><a href="https://pku-minic.github.io/online-doc/#/lv9p-reincarnation/ssa-form">北大编译实践</a> <a href="https://blog.ginshio.org/2022/flex_and_bison/#gnu-bison">lex和yacc内核</a></p>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a href="https://cnblogs.com/itech/archive/2012/03/04/2375746.html">flex和bison</a></li>
<li><a href="https://blog.csdn.net/u014015972/article/details/51480680">flex和bison实现计算器</a></li>
<li><a href="http://home.ustc.edu.cn/~guoxing/ebooks/flex%E4%B8%8Ebison%E4%B8%AD%E6%96%87%E7%89%88.pdf">flex和bison中文版电子书</a></li>
</ol>
]]></content>
      <categories>
        <category>编译器</category>
      </categories>
      <tags>
        <tag>yacc</tag>
      </tags>
  </entry>
</search>

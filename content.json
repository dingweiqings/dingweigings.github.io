{"meta":{"title":"猫猫攻城狮的博客","subtitle":"","description":"","author":"KurtDing","url":"https://dingweiqings.github.io","root":"/"},"pages":[{"title":"关于我","date":"2023-06-14T06:24:25.000Z","updated":"2023-10-05T09:51:04.875Z","comments":true,"path":"about/index.html","permalink":"https://dingweiqings.github.io/about/index.html","excerpt":"","text":"人生格言 路漫漫其修远兮,吾将上下而求索. 书山有路勤为径，学海无涯苦作舟. 认识自己的无知就是最大的智慧. 渐功顿悟，绳锯木断，水滴石穿，愚公移山. 物质上的贫穷不可怕,怕的是知识上的贫穷. 当继承革命先烈遗志,守住这一片华夏大地. 人生导师 毛主席,岳飞,苏格拉底,伽利略,牛顿,华罗庚 人生目标 读万卷书，行万里路 学习新知识,发现新知识，为国家和社会做出自己的贡献 关于我我是程序员一枚，对底层和数据科学很感兴趣，数学基础扎实,目前已学习linux,数据库,并行计算,计算机系统相关基础理论.常用编程语言是java&#x2F;C++&#x2F;python. 开源贡献目前有几个小的PR,不属于大的feature,希望能不断积累PR,成为贡献者 mariadb https://github.com/MariaDB/server/pull/2293 https://github.com/MariaDB/server/pull/2393 https://github.com/MariaDB/server/pull/2297 grafana https://github.com/grafana/grafana/pull/51529 flink https://github.com/apache/flink/pull/20755 flink-connector-elasticsearch https://github.com/apache/flink-connector-elasticsearch/pull/48"},{"title":"全部分类","date":"2020-05-08T10:52:51.000Z","updated":"2023-09-15T04:10:34.766Z","comments":true,"path":"categories/index.html","permalink":"https://dingweiqings.github.io/categories/index.html","excerpt":"","text":""},{"title":"全部标签","date":"2020-05-08T10:52:51.000Z","updated":"2023-09-15T04:10:44.254Z","comments":true,"path":"tags/index.html","permalink":"https://dingweiqings.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"x86体系结构","slug":"体系结构/x86体系结构","date":"2023-10-06T01:20:56.000Z","updated":"2023-10-06T08:54:23.429Z","comments":true,"path":"/2023/10/06/体系结构/x86体系结构/","link":"","permalink":"https://dingweiqings.github.io/2023/10/06/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/x86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"x86实模式x86实模式的内存模型是物理地址&#x3D;段地址*16+偏移地址 x86保护模式这是另外一种分段的内存模型.由于实模式下有20根地址线,在x86-32架构下有32位地址线，那么如何去使用和管理这4g的内存？并且现在机器都是多任务的，需要任务之间隔离内存访问。于是，x86-32的保护模式，采用了表格登记分配的方式。段先在全局的一张表格中登记.表格实际上是一个数组，每个元素8字节，里面保存的段的基地址和段的界限，基地址+界限就可以确定一个段 然后在访问内存时，段寄存器不再表示基地址，而表示在表格中的序号,通过序号查找到在内存中的区块.这样表示有很多好处，可以对段加权限标记,x86-32是有2位来表示段权限，总共有4个权限.cpu在访问时，**用sp的权限(当前代码段的权限)**表示当前cpu的权限,如果比要访问的段权限高，就可以访问，否则拒绝访问;也可以对16位程序保持兼容;也可以对任务实现内存隔离 一般把这个表格叫做GDT，cpu会有一个寄存器记录GDT的首地址 x64长模式有2种子模式，纯的64位模式和兼容模式(kernel工作在64位，在返回应用时工作在32位) 引用 x86保护模式","categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://dingweiqings.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"x86","slug":"x86","permalink":"https://dingweiqings.github.io/tags/x86/"}]},{"title":"可重入锁","slug":"java/锁框架","date":"2023-10-05T09:36:10.000Z","updated":"2023-10-06T09:41:31.586Z","comments":true,"path":"/2023/10/05/java/锁框架/","link":"","permalink":"https://dingweiqings.github.io/2023/10/05/java/%E9%94%81%E6%A1%86%E6%9E%B6/","excerpt":"","text":"锁框架基于抽象基类的设计模式，抽象基类是AbstractQ jdk","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"jdk 锁框架","slug":"jdk-锁框架","permalink":"https://dingweiqings.github.io/tags/jdk-%E9%94%81%E6%A1%86%E6%9E%B6/"}]},{"title":"即时编译","slug":"jvm/即时编译","date":"2023-10-04T07:46:20.000Z","updated":"2023-10-04T07:46:20.413Z","comments":true,"path":"/2023/10/04/jvm/即时编译/","link":"","permalink":"https://dingweiqings.github.io/2023/10/04/jvm/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"gc","slug":"jvm/gc","date":"2023-10-04T07:45:13.000Z","updated":"2023-10-04T07:45:13.909Z","comments":true,"path":"/2023/10/04/jvm/gc/","link":"","permalink":"https://dingweiqings.github.io/2023/10/04/jvm/gc/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"循环码","slug":"编码/循环码","date":"2023-09-26T03:56:46.000Z","updated":"2023-09-27T01:21:56.684Z","comments":true,"path":"/2023/09/26/编码/循环码/","link":"","permalink":"https://dingweiqings.github.io/2023/09/26/%E7%BC%96%E7%A0%81/%E5%BE%AA%E7%8E%AF%E7%A0%81/","excerpt":"","text":"通信主流的理解是将通信看成信息编码+信息传输+信息解码,这里不涉及到应用层的具体协议解读.只是将源产生的信息在经过不可靠信道传输之后,目的端能够接收并正确还原到多少. 编码定理TODO 循环码这块内容涉及到相当多的理论证明,等我后面慢慢研究再补充","categories":[{"name":"信号与编码","slug":"信号与编码","permalink":"https://dingweiqings.github.io/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"CRC","slug":"CRC","permalink":"https://dingweiqings.github.io/tags/CRC/"}]},{"title":"yacc使用","slug":"编译器/yacc","date":"2023-09-25T03:10:26.000Z","updated":"2023-09-26T00:48:46.700Z","comments":true,"path":"/2023/09/25/编译器/yacc/","link":"","permalink":"https://dingweiqings.github.io/2023/09/25/%E7%BC%96%E8%AF%91%E5%99%A8/yacc/","excerpt":"","text":"简单介绍下编译原理词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。AST啥的也理解不透彻. 词法分析和语法分析框架lex和yacc是unix下的词法&#x2F;语法分析框架,flex&#x2F;bison是词法&#x2F;语法分析框架bison和yacc实际上用途是同一种，不过在不同平台下,yacc已经成为语法分析框架的代名词。下文统一使用lex&#x2F;yacc Lex和YACC内部是如何工作的？main -&gt;yyparse() -&gt; yylex()yylex 会读取在yyin这个变量中的文件(没有则默认是stdin), yylex不断解析输入流,yyparse不断推导产生式并执行相应动作(在语法文件中定义),直到结束.注意：所以现在语法推导和lex解析算法大多都是O(N),只扫描一遍输入流不回退 lexhello world这个框架实际上会根据给定的配置,来解析字符串 1234567%&#123;#include &lt;stdio.h&gt;%&#125;%%stop printf(“Stop command received\\n”);start printf(“Start command received\\n”);%% 第一部分，位于%{和%}对之间直接包含了输出程序(stdio.h).我们需要这个程序，因为使用了printf函数，它在stdio.h中定义. 第二部分用’%%’分割开来，所以第二行起始于’stop’，一旦在输入参数中遇到了’stop’，接下来的那一行(printf()调用)将被执行. 1匹配的字符串名称 执行动作 我们这里是固定字符串stop,start 除此之外，还有’start’，其跟stop的行为差不多.执行以下命令：编译时，我们增加『-ll』编译选项，因为libl会提供main函数. 12flex helloworld.lexgcc lex.yy.c –o example –ll 正则表达式1234567%&#123;#include &lt;stdio.h&gt;%&#125;%%[0123456789]+ printf(“NUMBER\\n”);[a-zA-Z][a-zA-Z0-9]* printf(“word\\n”); 执行以下命令： 12flex regex.lexgcc lex.yy.c –o example –ll lex中的函数和变量 ytext char * 当前匹配的字符串 yleng int 当前匹配的字符串长度 yin FILE * lex当前的解析文件，默认为标准输出 yout FILE * lex解析后的输出文件，默认为标准输入 ylineno int 当前的行数信息 宏 CHO #define ECHO fwrite(yytext, yyleng, 1, yyout) 也是未匹配字符的默认动作 int yylex(void) 调用Lex进行词法分析 int yywrap(void) 在文件(或输入)的末尾调用。如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。代码可以写在第三段，这样可以解析多个文件。 方法是使用 yyin 文件指针指向不同的文件，直到所有的文件都被解析。最后，yywrap() 可以返回1来表示解析的结束。 yaccYACC可以解析输入流中的标识符(token)，这就描述了YACC和LEX的关系，YACC并不知道『输入流』为何物，它需要事先就将输入流预加工成标识符，我们也可以自己手工写一个Tokenizer. yacc中的函数 yyerror()在YACC发现一个错误的时候被调用，我们只是简单的输出错误信息. yywrap()函数用于不断的从一个文件中读取数据，当遇到EOF时，你可以再输入一个文件，然后返回0，你也可以使得其返回1，暗示着输入结束 这里有一个main()函数，它基本什么也不做，只是调用一些函数.可以单独定义也可以就放在grammer.y中 yyparse() 会解析输入流中的token,并结合产生式推导 产生式编译原理中的表达语法的上下文无关文法,确定了字符串的生成变换规则.这里需要将固定的语法拆分成字符串变换规则来理解,如果一个字符串没办法从终结符号结合变换规则得到，则该字符串不符合语法,需要抛出sytnax error.常见的语法分析算法有递归下降,LALR等 实例(实现一个固定语法的温度控制器)我们希望实现下面的功能,如果用户输入heat on 就打开温度控制器,输入heat off就关闭温度控制器,用户还可以通过target temperature set xxx来设定温度值 lexer12345678910111213%&#123;#include &lt;stdio.h&gt;#include &quot;y.tab.h&quot;%&#125;%%[0-9]+ &#123; yylval = atoi(yytext); return NUMBER;&#125;heat return TOKHEAT;on|off return STATE;target return TOKTARGET;temperature return TOKTEMPERATURE;\\n /* ignore end of line */;[ \\t]+ /* ignore whitespace */%% lex根据正则来确定TOKEN,这个也是在yacc产生式中的终结符 grammer123456789101112131415161718192021222324252627282930313233343536373839404142%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void yywrap()&#123; return 1;&#125;void yyerror(char * errmsg)&#123; printf(&quot;%s\\n&quot;,errmsg);&#125;int main()&#123; yyparse();&#125;%&#125;//这里需要和lex中返回的token一致%token NUMBER TOKHEAT STATE TOKTARGET TOKTEMPERATURE%%commands: /* empty */ | commands command;command: heat_switch | target_set;heat_switch: TOKHEAT STATE &#123; printf(&quot;\\tHeat turned on or off\\n&quot;); &#125;;target_set: TOKTARGET TOKTEMPERATURE NUMBER &#123; //展示区别,这里给输入参数+5 printf(&quot;\\tTemperature set %d\\n&quot;,$3 + 5); &#125;;%% 输出对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑执行下列命令 123flex heat.lexbison -d heat-grammer.y --file-prefix ygcc y.tab.c lex.yy.c yacc中的union类型(这种是实际工程中才使用的)温度控制器的新语法用下面方式控制，先选择heater，再设置温度heater mainbuilding Selected ‘mainbuilding’ heater Target temperature 23 ‘mainbuilding’ heater target temperature now 23 yacc中的变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yydebug = 1;char * heater=NULL;void yywrap()&#123; return 1;&#125;void yyerror(char * errmsg)&#123; printf(&quot;%s\\n&quot;,errmsg);&#125;int main()&#123; yyparse();&#125;%&#125;%token TOKHEAT TOKTARGET TOKTEMPERATURE TOKHEATER %union&#123; int number; char *string;&#125;%token &lt;number&gt; STATE%token &lt;number&gt; NUMBER%token &lt;string&gt; WORD%%commands: /* empty */ | commands command;command: heat_switch | target_set | heater_select;heat_switch: TOKHEAT STATE &#123; if ($2) printf(&quot;\\tHeat turned on\\n&quot;); else printf(&quot;\\tHeat turned off\\n&quot;); &#125;;target_set: TOKTARGET TOKTEMPERATURE NUMBER &#123; //展示区别,这里给输入参数+5 printf(&quot;\\tHeater &#x27;%s&#x27; temperature set to %d\\n&quot;, heater, $3+5); &#125;;heater_select : TOKHEATER WORD &#123; printf(&quot;\\tSelected heater ‘%s’\\n&quot;, $2); heater = $2;&#125; ;%% 这次我们在command产生式增加了heater_select,并且定义了一个全局变量来接收选择的温度控制器.token处，我们定义了一个union变量,用于处理输入中不同的数据类型.此处表示yylval是一个union类型,可用来处理不同的数据类型 语法123456789101112131415%&#123;#include &lt;stdio.h&gt;#include &quot;y.tab.h&quot;%&#125;%%[0-9]+ &#123; yylval.number = atoi(yytext); return NUMBER;&#125;heater return TOKHEATER;heat return TOKHEAT;on|off &#123; yylval.number = !strcmp(yytext, &quot;on&quot;); return STATE; &#125;target return TOKTARGET;temperature return TOKTEMPERATURE;[a-z0-9]+ yylval.string = strdup(yytext); return WORD;\\n /* ignore end of line */;[ \\t]+ /* ignore whitespace */%% 细心的同学可能已经发现了,这次对于yylval的赋值已经是具体到成员了 输出对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑 yacc debug当调试你的语法时，在YACC命令行中添加—debug和—verbose选项，在你的C文件头中添加以下语句：int yydebug &#x3D; 1;这将生成一个y.output文件，其中说明了所创建的那个状态机.可以开启debug语法信息,详细查看yacc状态机和根据产生式推导的过程.这里我mark一下,以便后续自己查阅. 12-t(--debug) -vbison -t -v -d heat-grammer.y -b y 测试代码见我的github代码 推广我们发现lex和yacc可以用来处理有固定语法的字符串,那么我们可以用其来解析配置文件,解析sql,解析json等等.好啦,现在你可以去看mysql和pg的sql解析啦,为学到新知识开心.mysql yaccPostgres yacc 更深入的学习北大编译实践lex和yacc内核 引用 flex和bison flex和bison实现计算器 flex和bison中文版电子书","categories":[{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"}]},{"title":"gcc的虚函数表","slug":"C++/gcc的虚函数表","date":"2023-09-25T00:17:55.000Z","updated":"2023-10-05T08:11:29.437Z","comments":true,"path":"/2023/09/25/C++/gcc的虚函数表/","link":"","permalink":"https://dingweiqings.github.io/2023/09/25/C++/gcc%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/","excerpt":"","text":"虚函数表 所谓虚函数表，是编译器自动为一个带有虚函数的类生成的一块内存空间，其中存储着每一个虚函数的入口地址。由于函数的入口地址可以看成一个指针类型，因此这些虚函数的地址间隔为四个字节。而每一个带有虚函数类的实例，都拥有一个虚函数指针——vptr，在类的对象初始化完毕后，它将指向虚函数表。 相关概念 vbase offsetvbase offset全称为(Virtual Base offsets), 也即虚基类偏移。当一个class存在虚基类时，gcc编译器便会在primary virtual table中安插相应的vbase offset。 其主要作用为：用于访问对象的虚基类子对象。这样的条目被添加到派生类对象vtable，以获取虚拟基类子对象的地址。每个虚基类都需要这样一个条目。这些值可以是正的，也可以是负的。 top offsettop offset ，也即到class顶部的偏移，指的该class的vptr到对象顶部的位移，其类型为 ptrdiff_t。 它总是存。 偏移量提供了一种使用vptr从任何基类对象中查找对象顶部的方式。 这对于 dynamic_cast&lt;void*&gt; 尤其必要。 typeinfo指针typeinfo 指针指向用于 RTTI 的 typeinfo 对象。 它总是存在的。 给定类的每个vtable中的所有typeinfo 指针都必须指向相同的 typeinfo 对象。 typeinfo 相等性的正确实现是检查指针相等性，但指向不完整类型的指针（直接或间接）除外。 typeinfo 指针在多态类的场景下是有效指针，对于非多态类为零。 virtual function 指针函数指针用于虚函数调度。 每个指针要么保存类的虚函数的地址，要么保存在将控制权转移到虚函数之前执行某些调整的辅助入口点的地址。先有个初步的了解 123456789class A&#123;public: int a; virtual ~A(void) &#123;&#125;&#125;;class B : virtual public A&#123;&#125;; 对于上面的代码,执行g++ -fdump-lang-class code.cc，并执行c++命名反修饰cat code.001.class | c++filt会得到下面的输出,其中的VTT下面会解释 1234567891011121314151617181920212223242526272829Class A size=16 align=8 base size=12 base align=8A (0x0x7fb9e6855d80) 0 vptr=((&amp; A::vtable for A) 16)Vtable for BB::vtable for B: 8 entries0 168 (int (*)(...))016 (int (*)(...))(&amp; typeinfo for B)24 (int (*)(...))B::bf32 040 (int (*)(...))-1648 (int (*)(...))(&amp; typeinfo for B)56 (int (*)(...))A::afVTT for BB::VTT for B: 2 entries0 ((&amp; B::vtable for B) 24)8 ((&amp; B::vtable for B) 56)Class B size=32 align=8 base size=12 base align=8B (0x0x7fb9e66fe1a0) 0 vptridx=0 vptr=((&amp; B::vtable for B) 24) A (0x0x7fb9e6855e40) 16 virtual vptridx=8 vbaseoffset=-24 vptr=((&amp; B::vtable for B) 56) gcc查看虚函数表做些设置 123set print asm-demangle onset print demangle on set print pretty on 查看对象结构：p 对象名 12345678(gdb) p p1$1 = &#123;_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;&#125;(gdb) p p2$2 = &#123;_vptr$Parent = 0x400bb8 &lt;vtable for Parent+16&gt;&#125;(gdb) p d1$3 = &#123;&lt;Parent&gt; = &#123;_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;&#125;, &lt;No data fields&gt;&#125;(gdb) p d2$4 = &#123;&lt;Parent&gt; = &#123;_vptr$Parent = 0x400b50 &lt;vtable for Derived+16&gt;&#125;, &lt;No data fields&gt;&#125; dump内存: x&#x2F;字节数 起始位置x&#x2F;300xb 0x400b40 12345678910111213141516171819(gdb) x/300xb 0x400b400x400b40 &lt;vtable for Derived&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x400b48 &lt;vtable for Derived+8&gt;: 0x90 0x0b 0x40 0x00 0x00 0x00 0x00 0x000x400b50 &lt;vtable for Derived+16&gt;: 0x80 0x0a 0x40 0x00 0x00 0x00 0x00 0x000x400b58 &lt;vtable for Derived+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x000x400b60 &lt;typeinfo name for Derived&gt;: 0x37 0x44 0x65 0x72 0x69 0x76 0x65 0x640x400b68 &lt;typeinfo name for Derived+8&gt;: 0x00 0x36 0x50 0x61 0x72 0x65 0x6e 0x740x400b70 &lt;typeinfo name for Parent+7&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x400b78 &lt;typeinfo for Parent&gt;: 0x90 0x20 0x60 0x00 0x00 0x00 0x00 0x000x400b80 &lt;typeinfo for Parent+8&gt;: 0x69 0x0b 0x40 0x00 0x00 0x00 0x00 0x000x400b88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x400b90 &lt;typeinfo for Derived&gt;: 0x10 0x22 0x60 0x00 0x00 0x00 0x00 0x000x400b98 &lt;typeinfo for Derived+8&gt;: 0x60 0x0b 0x40 0x00 0x00 0x00 0x00 0x000x400ba0 &lt;typeinfo for Derived+16&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x000x400ba8 &lt;vtable for Parent&gt;: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x400bb0 &lt;vtable for Parent+8&gt;: 0x78 0x0b 0x40 0x00 0x00 0x00 0x00 0x000x400bb8 &lt;vtable for Parent+16&gt;: 0xa0 0x0a 0x40 0x00 0x00 0x00 0x00 0x000x400bc0 &lt;vtable for Parent+24&gt;: 0x90 0x0a 0x40 0x00 0x00 0x00 0x00 0x00... 单继承的虚函数表123456789101112131415161718192021#include &lt;iostream&gt;class Parent &#123; public: virtual void Foo() &#123;&#125; virtual void FooNotOverridden() &#123;&#125; int a;&#125;;class Derived : public Parent &#123; public: void Foo() override &#123;&#125; int b;&#125;;int main() &#123; Parent p1, p2; Derived d1, d2; std::cout &lt;&lt; &quot;done&quot; &lt;&lt; std::endl;&#125; 子类的内存布局 子类布局 _vptr$Parent int a (Parent data) int b (Child data) 虚函数表,Drived只有一个函数表，但Parent和Derived都指向Derived的虚函数表,Derived复用了父类的vptr。下面是vtable布局 多继承的虚函数表1234567891011121314151617class Mother &#123; public: virtual void MotherFoo() &#123;&#125; int mother_data;&#125;;class Father &#123; public: virtual void FatherFoo() &#123;&#125; int father_data;&#125;;class Child : public Mother, public Father &#123; public: void FatherFoo() override &#123;&#125; int child_data;&#125;; 按照上面gdb的查看步骤，可以得到:这里是把Monther当做主基类,Child复用Monther的vptr.观察可以发现，父类的vptr指针对于被覆盖的函数，实际上指向的子类的地址。当做下面转换时， 12Father f = Child();f.fatherFoo(); 实际上调用的一段汇编的桩代码，类似于gdb执行info vtbl c查看vtable有:实际的内存地址可能和上面表格有出入，但顺序是一致的得到函数地址再反汇编,有第一行sub $0x10 %rdi就是在调整this指针，rdi寄存器一般用来保存成员函数的第一个参数，也就是this指针.偏移量有前面的top_offset得到注意 为什么需要调整this指针呢？因为Father实际上基类，但调用的实例是Child，成员函数的this指针必须指向当前实际类型的内存空间,因为在被覆盖的成员函数可能会访问子类成员数据，this指针如果不设置正确，则可能访问错误。所有的多态调用都必须调整this指针,主基类由于和子类共用vptr不需要调整。在我们这个例子中Mother是主基类，调佣Mother的虚函数，不需要调整this指针 虚拟继承的虚函数表123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Grandparent &#123; public: virtual void grandparent_foo() &#123;&#125; int grandparent_data;&#125;;class Parent1 : virtual public Grandparent &#123; public: virtual void parent1_foo() &#123;&#125; int parent1_data;&#125;;class Parent2 : virtual public Grandparent &#123; public: virtual void parent2_foo() &#123;&#125; int parent2_data;&#125;;class Child : public Parent1, public Parent2 &#123; public: virtual void child_foo() &#123;&#125; int child_data;&#125;;int main() &#123; Child child;&#125; 还是按照上面步骤来看,打印Child的内存布局可以发现，实际上虚继承的每个父类都只有一份内存拷贝，相当于直接继承GrandParent。下面是vtable实际的内存地址可能和上面表格有出入，但顺序是一致的这里多出来了construct table和vtt。这篇反汇编gcc编译bin的论文有提到这些是干什么的.下面我也会解释这两个的作用。注意 construct table和vtt在内存中实际存在的,要占用内存空间construct table是在实例化Child需要用到的,比如在实例化Child时，会最先实例化GrandParent(相当于Child直接继承),然后再实例化Parent1,Parent2.但GrandParent已经有了，如何告诉Parent1呢？这里就用到了virtual base offset和construct table，告诉Parent1，GrandParent已经在this-32的位置(这里this是指向Child的内存首地址,因为是构造Child).这样就可以把类拼起来了。top_offset还是子类到Child数据成员首地址的偏移量。还有一个东西就是Vtable table，用来记录多个vtable的位置，充当一个索引的作用 虚函数表如何解决面向对象中的问题实现多态 基类的vptr指向子类的虚函数 在调用时，根据子类记录的基类偏移量来调整this指针 遗留的问题我搞不懂既然vptr是指向function pointer，那编译器怎么直到vptr前面有几个才是vtable的首地址呢，第几项是vbase offset呢？如果有多个虚继承的类，又当怎么vbase offset呢？ 继承结构可视化在有一篇反汇编gcc编译出的bin论文中有提到说可以可视化vtable,但我是没跑通，最后需要下载ida pro这个反编译工具,没跑通https://github.com/bingseclab/VirtAnalyzer/blob/master/README.md 引用 深入探索C++对象-候捷 反汇编gcc编译bin的论文 LLVM虚函数表 vtable单继承详解 vtable多重继承详解 vtable虚继承详解","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++ 虚函数 编译器","slug":"C-虚函数-编译器","permalink":"https://dingweiqings.github.io/tags/C-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"std库","slug":"C++/std","date":"2023-09-20T01:29:15.000Z","updated":"2023-09-20T01:57:00.610Z","comments":true,"path":"/2023/09/20/C++/std/","link":"","permalink":"https://dingweiqings.github.io/2023/09/20/C++/std/","excerpt":"","text":"正文见我的有道云笔记https://note.youdao.com/s/TzGJhYmG","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"std库 模板","slug":"std库-模板","permalink":"https://dingweiqings.github.io/tags/std%E5%BA%93-%E6%A8%A1%E6%9D%BF/"}]},{"title":"spark","slug":"大数据/spark","date":"2023-09-19T08:48:23.000Z","updated":"2023-09-19T08:48:23.577Z","comments":true,"path":"/2023/09/19/大数据/spark/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"elasticsearch查询","slug":"大数据/elasticsearch","date":"2023-09-19T08:48:01.000Z","updated":"2023-09-19T08:48:01.644Z","comments":true,"path":"/2023/09/19/大数据/elasticsearch/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/elasticsearch/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"系统编程","slug":"linux/linux系统编程","date":"2023-09-19T08:47:19.000Z","updated":"2023-10-04T07:16:58.186Z","comments":true,"path":"/2023/09/19/linux/linux系统编程/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/linux/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/tags/linux/"}]},{"title":"文件系统源码","slug":"linux/linux文件系统源码","date":"2023-09-19T08:46:52.000Z","updated":"2023-10-04T07:17:11.175Z","comments":true,"path":"/2023/09/19/linux/linux文件系统源码/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/","excerpt":"","text":"","categories":[{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/tags/linux/"}]},{"title":"x86-16汇编","slug":"汇编语言/x86-16汇编","date":"2023-09-19T08:46:32.000Z","updated":"2023-10-06T08:04:19.587Z","comments":true,"path":"/2023/09/19/汇编语言/x86-16汇编/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86-16%E6%B1%87%E7%BC%96/","excerpt":"","text":"计算模型计算模型是一种表达计算方式的模型，是我们日常见到的物理计算机的计算方式的抽象。有穷自动机和图灵机是计算模型。 有穷自动机可以从我们常见的状态机来理解，比如tcp网络状态机，缓存一致性状态机，编译原理中的DFA,业务中的订单流转状态机都属于状态机。自动机是一种模型机，它根据系统当前状态和一个给定的输入来确定系统下一步将进入哪个状态或者下一步执行哪个动作。但它只会从一个状态进入另一个状态，并不会有其他额外的数据存储。于是，我们根据自动机的特点，构建出一种模型,这种模型可以用来识别和判断字符串是否符合正则表达式，状态转换是否合法等等.用一个寄存器来存储当前状态，预先给这个模型设定好状态转化图。让模型一开始处于Start状态,然后不断读取输入字符串&#x2F;状态转换路线，因为是有限的状态机，最终会终止.如果终止状态可以被Accept，则是合法.注意 有穷自动机的计算能力是很有限的，只能根据给定的状态机来判断输入是否合法 图灵机仔细思考我们可以发现，上面的计算模型： 只能保存一个状态，而且不可保存数据，只能读取外部输入.于是我们可以增加另外一块存储区域,用来支持写数据。 在读取输入字符串只能不断向前移动，不能向后移动.于是，设计这样一种模型.这时输入字符串(不再是固定的状态转换路线)就可以是下面几种操作: 读存储区的数据 向存储区写数据 数据运算 读指针向后跳转这就是经常说的图灵机纸带，读写头可以向前移动(不断读取新指令),向后移动(重新执行先前执行过的指令),移动到空白纸带(读写存储区)注意 图灵机已经拥有很强大的计算能力 通用图灵机仔细思考我们可以发现，图灵机的模型，给定一个问题的算法后，便可以解决这一类问题。但是对于输入字符串该如何编写，如何用指令来描述解决问题的算法？所以需要对图灵机支持的指令进行规定。于是，我们又有一个新的模型，把指令集也作为一种输入给图灵机，这样图灵机就可以根据指令集和预先给定的算法来自动的处理和解决问题。这种将算法和指令集作为输入的模型称为通用图灵机(和图灵机的计算模型和计算能力并无不同)，这样，我们就可以不需要让模型依赖于解决问题的算法. 冯诺依曼机下面，我们将图灵机做进一步的组件拆分，把读写输入指令的叫做控制器，支持存储的区域叫做存储器，把运算指令单独作为一个部件，再加上输入和输出设备，这样图灵机就可以根据预先给定的指令，来处理输入数据，并将结果传输到输出设备中。 注意 冯诺依曼机拥有和图灵机一样的计算能力，此外还具备和输入输出能力。这也是现代计算机的组成模型 计算机软硬协同代入上面的理论，可以发现，具体的一个物理计算机实际上是通用图灵机的实现，物理计算机所支持的指令集就是通用图灵机的输入，相当于预先给定了一个输入，算法的输入就交给程序员。计算机系统分为硬件和软件，那么软件如何驱动硬件呢，就要根据机器支持的指令集,访问内存模型，访问输入输出设备模型来编写指令，硬件就只管读取输入的指令串，就实现了软件编程。一般的指令集有intel和AMD的x86，AArch64,mips等注意 x86分为32位和64位,一般叫做x86_32和x86_64(简称为x64)。AArch32和AArch64是arm架构下的32位和64位指令集。IA64是intel不兼容的x86_32的64位指令集，安装在安腾处理器上，主流市场不常见. 计算机算术整数表示:补码表示(原理是溢出截断情况下运算的等价性)参考浮点表示: 科学计数法的表示，尾数和指数参考 计算机体系结构cpucpu包含了冯诺依曼机中的运算器和控制器(CS,IP).CPU不断执行取出指令，解码指令，执行指令。cpu让IP寄存器始终指向指令区域的下一条，每执行一条指令，ip就指向下一条指令，直到碰到异常或者程序退出。CPU会支持中断，当外部设备或者使用中断指令中断cpu时(外中断)，cpu会跳转到中断处理函数处。cpu内部在遇到运算异常，访问内存权限异常也会发生中断(内中断),并转到中断处理函数处。CPU和其他部件通过总线来相连，总线包括地址总线(用来对内存单元寻址)，数据总线(传输数据)，控制总线(发送控制信号) 内存内存以字节为基本单位划分为内存单元，cpu通过地址总线来确定访问哪个内存单元。内存地址范围是从0-最大值 输入输出设备比如磁盘，GPIO，flash等，cpu通过读写寄存器并按照固定的协议和外部设备交互。 x86-16汇编x86-16寄存器分为通用寄存器，段寄存器,标志寄存器等。通用寄存器包括：ax,bx,cx,dx段寄存器包括:ds,cs,ss,es标志寄存器： eflags(用来存储执行指令过程中溢出，是否为0等标志) x86实模式访存模型cpu一加电就进入实模式，实模式的内存模型是下面这样的物理地址&#x3D;段地址16+偏移地址cpu访问内存按照实际地址来访问，比如访问0x01就是访问从ds16+0x01位置开始向递增方向一个字节的内容。偏移地址最多使用4个部分来指定(应对不同的数据结构) 1target address = BaseReg + IndexReg + Disp 可以按照实际中常用的访问类型来理解： 最简单的就是只有一个Disp,实际上就是绝对地址访问，比如 Disp &#x3D; 0x01 要用到BaseReg一般是访问某个内存块内部的单元 要用到IndexReg部分的一般是数组访问,比如BaseReg指向数组首地址，IndexReg指向数组第几个元素，当数组存的是结构体时，Disp可以表示结构体内的成员 注意 x86实模式下如果不加段前缀，则默认使用的数据段前缀DS.保护模式下分段策略由GDT,LDT和段选择子决定 传送指令(前面是目的操作数，后面是源操作数)向寄存器传输立即数 mov ax,01H把内存单元传输到寄存器 mov ax,[01]把寄存器传输到内存单元 mov [01],ax寄存器之间传参 mov ax,bx,把bx传输给ax注意 段寄存器只能从通用寄存器传送 运算指令add和sub，sub ax,bx是 ax&#x3D; ax - bx，这两个是无进位&#x2F;借位的加减adc和sbb , 这两个是无进位&#x2F;借位的加减mul和div 这两个是无符号乘法除法,并且是单操作数被乘数放在AL&#x2F;AX中，这是x86的默认寄存器规则，有些指令会默认使用特定的寄存器 12MUL reg/mem8MUL reg/meml6 被乘数 乘数 乘积 AL reg&#x2F;mem8 AX AX reg&#x2F;mem16 DX:AX 如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置1。例如，当AX乘以一个 16 位操作数时，乘积存放在 DX和AX(从高到低)寄存器对中。其中，乘积的高16位存放在DX，低16位存放在AX。如果DX不等于零，则进位标志位置1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。被除数都是放在DX:AX中 12DIV reg/mem8DIV reg/meml6 被除数 除数 商 余数 AX reg&#x2F;mem8 AL AH DX:AX reg&#x2F;mem16 AX DX imul和idiv是有符号乘除法，基本行为和无符号乘除法一致 and和or and ax,bx逻辑与和逻辑或 问题 x86乘除法支持多操作数码？ 控制跳转指令跳转分为近转移(只修改ip，段内跳转)和远转移(同时改变cs和ip,段间跳转)， 标号跳转:jmp short 标号(jmp near pt 标号) 近转移jmp far ptr 标号 远转移 绝对地址跳转,跳转地址由寄存器或者内存单元给出jmp regjmp word ptr [内存单元]jmp dword ptr [内存单元], 从内存单元开始处存放着2个字(x86字是16位),高位是目的段地址，低位目的偏移地址 有条件跳转jcxz 如果cx&#x3D;&#x3D;0就跳转跳转可以用来实现分支和循环 入栈和出栈指令push axpush 01hpop ax 调用子过程指令call 和ret&#x2F;retfcall 标号 相当于 12push ip jmp near ptr 标号 ret相当于 1pop ip 因此也对应近跳转和远跳转，标号跳转和绝对地址跳转。绝对地址跳转和上面类似，同时支持寄存器和内存单元 中断指令int n,向cpu发起中断.cpu便会查找中断表中的中断号n所在的位置，跳转到中断号n对应的处理函数去处理int n 相当于 12345pushf push cspush ip# 查中断表得到中断处理函数call cs:ip iret从中断处返回,相当于 123pop ippop cspopf 汇编语法 intel语法 寄存器前无前缀 源操作数在后，目的操作数在前 内存单元用方括号表示,并且地址是[INDEX * WIDTH + BASE + OFFSET] 立即数无前缀，十六进制以h结尾 AT&amp;T 语法 寄存器前有百分号 源操作数在前，目的操作数在后 内存单元用圆括号表示,并且地址是offset(base, index, width)的格式 立即数前被冠以“$”,十六进制数前被冠以“0x” 汇编器gnu汇编主要是as汇编器，gcc将c语言编译后也是调用的as汇编器 nasm汇编另外一种汇编器,同时支持intel和AT&amp;T语法 伪指令伪指令是汇编器支持的指令，比如有IF,DD等。这些不会翻译成机器指令，和编译器的宏和include有点类似 使用qemu学习汇编安装qemu(我是ubuntu系统)1sudo apt install qemu 如果机器上出现了qemu-system-x86_64 qemu-system-i386就表示安装成功了 12345org 0x7c00 ;告诉汇编器程序的入口地址mov ax,1mov bx,2add ax,bx db 0x55,0xaa ;结束表示，整个段程序的大小正好为510字节，占满一个扇区。 编译汇编代码并制作启动盘这里原理就是机器加电bios自检通过后，bios会加载磁盘上第一个扇区(MBR扇区),并执行其中的代码。第一个扇区是用来引导操作系统。把咱们写的汇编程序放入这个扇区，bios会加载并执行这段代码 编译boot代码要加-f binnasm fat.s -f bin -o ..&#x2F;out&#x2F;boot.bin 制作软盘(用linux的loop设备将文件模拟成设备)dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;..&#x2F;out&#x2F;floopy bs&#x3D;512 count&#x3D;2880sudo losetup &#x2F;dev&#x2F;loop11 ..&#x2F;out&#x2F;floopysudo mkfs.fat &#x2F;dev&#x2F;loop11 这步会留出主分区sudo losetup -d &#x2F;dev&#x2F;loop11 卸载设备 将上面编译得到的bin写入mbr,写入上面软盘的第一个扇区dd if&#x3D;..&#x2F;out&#x2F;boot.bin ibs&#x3D;512 of&#x3D;..&#x2F;out&#x2F;floopy obs&#x3D;512 count&#x3D;1 seek&#x3D;0 conv&#x3D;notrunc 使用qemu启动，并使用gdb debug-ex 表示启动时执行的命令, -fda指定启动的软盘qemu-system-i386 -fda ..&#x2F;out&#x2F;floopy -s -Sgdb -ex ‘set architecture i8086’ -ex ‘target remote :1234’ -ex ‘b *0x7c00’ -ex ‘layout asm’这里加的断点0x7c00是x86架构加电后ip指向的位置，咱们编写汇编程序也是放在0x7c00.注意 如果你是使用qemu-system-x86_64平台启动的,需要把架构设置成i386:x86-64即 set architecture i386:x86-64,具体看gdb报错信息 后续你就可以写更多的汇编，并用qemu，gdb调试了,此时汇编是跑在裸机上.后面你会发现，这步实际上就是操作系统boot.但这对于底层的学习才是万里长征第一步，后面还有x86-32,x86-64,x86-64的AVX，保护模式和长模式 汇编的用处在操作系统内核中，经常要用到，比如机器加电引导操作系统(裸机上)，并设置保护模式，在网卡接收数据触发中断，陷入内核时，做的上下文切换(这种一般是被c调用)。 引用 从图灵机到冯诺依曼机 计算复杂性-现代方法 汇编语言-王爽 x86汇编语言从实模式到保护模式 x86指令手册","categories":[{"name":"汇编","slug":"汇编","permalink":"https://dingweiqings.github.io/categories/%E6%B1%87%E7%BC%96/"}],"tags":[{"name":"x86-16汇编","slug":"x86-16汇编","permalink":"https://dingweiqings.github.io/tags/x86-16%E6%B1%87%E7%BC%96/"}]},{"title":"goyacc","slug":"编译器/goyacc实现计算器","date":"2023-09-19T08:45:46.000Z","updated":"2023-09-26T00:41:04.856Z","comments":true,"path":"/2023/09/19/编译器/goyacc实现计算器/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E7%BC%96%E8%AF%91%E5%99%A8/goyacc%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"简单介绍下编译原理词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。AST啥的也理解不透彻. 词法分析token解析字符串流,确定一个个的token,比如在c语言中,确定是if,while这些关键字还是变量名,运算符等.最终会生成符号表。语言中关键字：这些关键字会被保存在一种表中，在解析字符流的时候，如果碰到关键字则直接保留。 词法框架根据正则表达式来定义某种特定token的规则,在解析字符串流的时候，根据正则来判断属于哪种token 常见的词法框架&#x2F;工具lex&#x2F;flex,是通过正则表达式和自定义解析字符串综合工作的 语法分析主要在于如何表达语法规则和检验语法规则. 语法规则编译器大佬提出了一种文法，只关注字符串的变换.并定义终结符号和非终结符号的概念.非终结符号则可以继续产生新符号,从而用字符串实体表达出了语言的语法规则.非终结符号到另外一个符号串叫做产生式. 产生式比如程序一开始会有一个非终结符号S,对于C语言这个语法来说,会有下面的产生式.下面给出部分产生式做说明 1234567S -&gt; void main()&#123;B&#125;B -&gt; Y;Y -&gt; Y;STATEMENT | eSTATEMENT -&gt; D | A | BLOCKD -&gt; TYPE id | TYPE* idBLOCK -&gt; IF(C)&#123;B&#125; ELSE&#123;B&#125; | while(C)&#123;B&#125;A -&gt; id + id | id -id | id * id | id /id 解释一下上面的产生式,id和e,type这些是终结符.第1行: S是非终结符号,可以变成main函数,里面是函数体第2行: 表示函数体可以是分号组成的各种语句第3行: 表示语句之间是可以不断拼接的,从而理论上可写出无限长度的程序第4行：表示语句可以有声明语句,算术运算和语句块第5行: 表示声明语句只能是类型名空格+标志符组成第6行: 表示语句块可以有条件块和循环块第7行: 表示算数运算可以有加减乘除 语法分析的实现给定一组字符串可以是递归去判断,看最终会不会达到终结符,然后比对终结符是否和字符串中的相同.但在实际中采用的是更有效率的DFA表格,预先对产生式处理,然后可以对扫一遍字符串就可以判定是否合法,并构建出语法树 语法树TODO,这块我目前还没搞懂 语法分析框架好在大佬们已经写出来好的工具来给咱们使用了.yacc是语法分析的一种实现，根据用户定义的语法规则，做对应的动作.所有的查询引擎都有这个模块,比如mysql,prometheus.根据不同语言的yacc(c语言),javacc还有goyacc goyacc做一个简单的计算器我们来2步走，主要是这2个方法 123456789type exprLexer interface &#123; Lex(lval *exprSymType) int Error(s string)&#125;type exprParser interface &#123; Parse(exprLexer) int Lookahead() int&#125; expr函数前缀,goyacc中可以自定义. 在自己的app中可以直接调用Parser来分析。但要提供lex的实现.下面实例中就可以看到 分析词法细心的同学就会发现,这里实际上实现了上面lexer的2个接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func (x *exprLex) Lex(yylval *exprSymType) int &#123; for &#123; c, _, err := x.input.ReadRune() if err != nil &#123; return eof &#125; switch c &#123; case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;: return x.num(c, yylval) case &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;: return int(c) case &#x27;×&#x27;: return &#x27;*&#x27; case &#x27;÷&#x27;: return &#x27;/&#x27; case &#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\n&#x27;, &#x27;\\r&#x27;: default: log.Printf(&quot;unrecognized character %q&quot;, c) &#125; &#125;&#125;// Lex a number.func (x *exprLex) num(c rune, yylval *exprSymType) int &#123; var b bytes.Buffer b.WriteRune(c)L: for &#123; c, _, err := x.input.ReadRune() if err != nil &#123; return eof &#125; switch c &#123; case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;e&#x27;, &#x27;E&#x27;: b.WriteRune(c) default: _ = x.input.UnreadRune() break L &#125; &#125; yylval.num = &amp;big.Float&#123;&#125; _, ok := yylval.num.SetString(b.String()) if !ok &#123; log.Printf(&quot;bad number %q&quot;, b.String()) return eof &#125; return NUM&#125;func (x *exprLex) Error(s string) &#123; log.Println(&quot;parse error: &quot;, s)&#125; 分析语法产生式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687%&#123;package mainimport ( &quot;fmt&quot; &quot;math/big&quot;)%&#125;%union &#123; num *big.Float&#125;%type &lt;num&gt; expr expr1 expr2 expr3 // 定义在后面的符号比定义在前面的符号具有更好的优先级%token &#x27;+&#x27; &#x27;-&#x27; &#x27;*&#x27; &#x27;/&#x27; &#x27;(&#x27; &#x27;)&#x27;%token &lt;num&gt; NUM%%top:expr&#123; if $1.IsInt() &#123; fmt.Println($1.String()) &#125; else &#123; fmt.Println($1.String()) &#125;&#125;expr:expr1&#123;&#125;|&#x27;+&#x27; expr&#123; $$ = $2&#125;|&#x27;-&#x27; expr&#123; $$ = $2.Neg($2)&#125;;expr1:expr2&#123;&#125;|expr1 &#x27;+&#x27; expr2&#123; $$ = $1.Add($1, $3)&#125;|expr1 &#x27;-&#x27; expr2&#123; $$ = $1.Sub($1, $3)&#125;;expr2:expr3&#123;&#125;|expr2 &#x27;*&#x27; expr3&#123; $$ = $1.Mul($1, $3)&#125;|expr2 &#x27;/&#x27; expr3&#123; $$ = $1.Quo($1, $3)&#125;;expr3:NUM|&#x27;(&#x27; expr &#x27;)&#x27;&#123; $$ = $2&#125;%% 应用中如何调用分析器读取命令行的输入,并调用分析器 12345678910111213141516171819func main() &#123; in := bufio.NewReader(os.Stdin) a := big.Float&#123;&#125; a.String() for &#123; if _, err := os.Stdout.WriteString(&quot;&gt; &quot;); err != nil &#123; log.Println(&quot;WriteString: &quot;, err) &#125; line, err := in.ReadBytes(&#x27;\\n&#x27;) if err == io.EOF &#123; return &#125; if err != nil &#123; log.Fatalf(&quot;ReadBytes: %s&quot;, err) &#125; //调用分析器 exprParse(newExprLex(line)) &#125;&#125; 运行安装go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;goyacc@latest goyacc使用 Usage of goyacc: -l disable line directives -o string parser output (default “y.go”) -p string name prefix to use in generated code (default “yy”) -v string create parsing tables (default “y.output”)会根据你的语法规则(.y后缀的)生成.go文件. -o指定文件的名称 -p 指定生成parse函数前缀,默认是叫yyParse,以供外部调用goyacc -o expr.go -p expr expr.y 构建go build expr.go lexer.go main.go 执行 goyacc 做json parser最主要是整理出json的产生式,然后理解下yacc框架下的整体工作流程，就可以搞出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990%&#123;package jsonparsertype pair struct &#123; key string val interface&#123;&#125;&#125;func setResult(l yyLexer, v map[string]interface&#123;&#125;) &#123; l.(*lex).result = v&#125;%&#125;%union&#123; obj map[string]interface&#123;&#125; list []interface&#123;&#125; pair pair val interface&#123;&#125;&#125;%token LexError%token &lt;val&gt; String Number Literal%type &lt;obj&gt; object members%type &lt;pair&gt; pair%type &lt;val&gt; array%type &lt;list&gt; elements%type &lt;val&gt; value%start object%%object:&#x27;&#123;&#x27; members &#x27;&#125;&#x27;&#123; $$=$2 setResult(yylex, $$)&#125;members:&#123; $$ = map[string]interface&#123;&#125;&#123;&#125;&#125;| pair&#123; $$ = map[string]interface&#123;&#125;&#123;$1.key: $1.val&#125;&#125;| members &#x27;,&#x27; pair&#123; $1[$3.key] = $3.val $$ = $1&#125;pair:String &#x27;:&#x27; value&#123; $$ = pair&#123;key: $1.(string), val: $3&#125;&#125;array: &#x27;[&#x27; elements &#x27;]&#x27;&#123; $$ = $2&#125;elements:&#123; $$=[]interface&#123;&#125;&#123;&#125;&#125;| value&#123; $$=[]interface&#123;&#125;&#123;$1&#125;&#125;|elements &#x27;,&#x27; value&#123; $$=append($1, $3)&#125;value: String| Number| Literal| object &#123; $$ = $1 &#125;| array 测试代码见https://github.com/dingweiqings/study/tree/master/goyacc-study 引用 龙书 编译原理 yacc使用","categories":[{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"}]},{"title":"mysql查询源码","slug":"数据库/mysql查询源码","date":"2023-09-19T08:44:52.000Z","updated":"2023-09-19T08:44:52.157Z","comments":true,"path":"/2023/09/19/数据库/mysql查询源码/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9F%A5%E8%AF%A2%E6%BA%90%E7%A0%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"运算符重载","slug":"C++/运算符重载","date":"2023-09-19T08:41:51.000Z","updated":"2023-09-26T02:58:06.169Z","comments":true,"path":"/2023/09/19/C++/运算符重载/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"类之间的运算这里可以利用抽象代数的观点来看待这种处理,把运算扩充到任意的集合上,而不是只在数集上.运算可以对应于某个集合下元素之间的关系,可以在运算的世界中表达逻辑.在软件工程观点来看,让代码变得简洁 C++运算符重载：用同一个运算符完成不同的运算功能。限制基本原则 C++运算符重载的相关规定如下： 1.不能改变运算符的优先级。 2.不能改变运算符的结合性。 3.默认参数不能和重载的运算符一起使用，也就是说，在设计运算符重载成员函数时不能使用默认函数。 4.不能改变运算符的操作数的个数。 5.不能创建新的运算符，只有已有运算符可以被重载 6.运算符作用于C++内部提供的数据类型时，原来含义保持不变 7. 重载的运算符至少有一个操作数是自定义类型 C++中可被重载的运算符： 不可被重载的运算符 sizeof .: 成员运算符 .* 成员指针运算符 :: 作用域运算符 ?:: 条件运算符 typeid: 运行时信息运算符 const_cast&#x2F;dynamic_cast&#x2F;static_cast&#x2F;reinterpret_cast 类型转换运算符上面这些并不是表达元素之间的运算关系,而是取成员和类型转换,这些由类的元数据决定,当一个类确定之后,这些的运算结果就应该是确定的 只可通过成员函数重载 &#x3D; 赋值 () 函数调用 [] 下表 -&gt; 通过指针访问类成员 格式123456789函数类型 operator 重载运算符（形参表）&#123; 函数体；&#125;//非成员函数friend 函数类型 operator 重载运算符（形参表）&#123; 函数体；&#125; 原理实际上都是编译器做了特定表达式&#x2F;类型下运算符-&gt;函数的转换.最终都被编译器转换成函数 实例重载自增自减运算符123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class MyClass2&#123; int n;public: MyClass2(int i)&#123; n = i; &#125; int operator ++()&#123; n++; return n; &#125; int operator ++(int)&#123; n += 2; return n; &#125; void display() &#123; cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass2 A(5), B(5); A++; ++B; A.display(); B.display(); return 0;&#125; 重载双目运算符成员函数假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。若把op重载为A类的成员函数，该函数只有一个形参，形参的类型是obj2所属的类型。是把op前面的看成对象,op右边的看出函数参数 1obj1.operator op(obj2) 友元函数假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。 若把op重载为A类的友元函数，该函数有两个形参，经过重载之后，表达式“obj1 op obj2”解释为： 1obj1 op(obj1,obj2) 重载赋值运算符哈哈,这里不就是我们熟悉的拷贝构造函数和赋值运算符.找到理论和实际的结合点了 重载下标运算符下标运算符“[ ]”通常用于获取数组的某个元素，重载下标运算符可以实现数组下标的越界检测等。下标运算符重载只能作为类的成员函数，不能作为类的友元函数。 重载new delete换运算符new和delete只能被重载为类的成员函数，不能重载为友元。而且，无论是否使用关键字static进行修饰，重载了的new和delete均为类的静态成员函数。 运算符new重载的一般格式如下： 12345void *类名：：operator new(size_t,参数表)；void* operator new(size_t size,int x,int y,int z)&#123;……&#125;void *类名“::operator delete(void*,参数表); 使用如下: 1x*pX=new(1,2,3) X; 重载类型转换运算符这个特性是和拷贝构造函数对应的,比如有一个类Stock可以根据传入的double来构造, 1234567class Stock&#123; public: Stock(double t)&#123; value = t; &#125; int value;&#125; 那么如果要将Stock转出double呢,就要用到下面的类型转换运算符.这两个函数是一一对应的格式: 1234operator 类型名（）&#123; 函数体；&#125; 重载函数调用运算符函数调用运算符“（）”只能说明成类的非静态成员函数，该函数具有以下的一般格式： 1函数类型 类名：：operator()(参数表) 重载移位运算符按照输入流和输出流的概念,如果能有一种运算符可以让对象直接和输入流输出流交互,就不用再写printf(“%s”)这种冗余代码了,还要记类型的format.于是我们想,把移位看出向输入流和输出流传递数据,正好有左移和右移.开口大的流向开口小的.于是会有下面的代码: 12输出流 &lt;&lt; obj输入流 &gt;&gt; obj 幸运的是,C++大佬们设计出了这样的特性. 根据友元函数运算符重载的特点,对于双目操作符是将 obj1 op opj2转换成 op(obj1,obj2);并且这样还可以支持任意一种自定义类型却不用修改std库中输入流和输出流的代码.这实际上也是友元函数重载解决的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; //ostream是标准的输出流，全局只能有一个，所以用引用引用的方式 out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); return 0;&#125; 运算符重载的坑意外的类型转换在编程实践中,对于类型转换和拷贝构造函数有可能发生了意外的隐式转换,导致bug,所以最好是加上explict关键字,告诉编译器不要做隐式转换 重载双目运算符不满足交换律1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class MyClass2&#123; int n;public: MyClass2(int i)&#123; n = i; &#125; MyClass2 operator +(int a)&#123; n+=a; return n; &#125; void display() &#123; cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl; &#125; friend MyClass2 operator +(MyClass2 a, int b)&#123; a.n += b; return a; &#125;&#125;;int main()&#123; MyClass2 A(5), B(5); A = 5 + A;// 会报错 A.display(); B.display(); return 0;&#125; 例子中会无法通过编译,因为双目运算符成员函数左边必须是对象，友元重载必须参数类型要匹配(按照前面双目运算符的等价函数调用来理解)。这就导致的加法不满足交换律. 过多的转换函数导致的二义性假定Stock有形参为double的拷贝构造函数,并且重载了Stock类之间的加法 1234Stock a(1.0);double b = 2.0;Stock total;total = a + b;// 将b转成Stock，再相加 如果此时还又定义了Stock到double的转换函数,那么最后一行将不知道是将a转成double还是将b转成Stock,导致歧义 测试代码见我的github 引用 C++ Prime Plus C++重载运算符实例","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"生活","slug":"生活","date":"2023-09-15T03:20:47.000Z","updated":"2023-09-25T03:56:43.145Z","comments":true,"path":"/2023/09/15/生活/","link":"","permalink":"https://dingweiqings.github.io/2023/09/15/%E7%94%9F%E6%B4%BB/","excerpt":"","text":"生活保持一颗淡泊的心,自己会变的很轻松愉快.坚持一项运动，会一生受益.坚持早睡早起,会一生受益.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://dingweiqings.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"文化理解","slug":"文化理解","permalink":"https://dingweiqings.github.io/tags/%E6%96%87%E5%8C%96%E7%90%86%E8%A7%A3/"}]},{"title":"c++11新特性","slug":"C++/C++新特性","date":"2023-01-17T11:40:56.000Z","updated":"2023-09-22T02:56:09.307Z","comments":true,"path":"/2023/01/17/C++/C++新特性/","link":"","permalink":"https://dingweiqings.github.io/2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"lambda函数 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。 123456789[]：默认不捕获任何变量；[=]：默认以值捕获所有变量；[&amp;]：默认以引用捕获所有变量；[x]：仅以值捕获x，其它变量不捕获；[&amp;x]：仅以引用捕获x，其它变量不捕获；[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；[this]：通过引用捕获当前对象（其实是复制指针）；[*this]：通过传值方式捕获当前对象； 智能指针C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。实现原理是通过类达到作用域后的构造和析构来实现的 独占指针unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括： 1、拥有它指向的对象 2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作 3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象 共享指针多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。 弱指针weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 移动语义编译器通过参数的类型实现重载函数决断，对于右值入参，优先调用形参为右值引用的函数。形参为右值引用类型的接口实现方式一般和传统接口（例如拷贝构造、拷贝赋值）实现方式不同，简单来说前者为浅拷贝，后者为深拷贝，即前者为“窃取”后者为副本复制，形如本文开篇那张图片所示（class string） 多线程支持 原子类,thread类，条件变量类 注意 本文测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/smartpoinerhttps://github.com/dingweiqings/study/tree/master/cpp_study/src/thread 引用 移动语义 https://cloud.tencent.com/developer/article/1385969 多线程 https://immortalqx.github.io/2021/12/04/cpp-notes-3/ C++智能指针 https://www.cnblogs.com/tenosdoit/p/3456704.html lambda函数 https://www.jianshu.com/p/d686ad9de817","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"面向对象","slug":"C++/面向对象","date":"2023-01-17T11:40:28.000Z","updated":"2023-10-05T03:36:47.159Z","comments":true,"path":"/2023/01/17/C++/面向对象/","link":"","permalink":"https://dingweiqings.github.io/2023/01/17/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的软件设计方式大型软件工程中是根据需求中的实体来建模的,对象往往代表了这些实体。具有这些实体的属性，并以提供和其他对象交互的函数。有以下的优势： 逻辑容易设计和理解 可以提高代码功能逻辑的复用 代码上高内聚低耦合，面向接口依赖 提供了运行时的动态绑定 面向对象的基本概念和模式类：类是描述一类对象的特征和提供特定功能的代码实体，同时也是实例的模板，实例以类为模板实例: 具体的一个对象，具有实例变量，是类的一个具体化。类有静态属性和动态属性之分，静态属性是所有实例共享的，动态属性是每个实例特有的，又称实例属性 举个例子，以人为例1234567891011121314151617181920usingnamespace std::string;class Person&#123; private: int age; string name; string work; public: static string motherland; private: string doWork()&#123; std::cout&gt;&gt;&quot;我在做xxxjob&quot;; &#125; public: string buy(string car)&#123; std::cout&gt;&gt;&quot;买了&quot;&gt;&gt;car; &#125; &#125;;Person::motherland = &quot;中国&quot;;Person zhangsan = Person(10,&quot;张三&quot;,&quot;学生&quot;);Person lisi = Person(25,&quot;李四&quot;,&quot;程序员&quot;); 来验证前面的理论，类是实体的建模，成员是对实体属性的抽象。两个实例zhangsan和lisi是类Person的具体化，动态属性的值各不相同。但都有一个共享的静态变量。类有特定功能的函数或者说有特定行为的函数，这些函数用来和其他对象交互. 进一步的概念经过上面的例子，就可以归纳出在代码实体上的概念： 成员变量,类的属性 方法，类的特定行为的函数 成员变量和方法的权限 普通函数，和c中函数类似，不在类的代码块内部 构造函数和析构函数 继承，对象的树级关系 虚函数，子类可以重写的方法，编译器用virtual关键字来识别 纯虚函数，用来定义接口，带有纯虚函数的不能实例化,编译器用virtual关键字+方法体&#x3D;0来定义 抽象基类,用做接口定义,包含纯虚函数的类是抽象基类，不能实例化，只能被继承，实例化成他的子类 类型兼容原则所指的替代包括以下情况： 子类对象可以当作父类对象使用 子类对象可以直接赋值给父类对象 子类对象可以直接初始化父类对象 父类指针可以直接指向子类对象 父类引用可以直接引用子类对象 下面介绍构造函数和析构函数默认构造函数和无参构造函数默认构造函数是创建对象时默认调用的,如果没有声明，则编译器会按照一定条件来默认创建一个无参的构造函数，当然自己也可以声明无参的。自己声明了，编译器则不会再创建。编译器创建的构造函数并不会赋初始值。编译器的创建策略主要是 有非基本类型的成员(自定义类型或者string类型),并且这些成员本身有默认构造函数。这种情况是如果只有基本类型在拷贝对象时，直接拷贝内存块即可 有虚函数和虚继承，这种情况是需要虚函数表 继承的父类有默认构造函数这里推荐一个网站，可以用来查看编译后的汇编代码。https://godbolt.org/引用1中的结论我是验证过的，在gcc13.2上。记住要加-O0(减号大o后面跟个优化等级)才可以得到结果 如果自己只定义了默认构造函数，编译器是否会生成拷贝&#x2F;赋值&#x2F;移动构造函数？如果程序中有用到对象拷贝赋值则会生成并调用默认的构造函数，没有用到则不会生成 如果只定义了拷贝构造函数，还会生成默认构造函数吗？这种不会，编译会报错 析构函数在释放对象时，编译调用的函数。如果是用来继承的类，必须声明为虚函数 父子类的构造函数和析构函数顺序构造：先基类，再子类析构：先子类，再基类对上面继承时析构函数需要声明为虚函数做些说明，因为虚函数再调用时才会根据运行时状态，调用子类对象的析构函数。编译器又会自动释放基类，从而可以完整的释放这条继承链上的所有对象。不是虚函数的话，会直接调用基类的析构函数，发生内存泄露 拷贝构造函数形如下面的code 1234567891011121314//调用拷贝构造生成对象A a ;A b = A(a);//函数返回值A doSomeWork()&#123; A work; ... return work;&#125;//函数参数void doSomeWork(A other)&#123; ...&#125; 拷贝构造是一定会生成新对象的，可能是临时的，过一会被删除。这也解释了为啥函数参数推荐使用引用或者指针，避免了重复创建临时对象。关于函数的2种情况实际上可以统一，从程序的内存布局来理解，都是在调用者和被调用者栈帧之间拷贝对象，因为栈帧内的内存会用完就被释放。 赋值运算符形如下面的code 1234A a;B b;C c;c=b=a; 赋值号左右两边都是已经存在的对象，不会产生新对象 移动构造函数这个函数还是为了减少内存拷贝带来的特性。在编程中，有些类中会包含大的成员数组，或者大的成员变量。如果在拷贝赋值时可以直接将这个大的成员直接移动给目标对象，可以减少很多拷贝开销。语义上理解很像是移动或者所有权转移。那怎么去实现他呢？需要一种标志来表示程序员啥时候可以使用移动语义，现在的引用是无法转移的。于是，那些C++大牛们提出了一个另外一种引用，当参数中以这种形式的引用出现时，编译器就会按照移动语义来实现。一般文献中会称为右值引用,就可以理解为一种引用，不过是用来标志支持移动语义的。左值和右值可以相互转换 1234A (A&amp;&amp; other)&#123; array = other.array; //移动 other.array = nullptr;&#125; 移动运算符和上面类似的，运算符两边都是已经存在的对象，并且是移动语义 注意 拷贝构造&#x2F;拷贝赋值与移动构造和移动赋值如果自己提供了其中一个，则编译不会提供另一个。因为只要有一种就都可以编译通过。可通过&#x3D;default来声明 前面的测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/construct 汇编验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl; &#125; Person&amp; operator=(const Person&amp; p) &#123; cout &lt;&lt; &quot;Assign&quot; &lt;&lt; endl; return *this; &#125;private: int age; string name;&#125;;void f(Person p)&#123; return;&#125;Person f1()&#123; Person p; return p;&#125;int main()&#123; Person p; Person p1 = p; // 1 Person p2; p2 = p; // 2 f(p2); // 3 p2 = f1(); // 4 Person p3 = f1(); // 5 getchar(); return 0;&#125; 将上面代码拷贝到https://godbolt.org/ C++的对象模型面向对象的语言都需要解决下面几个问题: 对象的成员数据存储和访问 对象的成员函数存储和访问 对象的静态成员和方法的存储的访问 在有继承的情况下，前面1，2，3怎么处理 对于多态的运行时绑定策略 对象的创建和释放 几种可能的实现 简单对象模型暴力一点，对每个实例，都把成员数据和成员函数都都拷贝一份，这样不就都可以访问到了吗？静态成员还是要单独存储。继承把父类的成员数据和函数都拷贝一份，因为每个实例有自己独立的拷贝，所以多态是自然支持的 基于表格的模型第一种的内存消耗太大，虽然访问都是固定时间.于是，我们产生了第二种想法，可以将成员函数和成员数据分开来存储。把成员函数放入一个表格之中，这样成员函数就可以被所有实例共享。成员数据还是随每个实例存储，每个成员额外增加一个指向成员函数表格的指针。想法是根据成员函数有共享性，成员数据是独立性。这里先记住2个名字，函数表指针和函数表 C++的成员变量存储和访问静态变量和静态函数静态变量是转变成global变量，但会由编译器控制可见性。就类似于普通定义的全局变量.所以访问也是和普通变量类似,通过地址直接访问 无继承的情况类似于c结构体的存储,按照声明变量的顺序和大小，从低地址到高地址存储。当然中间可能会由于体系结构要求的对齐。这里C++并未规定，变量必须连续存储，只要按照变量声明的顺序即可。也就是说，可以在成员变量缝隙间插入特定的内容.详细可见《深入探索对象模型》的第3章3.2节 123456class A&#123; public: int a; int b; virtual void function();&#125; 先忽略虚函数表的内容，后面会再介绍 单一继承的情况子类会将父类实例成员拷贝一份.类似于包馅饼。因为这样才可以完整的实现多态，否则向上转型取字段就不对了。 多重继承(继承树上无重复)就包多次馅饼,从小到大包.所以此时,如果有重名变量和方法，需要明确指定基类.比如:两个基类中有重名的方法和变量,SetWeight,则需要用完全限定名称 123SleepSofa a;a.Bed::SetWeight(1);a.Sofa::SetWeight(2); 多重继承(继承树上有重复)这种情况，如果还是包馅饼,对于继承树上重复出现会被多个子节点包进去,造成内存的浪费，也会导致访问和修改的歧义。C++大佬们又想了个办法，(后面你会发现和虚函数的处理策略是类似的).增加了共享继承的机制，用现有的关键字virtual，语义同虚函数相同。在类对象中增加一个虚基类指针，用以指向虚基类在实例中的偏移量。虚基类指针在内存中放在哪里呢？有2种放置策略 将所有虚继承的父类都搞一个指针放在实例中,指向基类在实例中的内存位置，以用来访问成员。这种每个实例都有额外的指针存储，在基类很多的情况下，开销较大 多个虚继承的父类就搞一个虚继承表(和虚函数表很像),指代基类在实例中的偏移量。由于类的布局是固定的，所以只需要准备一份这个表即可。(根据候捷大佬《深入探索C++模型》原文中说微软编译器是这样做的) 和虚函数表放在一起，gcc和clang是这样做的，下面会详细分析gcc的虚函数表 C++的成员函数存储和调用静态函数静态函数就是只能访问静态变量的函数，除此之外函数的存储和调用和其他成员函数无区别，静态函数不能是虚函数，编译期就可以得到地址. 继承树中所有类都无虚函数这种和普通非成员函数调用无区别，编译期就可以确定 虚函数无继承编译器会创建一个虚函数表,在实例中增加一个隐藏成员,这个成员指向虚函数表的位置 123456789101112131415161718class Base &#123; Base() = default; virtual ~Base() = default; void FuncA() &#123;&#125; virtual void FuncB() &#123; printf(&quot;FuncB\\n&quot;); &#125; int a; int b;&#125;;int main() &#123; Base a; return 0;&#125; 注意 详细介绍一下虚函数表中的概念， 整个虚函数表,是一个数组,每一项8字节（64位架构下）固定长度,所以可以按照偏移量来索引 function pointer 存储虚函数的区域,每一项都是一个内存地址,指向函数的入口,按照源码顺序来排列 virtual base offset 虚函数表中有些项存储的是虚基类的偏移量 offset to top 这种项记录的是和当前实际类型的开头的偏移量下面给出一个简单vtable例子,有个简单的印象12345Vtable for AA::vtable for A: 3 entries0 (int (*)(...))08 (int (*)(...))(&amp; typeinfo for A)16 (int (*)(...))A::af 单继承的情况(这种很重要,平常用的最多,而且是理解后续模型的基础)12345678910111213141516171819202122class Base &#123; Base() = default; virtual ~Base() = default; void FuncA() &#123;&#125; virtual void FuncB() &#123; printf(&quot;Base FuncB\\n&quot;); &#125; int a; int b;&#125;;class Derive : public Base&#123;&#125;;int main() &#123; Base a; Derive d; return 0;&#125; 注意 这里可以发现,父类的vptr指针指向的也是子类的vtable.如果子类有覆盖父类的方法,虚函数表中就填子类的,如果没有就把父类的拷贝过来.每个类都有自己的虚函数表,并不是通过共享虚函数表来实现继承的. 多重继承这种是每个继承树上的每一个类在实例内存中指向自己类的function pointer,这样在调用基类虚函数时，会查找到实际类型的函数地址,从而实现多态下面会详细介绍如果根据虚函数表查找实际类型的函数地址注意 这里有个主基类的说法，编译器会在继承的父类中找一个有虚方法的父类，复用他的vptr,在调用主基类的方法时不需要调整this指针。下面虚函数表的会详细解释 虚继承在继承树上有重复类的时候,根据前面对象数据成员内存布局,需要添加一个基类的偏移量来表示每个基类在实例中的内存位置.gcc是把基类指针放在虚函数表中,下面会详细介绍虚函数表 虚函数表这些内容比较复杂,另起一篇文章gcc的虚函数表 gcc查看虚函数表gcc的虚函数表 gdb打印对象内存布局gdb命令 每行打印一个结构体成员可以执行set print pretty on命令，这样每行只会显示结构体的一名成员，而且还会根据成员的定义层次进行缩进 按照派生类打印对象set print object on 查看虚函数表通过如下设置：set print vtbl on 之后执行如下命令查看虚函数表：info vtbl 对象或者info vtbl 指针或引用所指向或绑定的对象 c++名称转换GNU提供的从name mangling后的名字来找原函数的方法，c++filt工具,执行c++filt _ZTV1A在线反修饰名称的网站http://demangler.com/ 汇编查看实例函数调用汇编中会额外增加一个this指针,一般是放在rdi寄存器中 总结基本要解决的问题是下面几个？ 如何保证子类可以继承父类的成员和非虚方法？这两种是编译期就可以决定访问地址的,主要思想是包馅饼，vtable和成员都是类似的思想 如何保证子类调用自己重载的虚方法？每个基类都有一个指针，指向子类的vtable,并在调用非主要基类的子类方法时调整this指针 补充MSVC ABI和Itanium ABI(gcc和clang遵循这个标准)C++ Itanium ABI 主要分为四大板块： 指导程序中的各种数据结构如何正确而一致地在内存中布局（Data Layout）；指导在二进制层面如何调用其他函数（调用约定，Calling Convention）；为 C++ 的异常处理机制提供正确的实现（Exception Handling）；定义输入到链接器的对象文件的格式（Linkage &amp; Object Files） 引用 gcc生成默认构造器的策略 gcc生成拷贝构造和默认构造的策略 深入探索C++对象模型-候捷 图解对象内存模型 gcc deveploper option 打印对象vtable内存布局 gdb 打印内存布局 Itanuim ABI","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"堆","slug":"数据结构/堆","date":"2022-11-22T02:14:57.000Z","updated":"2023-10-07T11:12:32.740Z","comments":true,"path":"/2022/11/22/数据结构/堆/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86/","excerpt":"","text":"完全二叉树每个节点一定是先有左孩子，再有右孩子.当出现了叶节点之后，后续所有的节点都必须是叶节点。叶节点只可能会出现在倒数第一层和倒数第二层. 下标关系 123父=(child-1)/2左孩子=parent*2+1右孩子=parent*2+2 实现 一般叫做堆，名字不重要，常用数组来实现，因为完全二叉树有良好的下标关系，可以把数组看成一颗树 jdk中的优先级队列默认实现的是小根堆，PriorityQueue 支持修改元素字段的堆但在修改堆中元素后无法保持序的特性,下面介绍这种改写堆的方法主要是resign方法，找到元素对应的位置，同时向上和向下调整,复杂度为O(logn).Main方法中有对数器和使用方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package org.kurt.datastructure.heap;import java.util.ArrayList;import java.util.HashMap;import java.util.PriorityQueue;/** * 手写堆,支持修改元素的字段，并依旧保持堆的性质， * 插入O(logn),修改O(logn),修改元素字段O(logn) * 堆结构,实际上是完全二叉树,不过以数组形式存储。实现的是小根堆 */public class MyHeapType&lt;T extends Comparable&gt; &#123; /** * 堆的大小 */ private int size; private ArrayList&lt;T&gt; arr; /** * 记录元素子啊堆中的位置 */ private HashMap&lt;T,Integer&gt; indexMap ; public MyHeapType()&#123; arr = new ArrayList&lt;&gt;(); indexMap = new HashMap&lt;&gt;(); &#125; public void push(T value) &#123; heapInsert(value, size++); &#125; public T pop() &#123; if (size &gt; 0) &#123; swap(0, size - 1); T ans = arr.get(size-1); size--; heapify(0); return ans; &#125; return null; &#125; public T peek()&#123; if(size&gt;0)&#123; return arr.get(0); &#125; return null; &#125; /** * 修改堆中元素 * @param t */ public void resign(T t) &#123; heapInsert(t, indexMap.get(t)); heapify(indexMap.get(t)); &#125; /** * 把参数放到index位置 * @param arr * @param index */ private void heapify(int index) &#123; //从index开始向下调整 //调整到什么时候停 int child = 0; while (index &lt; size) &#123; child = 2 * index + 1; if (child &gt;= size) &#123; break; &#125; child = child + 1 &lt; size &amp;&amp; arr.get(child + 1).compareTo(arr.get(child))&lt;0 ? child + 1 : child; if (arr.get(index).compareTo(arr.get(child)) &gt; 0) &#123; swap(index, child); &#125; else &#123; break; &#125; index = child; &#125; &#125; private void swap(int a, int b) &#123; T tmp = arr.get(a); arr.set(a, arr.get(b)); arr.set(b, tmp); indexMap.put(arr.get(a), a); indexMap.put(arr.get(b), b); &#125; /** * 向上调整 * @param arr * @param value */ private void heapInsert(T value, int index) &#123; if(index &gt;= arr.size())&#123; arr.add(value); &#125;else&#123; arr.add(index, value); &#125; indexMap.put(value, index); while (arr.get(index).compareTo(arr.get((index - 1) / 2)) &lt; 0) &#123; swap(index, (index - 1) / 2); index = (index - 1) / 2; &#125; &#125; public static class Student implements Comparable&lt;Student&gt;&#123; public int score; public String name; public Student(int score, String name) &#123; this.score = score; this.name = name; &#125; /** * * @param o the object to be compared. * @return */ @Override public int compareTo(Student o) &#123; if (score &gt; o.score) &#123; return -1; &#125; else if (score &lt; o.score) &#123; return 1; &#125; return 0; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;score=&quot; + score + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; public static void main(String[] args) &#123; //对数器和系统的优先级队列做比对 for (int i = 0; i &lt; 1000; i++) &#123; MyHeapType&lt;Student&gt; heapType = new MyHeapType&lt;&gt;(); PriorityQueue&lt;Student&gt; queue = new PriorityQueue&lt;&gt;(); int size = (int) (Math.random() * 1000); for (int j = 0; j &lt; size; j++) &#123; int score = (int) (Math.random() * 1000); Student tmp = new Student(score, &quot;A&quot; + score); heapType.push(tmp); queue.offer(tmp); &#125; System.out.println(queue.peek() + &quot; &quot; + heapType.peek()); if (queue.peek() != heapType.peek()) &#123; System.out.println(queue.peek() + &quot; &quot; + heapType.peek()); System.out.println(&quot;ERROR&quot;); &#125; &#125; System.out.println(&quot;PASS&quot;); MyHeapType&lt;Student&gt; heapType = new MyHeapType&lt;&gt;(); Student a = new Student(100,&quot;a&quot;); Student b = new Student(18,&quot;b&quot;); Student c = new Student(30,&quot;c&quot;); heapType.push(a); heapType.push(b); heapType.push(c); System.out.println(heapType.peek()); //修改学生的分数,再调用resign,这样堆会重新做调整,系统堆做不到 b.score=110; heapType.resign(b); System.out.println(heapType.peek()); &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://dingweiqings.github.io/tags/%E5%A0%86/"}]},{"title":"线性同余","slug":"算法/线性同余","date":"2022-11-22T02:12:32.000Z","updated":"2023-10-09T08:00:30.511Z","comments":true,"path":"/2022/11/22/算法/线性同余/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99/","excerpt":"","text":"随机数随机数一般可以用来仿真，抽样，生成测试数据来检验正确性。但生成真正的随机数是很难的，下面介绍一种伪随机数算法 线性同余伪随机数生成算法序列周期取到模数n的称为满周期,c&#x3D;0称为乘同余法, ,称为混合同余法 code实现java中java.util.Random类的实现中，发生器的关键代码如下： 123private static final long multiplier = 0x5DEECE66DL;private static final long addend = 0xBL;private static final long mask = (1L &lt;&lt; 48) - 1; 12345678910111213141516171819202122private static final long multiplier = 0x5DEECE66DL; private static final long addend = 0xBL; private static final long mask = (1L &lt;&lt; 48) - 1; //如果是32位int,则 protected int next(int bits) &#123; long oldseed, nextseed; //用的是long类型 AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); //线性同余,mask就是模数,模数取的是2的幂次，所以取余可以这样取 nextseed = (oldseed * multiplier + addend) &amp; mask; &#125; while (!seed.compareAndSet(oldseed, nextseed)); //转成int型 return (int)(nextseed &gt;&gt;&gt; (48 - bits)); &#125; public int nextInt() &#123; return next(32); &#125; 混合同余法满周期的数学原理定理1由(模数m,乘数a,增量c和初始值x0)所确定的线性同余序列达到满周期当且仅当： (c,m)&#x3D;1 对m的任一素因子p,有 如果4|m则， a&#x3D;1的特殊情况如果 则同余式变成,显然满足条件2和条件3.且同余式有较简单的表达式: 当周期为时，有并且 又(c,m)&#x3D;1,故 又这样就证明了充分性. 必要性在a&#x3D;1时，条件2和条件3是显然满足的,(c,m)互素由 可知成立 注意 a&#x3D;1不具有随机性; 又在 的情况下根据同余性质, 故下面都假设 下面根据计算机程序设计艺术-第2卷-第3章论文中来介绍一下充分性和必要性,主要思想是得出递推式和x0的关系,将模数m做素数分解,这样会得到一个重要的简化定理，模数m的周期等于模数m素数分解得到的所有因数周期的最小公倍数. 引理1(得到递推式) 设是产生的随机数序列,且,则有 其中, 特别的，取 ,即有 证:(用数学归纳法)当n&#x3D;0显然成立;假设当n&#x3D;k时成立,则当n&#x3D;k+1时,有 令,即有 引理2(模数做素数分解)设 是线性同余产生的随机数序列,周期为,对m做素数分解,,其中 为素数,. 记是由(初始值,乘子,增量,模数)为确定的随机数序列,周期为 ,其中 , 则有： ,即为 的最小公倍数 证: 先证明素数分解只有2个数的情况,即 故，两者互素, ,由定义知： 故根据同余性质, 即 ,于是.同理有. 不妨设,下证： 一方面,由周期定义知,,则,由前面的结论知，,从而由周期的定义知,,同理,故有最小公倍数的定义知,, 另一方面,设为任一公倍数,则由h是周期的倍数知 递推由的定义由前面结论 同理有, 综合上面2式，根据同余性质有 故有周期的定义知,,又是的任一倍数,故 对于素数分解2个以上的，由归纳法可知结论成立 引理3(一个数论结论)设p为素数,且, 如果 则. 证:(二项式定理展开)由条件知, 其中且是素数,从而有 其中 显然, 因 即当,在组合数中总是可以分出一个p来,凑出这个因子(可分为p&#x3D;2和p&gt;2来讨论),所以p整除Q中带有组合数的项,但还有单独1这一项， 故 ,故 引理4(一个数论结论)如果 ,则: 对任意都成立 证: 则， 于是可以仍然满足引理3的条件，继续应用引理3，得到: 其中 即 下面证充分性,即要证: 对任意都成立 对分子因式分解，化简有 由命题条件知令可有同余和整除等价性 同理对于每个都可以提出一个总共有项但可以多提出一个故总共可以提出 因此充分性的得证.必要性是显然的.因为 肯定包含一个的因子 引理5(化简到初始值为0)由(模数m,乘数a,增量c和初始值x0)所确定的线性同余序列达到满周期当且仅当 的周期为证:必要性:比较显然，达到满周期的含义是不论x0的初始值是多少都是满周期 充分性: 设另有2个序列,其中只有初始值不同是满周期 由于和的取值都在之间并且每个值都只会出现一次，记经过次迭代 则由周期定义即 引理6(递推式的性质)设 其中为素数,如果 是使得的最小正整数则 当时当时 证: 必要性(用反证法): 如果,则有 因为,可利用同余和整除的等价性有: 又,故 ,于是当 时, 由同余和整除的等价性, 但由费马定理知, ,这里和假设矛盾, p&#x3D;2时,如果 则或者 (1). 如果 ,根据同余和整除等价性,有 , 等式右边是奇数等式左边是偶数,矛盾(2). 如果 ,则由引理4知,这与是最小的矛盾,必要性得证 充分性:设对于引理中p&#x3D;2和p&gt;&#x3D;2的情况，都满足引理3的条件,并且重复应用引理3,可有: 每次方则模次数加其中,又由引理3的证明过程中， ,令x=a,有,故有 其中 特别的,有 这个同余式表示, 是的倍数即,故是这种形式又根据同余式知故 备注这个引理的充分性的证明在Hull和Dobell的论文Random Number Generators是通过二项式定理展开来证明的说实话，这段整除性分析我没看懂。在高德纳的书中，是采用引理3的结论来证明的,可以发现，证明方法也是在基于新知识不断改进的 定理1的证明终于来到主定理的证明了 由引理5,只需要考虑初始值为 的情况,由引理1,可以得到一个简单的通项表达式, 由引理2知,只需要证明 达到满周期即可,因为m的素数分解各个部分都是互素的,最小公倍数就是它们的乘积下设 必要性: 用反证法,若 ,则设 中的项都是位于中, 则可以取到1,即 但是不互素故而,导出矛盾,条件1证毕,接下来,引理5可将命题化简为要证明:当 时序列满周期.由引理6的必要性知,定理1的必要性成立. 充分性： 还是有引理5,可将命题充分性化简为要证明:当 时满足条件条件条件前提下有序列满周期.由引理6的充分性知定理1的充分性成立 线性同余统计检验 频数检测目的是检测待测试二进制序列中，“0”和“1” 数目是否近似相等。 块内频数检测目的是确定在待测序列中，所有非重叠的长度为M位的块内的“0”和“1”的数目是否表现为随机分布。还有其他的很多检验指标 线性同余理论检验待研究补充中 乘线性同余先直接给出下面的定理,证明待后续补充。当c&#x3D;0时，由定理1知，不会达到满周期.但选择合适的模数和乘数可以使周期达到m-1,在实际中已经够用了。这一个定理由高斯在他的算术研究中给出. 定理2当c&#x3D;0时,可能的极大周期为 ,如果: x0与m互素 a是以m为模的原根其中 是的欧拉函数值 注意如果m为素数,则可得到长度为m-1的周期 其他随机数算法梅森旋转算法 总结 随机数这块理论其实很复杂的,尤其是理论证明.不得不膜拜高德纳老爷子的功底.那几本计算机程序设计艺术太难懂了,起码数学专业的博士才能读懂大部分.不过读书是这样的,需要当你把知识基础补充好之后,才能读懂.不过这本书的作者高德纳老爷子是图灵奖的获得者,读不懂也很正常。虽然读不懂，但还是尽量去读，学习顶尖数学家的思想和思维方式.可能TAOCP要我花一辈子去读了吧 读了文献之后，你发现其实一个理论的完善不是一代人搞出来的,是逐步完善. 一开始随机数只证明了 的特殊情况,后面证明了充分性,到我们这代才完整的把充分必要性说清楚 引用 随机数课件 计算机程序设计与艺术-高德纳 线性同余满周期的充分性证明中文版 线性同余随机数 高德纳介绍 高德纳斯坦福个人主页","categories":[{"name":"算法","slug":"算法","permalink":"https://dingweiqings.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"随机数","slug":"随机数","permalink":"https://dingweiqings.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"}]},{"title":"素数判定和素数筛","slug":"算法/素数","date":"2022-11-22T02:12:14.000Z","updated":"2023-09-27T07:49:24.144Z","comments":true,"path":"/2022/11/22/算法/素数/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"素数判定埃氏筛法 整体流程是从小到大遍历，并将利用小的因数将后面大的合数剔除掉 原理就是合数和素数的判定条件 边界条件就是不能超过n,可以从i*i开始比较 复杂度是O(nloglogn)埃氏筛的时间复杂度为O(n log log n)，其中n是要筛选质数的范围。具体地，该算法的复杂度可以分为两部分：1.标记合数的复杂度：O(n)。因为每个数最多只会被标记一次，而每个数最多有log log n个质因数，所以总共需要进行O(n log log n)次操作。2.枚举质数的复杂度：O(n log log n)。因为每个质数最多只会被枚举一次，而n个数中质数的个数约为n&#x2F;ln n，所以总共需要进行O(n&#x2F;ln n)次操作。因此，总的时间复杂度为O(n log log n)。 版本1123456789101112131415161718192021bool is_prime[N];int Eratosthenes(int n) &#123; int p = 0; //初始化标记数组,先标记成都是素数,后面是合数就擦掉 for (int i = 0; i &lt;= n; ++i) &#123; is_prime[i] = 1; &#125; is_prime[0] = is_prime[1] = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (is_prime[i]) &#123; prime[p++] = i; // prime[p]是 if (i * i &lt;= n &amp;&amp; i*i &gt; 0)//防溢出 //i的倍数都是合数,实际上也是i*2,i*3，但由于在2-i-1时已经处理过了, //所以接下来从i*i,i*(i+1)=i*i+i,.... for (int j = i * i; j &lt;= n; j += i) is_prime[j] = 0; &#125; &#125; return p;&#125; 只筛奇数的版本12345678910111213141516171819bool is_prime[N];int Eratosthenes(int n) &#123; int p = 0; for (int i = 0; i &lt;= n; ++i)&#123; is_prime[i] = 1; &#125; is_prime[0] = is_prime[1] = 0; // i * i &lt;= n 说明 i &lt;= sqrt(n) //只需要筛一半 for (int i = 2; i * i &lt;= n; ++i) &#123; if (is_prime[i]) &#123; prime[p++] = i; for (int j = i * i; j &lt;= n; j += i) is_prime[j] = 0; &#125; &#125; return p;&#125; 只保留奇数的版本is_prime可以只申请n&#x2F;2一半，因为偶数肯定是合数 线性筛如果能让每个合数只被标记一次，复杂度就来到了O(n) 1234567891011121314151617181920void init(int n) &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; pri[cnt++] = i; &#125; for (int j = 0; j &lt; cnt; ++j) &#123; if ( (long long)(i * pri[j]) &gt; n)&#123; break; &#125; vis[i * pri[j]] = 1; if (i % pri[j] == 0) &#123; // i 之前被 pri[j] 筛过了 // 由于 pri 里面质数是从小到大的，所以 i乘上其他的质数的结果一定会被 // pri[j]的倍数筛掉 break; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://dingweiqings.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://dingweiqings.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"线程池","slug":"java/线程池","date":"2022-11-22T01:49:13.000Z","updated":"2023-10-04T07:29:35.183Z","comments":true,"path":"/2022/11/22/java/线程池/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"java的执行流模型java应用是单进程多线程模式,执行流的实体是线程，每个线程拥有自己独立的调用栈,堆和打开文件是共享的。线程实际上是对体系结构中的多线程的支持。 java的多线程线程是一个对象，这个对象可以执行某个函数，我暂且叫他运行函数。此外线程还有休眠,中断,加入，和线程私有存储等功能。实际上线程更像是一个worker,worker有执行task的能力，并且worker还可以和其他worker协作。当程序员需要另起一个执行流的时候，就需要使用线程.大白话就是你用一个线程来放歌，一个线程来浏览网页,一个线程来下载电影. 在大数据技术栈中的zk,es,hadoop等等都是这种多线程模式,一组线程负责心跳,一组线程负责内部rpc，一组线程提供外部访问 简单介绍下jvm的线程实现jvm实际上是一个c++程序,在linux中被执行后就进入jvm的入口函数,这里会封装env,开辟堆内存,初始化jit等等，最后会启动一个main线程，来执行程序员编写的main函数。Main线程和普通线程的执行模型区别并不大。下面是创建普通线程的代码. 只有在调用线程start方法时，才会真正在linux中创建线程 1234Thread thread = new Thread(()-&gt;&#123;&#125;);//这里Thread实际是一个普通对象,对其中的parent,线程id做了一些赋值 thread.start();//这里才真正在操作系统中创建线程，并加入linux的就绪队列 注意 判断在jvm主进程中还是在java虚拟机中： 只要是调用了native方法，都是在jvm主进程中直接执行的.普通的java方法都是经过jvm字节码翻译&#x2F;编译后执行的。比如gc和jdk库中的一些native方法. 如果要访问java虚拟机外的资源就只能在jvm主进程中Main线程是jvm主进程帮忙创建,并调用start方法.这里借用一下网上的一张时序图.start0() 这个本地方法，最终映射到了 JVM_StartThread 这个方法中，在&#96;&#96;hotspot\\src\\share\\vm\\prims\\jvm.cpp&#96;如果你对C++比较熟悉的话，会发现java的线程实际上还是pthread_create出来的，所以线程的sleep,interput都是调用的native方法，因为需要访问linux的线程，在jvm中是做不到的。 线程中断和cpu中断类似，对于执行流模型来说，都需要一个中断机制来中断执行流.cpu通过中断来响应外部事件，陷入操作系统等.*线程中断可以用做终止线程的标志位;对于线程阻塞在某些可中断方法的场景，中断会抛出中断异常，让程序员来处理中断阻塞方法的后置处理注意 线程中断标志位并不会终止线程，只是设置了一个标志位 Thread.interupted() 方法会有副作用，清空当前的标志位。我觉得这个叫clearInterupted更好,返回值是当前的中断标志位。因为需要提供一个方法来清空标志位. 线程池的作用线程池是一种资源池，可以达到复用的效果.此外，还可以增加并行度(因为线程是一个worker). 常见的资源线程池有：数据库链接池等. 常见的任务线程池有：tomcat的service线程池,netty的event事件处理线程池,spring的定时任务线程池等线程池在软件工程上来说，也实现了线程调度和业务逻辑的分离。 jdk的线程池框架采用的还是抽象基类的模式.Executor是最顶层接口. AbstractExecutorService是抽象基类.常见的线程池实现有定时任务线程池ScheduledThreadPoolExecutor,实时线程池ThreadPoolExecutor jdk线程池的特性如何描述一个线程池？自然的是池里面有多少个线程,因此有核心线程数(最小线程数)，最大线程数,线程存活时间.线程池还需要给定一个异常处理策略，否则线程池不知道该如何处理执行发生时的异常.线程池也是一个资源池，访问资源会出现排队的情况，因此也需要指定线程池的队列大小 核心线程数，最大线程数 异常处理策略 队列大小 线程存活时间 ThreadPoolExecutor详解(基于jdk11)先提出几个问题？如何维护线程keepAlive？如何执行任务？线程池如何退出？ 线程池状态维护线程池维护了几个成员,corePoolSize,maxinumPoolSize,keepAliveTime,rejectHandler,workQueue(保存任务的阻塞队列),mainLock(主要是用来控制对线程池成员的并发访问的),ctl(是个int,但是分段使用的,高位保存的是线程池的状态,低位保存的是线程的woker数量) 线程池总共有5个状态,所以用到了int的高3位. 状态机是 RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED,越往后数字越大。正常关闭是RUNNING -&gt; SHUTDOWN -&gt; TIDYING -&gt; TERMINATED; 立即关闭是RUNNING -&gt; STOP -&gt; TIDYING -&gt; TERMINATED 1234567891011121314151617181920212223242526272829303132333435363738394041private static final int COUNT_BITS = Integer.SIZE - 3; //29private static final int COUNT_MASK = (1 &lt;&lt; COUNT_BITS) - 1;//1向右移动29位，来到第30位,再 减1变成, 连续的29个1 // runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS; // 111, 补码，最低位是3个1 ,这个状态是里面最小的,private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; // 000private static final int STOP = 1 &lt;&lt; COUNT_BITS; // 001private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; // 010private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // 011...private static boolean runStateLessThan(int c, int s) &#123; return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123; return c &gt;= s;&#125;// 比SHUTDOWN小的就只有RUNNING，也可以用runStateOf(ctl) == RUNNING 来比较,搞不懂为啥这样写,逻辑反而更复杂了private static boolean isRunning(int c) &#123; return c &lt; SHUTDOWN;&#125;...if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty())) return;if (workerCountOf(c) != 0) &#123; // Eligible to terminate interruptIdleWorkers(ONLY_ONE); return;&#125;... // Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~COUNT_MASK; &#125; //state对应的是work count那一段全部为0private static int workerCountOf(int c) &#123; return c &amp; COUNT_MASK; &#125; // work count对应的是取maskprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; //ctl = runState + workCount ,位运算的知识 执行任务当在调用submit&#x2F;execute时，主要流程如下: 先检查线程池状态，如果已经处于SHUTDOWN或者更高级别，则不往线程池里面加;如果是running，并且小于coreSize，则新创建线程来执行 如果大于coreSize，则看能否加到队列里去 如果加不到队列里去，如果没有大于max线程数，则开启一个线程去处理下面对照代码来解释前面的流程:1234567891011121314151617181920212223242526public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //小于coreSize，则直接addWorker； if (workerCountOf(c) &lt; corePoolSize) &#123; //addWorker内部会检查线程池状态，如果处于SHUTDOWN就不再加了 if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果是运行中,则尝试加入到队列中 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); // //并发访问控制在在addWorker中已经做了，这里主要是在shutdown状态下，不再加入任务，将先前加入的并移出去 if (!isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果是running,并且没有大于maxSize则开启一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false);//这里第二参数表示非核心线程的意思 &#125; //如果不是running,并且没有大于maxSize则开启一个线程;如果队列满了并且没有大于maxSize则开启一个线程； else if (!addWorker(command, false)) reject(command);&#125; 接下来看addWorker方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (int c = ctl.get();;) &#123; //这里如果是SHUTDOWN以上的，就直接终止流程 if (runStateAtLeast(c, SHUTDOWN) &amp;&amp; (runStateAtLeast(c, STOP) || firstTask != null || workQueue.isEmpty())) return false; for (;;) &#123; //校验最大线程数在这里 if (workerCountOf(c) &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK)) return false; //如果修改workerCount成功了,就表示增加woker成功了, if (compareAndIncrementWorkerCount(c)) break retry; //如果workerCount没有修改成功，继续获取状态，继续修改 c = ctl.get(); // Re-read ctl if (runStateAtLeast(c, SHUTDOWN)) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //创建worker w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int c = ctl.get(); if (isRunning(c) || (runStateLessThan(c, STOP) &amp;&amp; firstTask == null)) &#123; if (t.getState() != Thread.State.NEW) throw new IllegalThreadStateException(); //用锁保护的woker set workers.add(w); workerAdded = true; int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //让worker开始执行 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; 接下来看worker类,worker继承了AQS.它的lock逻辑上表达的是正在执行的,非idle的.主要流程是： 如果是第一个task,则取出来， 不断循环从队列中取数据,不断执行任务.如果在keepAliveTime时间内没有取到任务，线程就自动退出了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //不断取任务 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //前置后置钩子函数 beforeExecute(wt, task); try &#123; //执行 task.run(); afterExecute(task, null); &#125; catch (Throwable ex) &#123; afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125; &#125;private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); // Check if queue empty only if necessary. if (runStateAtLeast(c, SHUTDOWN) &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //超过keepAliveTIme，就返回 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125; &#125; 线程池退出主要流程是： 修改线程池状态 中断idle的线程 等待原先加入到线程中的任务被执行完下面对照代码来解释前面的流程：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //设置下一个状态 advanceRunState(SHUTDOWN); //中断那些idle的, interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125;final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); //设置state if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty())) return; if (workerCountOf(c) != 0) &#123; // Eligible to terminate interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); &#125; finally &#123; ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125; 这里设置线程中断标志好像并不是必要的，因为只要线程池处于TERMINATED状态(在调用shutdown之后,线程池的SHUTDOWN状态是内部状态),无法再提交任务，队列中的任务总会被执行完。这也是线程池设计的目标，不会丢掉任何一个没有执行的任务。并且中断标志并不会终止线程，只是设置标志。所以我理解这里是保持一致性，在线程池被调用shutdown之后，需要保持线程的中断标志都被设置。可能在提交的任务里有根据中断来作为终止条件的. 总结开头提出的问题： 如何保持线程的keepAlive?如果在keepAlive时间内，在阻塞队列中没有取到任务，线程就执行完毕并退出 如何执行任务?用一个while循环，不断从阻塞队列中取任务，并调用task.run() 如何退出？线程池会维护内部的状态，在调用shutdown之后，就设置为TERMINATED,等待阻塞队列中已有任务执行完，线程会挨个终止，自然线程池也就退出了","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"java 线程池","slug":"java-线程池","permalink":"https://dingweiqings.github.io/tags/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"TreeMap","slug":"java/TreeMap","date":"2022-11-22T01:41:23.000Z","updated":"2023-09-16T00:31:13.795Z","comments":true,"path":"/2022/11/22/java/TreeMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/TreeMap/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"红黑树 平衡搜索树","slug":"红黑树-平衡搜索树","permalink":"https://dingweiqings.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"非阻塞队列","slug":"java/非阻塞队列","date":"2022-11-22T01:41:08.000Z","updated":"2023-10-05T09:35:36.063Z","comments":true,"path":"/2022/11/22/java/非阻塞队列/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","excerpt":"","text":"队列fifo的一种数据结构 jdk中的非阻塞队列ConcurrentLinkedQueue主要流程下面结合代码来解释 offer1234567891011121314151617181920212223242526272829public boolean offer(E e) &#123; final Node&lt;E&gt; newNode = new Node&lt;E&gt;(Objects.requireNonNull(e)); for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123; // p is last node if (NEXT.compareAndSet(p, null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;. if (p != t) // hop two nodes at a time; failure is OK TAIL.weakCompareAndSet(this, t, newNode); return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; poll主要流程下面结合代码来解释 123456789101112131415161718192021222324252627public E poll() &#123; restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;; p = q) &#123; final E item; if ((item = p.item) != null &amp;&amp; p.casItem(item, null)) &#123; // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; else if (p == q) continue restartFromHead; &#125; &#125; &#125; final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123; // assert h != null &amp;&amp; p != null &amp;&amp; (h == p || h.item == null); if (h != p &amp;&amp; HEAD.compareAndSet(this, h, p)) NEXT.setRelease(h, h); &#125; LinkedTransferQueueLinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。 核心方法12345678910111213141516171819202122232425262728private E xfer(E e, boolean haveData, int how, long nanos) &#123; if (haveData &amp;&amp; (e == null)) throw new NullPointerException(); restart: for (Node s = null, t = null, h = null;;) &#123; for (Node p = (t != (t = tail) &amp;&amp; t.isData == haveData) ? t : (h = head);; ) &#123; final Node q; final Object item; if (p.isData != haveData &amp;&amp; haveData == ((item = p.item) == null)) &#123; if (h == null) h = head; if (p.tryMatch(item, e)) &#123; if (h != p) skipDeadNodesNearHead(h, p); return (E) item; &#125; &#125; if ((q = p.next) == null) &#123; if (how == NOW) return e; if (s == null) s = new Node(e); if (!p.casNext(null, s)) continue; if (p != t) casTail(t, s); if (how == ASYNC) return e; return awaitMatch(s, p, e, (how == TIMED), nanos); &#125; if (p == (p = q)) continue restart; &#125; &#125;&#125; offer主要流程下面结合代码来解释 poll主要流程下面结合代码来解释 123public E poll() &#123; return xfer(null, false, NOW, 0);&#125; poll超时123456public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E e = xfer(null, false, TIMED, unit.toNanos(timeout)); if (e != null || !Thread.interrupted()) return e; throw new InterruptedException();&#125;","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"非阻塞队列 java queue","slug":"非阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"}]},{"title":"阻塞队列","slug":"java/阻塞队列","date":"2022-11-22T01:41:08.000Z","updated":"2023-10-05T09:27:36.682Z","comments":true,"path":"/2022/11/22/java/阻塞队列/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/","excerpt":"","text":"队列fifo的一种数据结构 jdk中的阻塞队列 下面以LinkedBlockingQueue为例来讲解主要是利用ReentrantLock和条件变量来实现并发安全的,有一个AtomicInteger成员，记录容量。有插入锁和获取锁.对于队满和队空不管是offer还是take都会做通知 offer主要流程 在入队前先获取锁，在入队后释放锁.如果队满和队空做下通知下面结合代码讲解1234567891011121314151617181920212223242526272829public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; if (count.get() == capacity) return false; final int c; final Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; //获取put锁 putLock.lock(); try &#123; //如果满了，则直接失败 if (count.get() == capacity) return false; //入队 enqueue(node); //这里是先get再add c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; //释放锁 putLock.unlock(); &#125; //因为上面是先get再add,只有当从不空变为空时才通知消费者 if (c == 0) signalNotEmpty(); return true; &#125; offer限定时间主要流程和前面的offer一样，主要是获取put锁变成了支持中断,如果在队满的时候,就加个超时等待，给定时间内队列依旧是满的，则失败下面结合代码讲解 1234567891011121314151617181920212223242526public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); final int c; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; if (nanos &lt;= 0L) return false; nanos = notFull.awaitNanos(nanos); &#125; enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return true; &#125; poll主要流程 获取take锁，然后出队，并在队空和队满时做通知下面结合代码讲解1234567891011121314151617181920212223public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) return null; final E x; final int c; final ReentrantLock takeLock = this.takeLock; //获取take锁 takeLock.lock(); try &#123; if (count.get() == 0) return null; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1)//通知 notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity)//如果前一步是等于队列容量，现在取出来了一个，就不满了，通知在入队的生产者 signalNotFull(); return x; &#125; poll限定时间和前面poll的流程差不多，主要是加了个在队空时的超时等待下面结合代码讲解 123456789101112131415161718192021222324public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; final E x; final int c; long nanos = unit.toNanos(timeout); final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly();//可中断获取锁 try &#123; while (count.get() == 0) &#123; if (nanos &lt;= 0L) return null; nanos = notEmpty.awaitNanos(nanos);//等待 &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"阻塞队列 java queue","slug":"阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"}]},{"title":"ConcurrentHashMap","slug":"java/ConcurrentHashMap","date":"2022-11-22T01:40:46.000Z","updated":"2023-10-04T07:41:37.339Z","comments":true,"path":"/2022/11/22/java/ConcurrentHashMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/ConcurrentHashMap/","excerpt":"","text":"线程安全线程安全的哈希表成员变量putget","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"concurrent hash map","slug":"concurrent-hash-map","permalink":"https://dingweiqings.github.io/tags/concurrent-hash-map/"}]},{"title":"HashMap","slug":"java/HashMap","date":"2022-11-22T01:40:38.000Z","updated":"2023-10-05T09:02:24.675Z","comments":true,"path":"/2022/11/22/java/HashMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/HashMap/","excerpt":"","text":"哈希表是一种kv的数据结构，插入查找都是O(1)的 哈希函数用来生成key的哈希值的函数,一般都是根据类成员的哈希值再相加 jdk中的HashMap哈希表的一种实现,插入和查找都是依据 key的哈希函数生成的哈希值来确定位置的。冲突时使用的是拉链法 put主要流程: 调用哈希函数获取哈希值，对数组长度取余，找到对应的桶。如果桶中无元素，直接放入如果桶中有元素，再看是否和当前元素和已有元素是否相同， 如果相同，则覆盖原有的值 如果不相同，则使用拉链法，在链表尾部插入一个节点或者把链表变成树 下面结合代码来解释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//如果还没有初始化数组,则初始化一个 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null)//如果对应的桶处没有元素,则创建一个 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //p是对应桶处的元素,这里是在判断是否是同一个key if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //冲突的元素，链表法或者转成树(一般不会走到) for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; //在最后面加上一个节点 p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; //如果相同，则覆盖原有的值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //如果达到阈值则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; get主要流程是 先用哈希函数找到对应的桶，如果已经存在，再遍历链表或者树下面结合代码来解释：123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; 扩容主要流程 扩容大小为原来2倍，更新阈值为容量*loadFactor 找到在新数组中的位置,这个有个简单的数学原理由于扩容是总是扩容2倍，一开始大小也是2的幂次，故大小总是为2的幂次设当前大小为newsize，则hash % newsize = hash &amp; (newsize-1); 因为比newsize低的位都会是余数的位。更进一步,设某个桶在原数组中下标为x，在新数组中下标为y，原数组大小为oldsize,则x,y满足123456hash % oldsize=xif (hash &amp; oldsize ==1 )&#123; y = x + oldsize//分支1&#125;else&#123; y = x//分支2&#125; 原因还是因为比数组大小低的位哪些会对余数产生贡献。 根据上面原理，在拷贝原数组的元素时，只需要将桶后面的链表拆分成2部分，一部分属于分支1，一部分属于分支2，放入对应的桶中即可下面结合代码来解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order //将原来的链表拆分成2部分,先叫做low和high吧 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //根据最后一位来判断是要放入low部分还high部分 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // //把low部分的链表头部放入 newTab[j]位置 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //把high部分的链表头部放入 newTab[j + oldCap]位置 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"}],"tags":[{"name":"hashmap 哈希表","slug":"hashmap-哈希表","permalink":"https://dingweiqings.github.io/tags/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"crc算法实现","slug":"算法/crc实现","date":"2022-11-21T03:26:27.000Z","updated":"2023-10-09T08:03:38.604Z","comments":true,"path":"/2022/11/21/算法/crc实现/","link":"","permalink":"https://dingweiqings.github.io/2022/11/21/%E7%AE%97%E6%B3%95/crc%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"奇偶校验校验位只有一位,根据编码长度中1的个数来确定这1位的数值有两种校验方法：奇校验和偶校验,实际上是根据看奇数为1还是偶数为1,可以在接收端模2来校验奇校验：原始码流+校验位 总共有奇数个1偶校验：原始码流+校验位 总共有偶数个1 数学原理编码的数学推导模2除法无进位的相加&#x2F;无进位的相减&#x2F;异或这些说的都是一个东西，以4bit长度为例 1234 1101+ 1011-------- 0110 模2除法就是二进制除法，但是在相减时采用无进制相减 多项式代数和多项式除法高等代数中的多项式代数知识 12M/N=Q...R 这里容易得到，R会比N幂次要低，就和整数除法m&#x2F;n&#x3D;q..r ，0&lt;&#x3D;r&lt;n 一样 除法规则-竖式除法每次消去余数最高项，直到余数最高次项小于除数!除法 编码算法将二进制看成多项式,这里是整个crc想法来源.比如1101可以看成,从高到低的第i个数字为.因为网络序是大端序,高位先传输 设校验码+原信息长度共n位,其中校验码长度为k.在msg长度为n位的前提下，介绍一个除式,记作G(x),其最高项次数为k,并记原信息叫做S(x),最高项次数为n-k-1. 则根据多项式的带余除法,知一定存在一对唯一的P(x)和R(x)使得,其中R(x)的次数小于Q(x)的次数,存在性和唯一性对模2带余除法也成立(后面会做证明). 于是将原先的多项式带余除法推广到模2带余除法，自然就有 此时再令，这一步是关键,因为模2除法相加和相减结果是一样的,是可以被整除的，余式为0.即由,可得 ,可得. 于是当接收端收到数据后，再做 模2带余除法存在性和唯一性存在性因为与普通带余除法每区别，不管是无进位相减还是带进位相减，最终都会得到一个结果，故存在性比较显然 唯一性设另外存在P(x)和T(x)，也满足条件.则有,因为 ,故 注意这里用的是模2加减法 能检测哪些错误这里最主要的是一个建模,核心在这里。是沟通理论和实际的桥梁。接下来就是理论上的证明了.所以我们思考问题的时候，是需要去寻找理论中的概念和原理，并将其和实际对应起来.对于包含错误的bit流可以看成 ,其中F(x)是加上校验码的bit,E(x)是信道传输过程中可能错误的bit. 如果,则表示存在错误.如果选择的G(x)能够使下面命题成立,则表示可以检测出错误. 当余数为0等价于E(x)为0 …(命题1) E(x)不为0时等价余数不为0 …(命题2) 解释：余数为0也可能是G(x)整除E(x).命题1和命题2也是等价的 定理1 如果G(x)至少有2项,则可以检测出所有的单bit错误 证明: 单bit错误表示,那么只有当G(x)形如时才E(x)会被整除。只要G(x)至少有2项那么就无法整除E(x). 命题1成立 定理2 如果是G(x)因式,则可以被检测所有的奇数个bit错误 证明:假定通过G(x)生成的编码信息为F(x), 则 其中 , 令x&#x3D;1可得, 故F(1)一定是偶数,F(x)又是多项式,故F(x)一定有偶数项.所以当发生奇数个错误时余式一定不为0.命题2成立 剩下的定理原论文中总共给出了8条定理,目前水平有限,等待后续领悟。 原论文原论文是大牛Peterson在1961年发布的论文Cyclic Code for Error Detection. crc碰撞这里介绍2个单词,在编码领域会经常要讨论的一个问题.冲突概率conflict collisions.我之前其实一直想不通,既然会有概率冲突，为啥还可以用来做校验呢？ 后面我想明白了，加密安全和传输校验不一样，信息传输过程中即使碰到了冲突也是可以接受的，接收端就认为这是源端发送的数据。但是当校验错误，接收端就要求源端重新发送。还有一个特性就是，信道一般发生错误集中在某一段内，不会产生各种各样的花式错误. 就像md5一样，虽然大家一直在用，但md5也会有冲突，愿意使用就表示接受冲突带来的结果。md5由我国的王小云院士优化了破解算法md5冲突王院士,感兴趣的同学可以看下王院士的主页. 碰撞分析这块涉及到比较复杂的数学知识，留作自己后续的研究方向. 常用的除数多项式所以检测错误的能力和选择多项式的特性有关，不是随便瞎选的见wiki常用的多项式 算法实现 朴素的竖式多项式除法的翻译这里主要思路是用商消去最高位，然后在输入的数组上减去商*生成多项式，因此余数也是保存在输入的被除多项式位置 1234567891011121314151617181920212223242526272829303132int divide( double num[], int nlen, double den[], int dlen, double quotient[], int *qlen )&#123; int n, d, q; // The lengths are one more than the last index; decrement them // here so the call is less confusing nlen--; dlen--; q = 0; // when n &gt; dlen, the result is no longer a polynomial // (e.g. trying to divide x by x^2) for ( n = nlen; n &gt;= dlen; n-- ) &#123; // First, divide the nth element of numerator with the last element // of the denominator quotient[ n - dlen ] = num[ n ] / den[ dlen ]; q++; // Now, multiply each element of the denominator by each // corresponding element of the numerator and subtract the // result for ( d = dlen; d &gt;= 0; d-- ) &#123; num[ n - ( dlen - d ) ] -= den[ d ] * quotient[ n - dlen ]; //采用模2除法，需要修改成这行代码 num[ n - ( denlen - d ) ] = fabs( num[ n - ( denlen - d ) ] ); &#125; &#125; *qlen = q; return ( nlen - *qlen + 1 );&#125; 使用异或来计算这里比较难理解，让我想了很久，还是基于竖式除法的思路，从竖式除法我们可以发现，32位的生成多项式最高位可以不存储，因为每次都是消去最高项；可以用一个32位int来保存余数，长度小于32位的二进制序列余数就是它自己，因此需要在右端补上32位；从竖式除法中我们可以发现，做减法的次数等于被除数长度-除数长度+1； 123456789101112131415161718192021222324unsigned long int compute_crc( unsigned long input, int len, unsigned long divisor )&#123; //要做被除数长度-除数长度+1=24+32-33+1=24 while ( len-- ) &#123; //如果最高位是1，那么这位是要被消去，余数等于剩下的和除数异或；如果最高位是0，我们发现最高位死0，实际上是 //商为0，和全0异或等于它自己，等效于直接左移 input = ( input &amp; 0x80000000 ) ? divisor ^ ( input &lt;&lt; 1 ) : ( input &lt;&lt; 1 ); &#125; //余数存储在32位，这里实际上等价于竖式多项式的低32位；因为运算过程中，余数始终保存在input位置 return input;&#125;... unsigned long int crc32_divisor = 0x04C11DB7; //下面的input按ABC实际上的值字节做了反转，多项式是低字节在低位，为了位对齐 // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, // C // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, // B // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 // A unsigned long int input = 0x8242C200; // ABC; backwards &amp; left aligned printf( &quot;%lx\\n&quot;, compute_crc( input, 24, crc32_divisor ); // 5A5B433A crc查表法https://www.cnblogs.com/esestt/archive/2007/08/09/848856.html 常见组件关于crc的实现 mariadb中用的是查表，或者使用cpu的sse来计算mariadb crc gcc中zlibgcc中zlib 引用 这是大牛的ppt讲解 crc原论文 多项式除法 模2除法 crc32校验和 更详细的crc doc","categories":[{"name":"信号与编码","slug":"信号与编码","permalink":"https://dingweiqings.github.io/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"crc 校验码","slug":"crc-校验码","permalink":"https://dingweiqings.github.io/tags/crc-%E6%A0%A1%E9%AA%8C%E7%A0%81/"}]}],"categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://dingweiqings.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"java","slug":"java","permalink":"https://dingweiqings.github.io/categories/java/"},{"name":"信号与编码","slug":"信号与编码","permalink":"https://dingweiqings.github.io/categories/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"},{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/categories/linux/"},{"name":"汇编","slug":"汇编","permalink":"https://dingweiqings.github.io/categories/%E6%B1%87%E7%BC%96/"},{"name":"随笔","slug":"随笔","permalink":"https://dingweiqings.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://dingweiqings.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"x86","slug":"x86","permalink":"https://dingweiqings.github.io/tags/x86/"},{"name":"jdk 锁框架","slug":"jdk-锁框架","permalink":"https://dingweiqings.github.io/tags/jdk-%E9%94%81%E6%A1%86%E6%9E%B6/"},{"name":"CRC","slug":"CRC","permalink":"https://dingweiqings.github.io/tags/CRC/"},{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"},{"name":"C++ 虚函数 编译器","slug":"C-虚函数-编译器","permalink":"https://dingweiqings.github.io/tags/C-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"std库 模板","slug":"std库-模板","permalink":"https://dingweiqings.github.io/tags/std%E5%BA%93-%E6%A8%A1%E6%9D%BF/"},{"name":"linux","slug":"linux","permalink":"https://dingweiqings.github.io/tags/linux/"},{"name":"x86-16汇编","slug":"x86-16汇编","permalink":"https://dingweiqings.github.io/tags/x86-16%E6%B1%87%E7%BC%96/"},{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"},{"name":"文化理解","slug":"文化理解","permalink":"https://dingweiqings.github.io/tags/%E6%96%87%E5%8C%96%E7%90%86%E8%A7%A3/"},{"name":"堆","slug":"堆","permalink":"https://dingweiqings.github.io/tags/%E5%A0%86/"},{"name":"随机数","slug":"随机数","permalink":"https://dingweiqings.github.io/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"数论","slug":"数论","permalink":"https://dingweiqings.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"java 线程池","slug":"java-线程池","permalink":"https://dingweiqings.github.io/tags/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"红黑树 平衡搜索树","slug":"红黑树-平衡搜索树","permalink":"https://dingweiqings.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"非阻塞队列 java queue","slug":"非阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"},{"name":"阻塞队列 java queue","slug":"阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"},{"name":"concurrent hash map","slug":"concurrent-hash-map","permalink":"https://dingweiqings.github.io/tags/concurrent-hash-map/"},{"name":"hashmap 哈希表","slug":"hashmap-哈希表","permalink":"https://dingweiqings.github.io/tags/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"crc 校验码","slug":"crc-校验码","permalink":"https://dingweiqings.github.io/tags/crc-%E6%A0%A1%E9%AA%8C%E7%A0%81/"}]}
{"meta":{"title":"猫猫攻城狮的博客","subtitle":"","description":"","author":"KurtDing","url":"https://dingweiqings.github.io","root":"/"},"pages":[{"title":"关于我","date":"2023-06-14T06:24:25.000Z","updated":"2023-09-19T09:00:51.607Z","comments":true,"path":"about/index.html","permalink":"https://dingweiqings.github.io/about/index.html","excerpt":"","text":"人生格言 路漫漫其修远兮,吾将上下而求索. 书山有路勤为径，学海无涯苦作舟. 认识自己的无知就是最大的智慧. 物质上的贫穷不可怕,怕的是知识上的贫穷. 当继承革命先烈遗志,守住这一片华夏大地. 人生导师 毛主席,岳飞,苏格拉底,伽利略,牛顿,华罗庚 人生目标 读万卷书，行万里路 发现新知识，为国家和社会做出自己的贡献 关于我我是程序员一枚，对底层和数据科学很感兴趣，数学基础扎实,目前已学习linux,数据库,并行计算,计算机系统相关基础理论.常用编程语言是java&#x2F;C++&#x2F;python. 开源贡献目前有几个小的PR,不属于大的feature,希望能不断积累PR,成为贡献者 mariadb https://github.com/MariaDB/server/pull/2293 https://github.com/MariaDB/server/pull/2393 https://github.com/MariaDB/server/pull/2297 grafana https://github.com/grafana/grafana/pull/51529 flink https://github.com/apache/flink/pull/20755 flink-connector-elasticsearch https://github.com/apache/flink-connector-elasticsearch/pull/48"},{"title":"全部标签","date":"2020-05-08T10:52:51.000Z","updated":"2023-09-15T04:10:44.254Z","comments":true,"path":"tags/index.html","permalink":"https://dingweiqings.github.io/tags/index.html","excerpt":"","text":""},{"title":"全部分类","date":"2020-05-08T10:52:51.000Z","updated":"2023-09-15T04:10:34.766Z","comments":true,"path":"categories/index.html","permalink":"https://dingweiqings.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"yacc使用","slug":"编译器/yacc","date":"2023-09-25T03:10:26.000Z","updated":"2023-09-26T00:48:46.700Z","comments":true,"path":"/2023/09/25/编译器/yacc/","link":"","permalink":"https://dingweiqings.github.io/2023/09/25/%E7%BC%96%E8%AF%91%E5%99%A8/yacc/","excerpt":"","text":"简单介绍下编译原理词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。AST啥的也理解不透彻. 词法分析和语法分析框架lex和yacc是unix下的词法&#x2F;语法分析框架,flex&#x2F;bison是词法&#x2F;语法分析框架bison和yacc实际上用途是同一种，不过在不同平台下,yacc已经成为语法分析框架的代名词。下文统一使用lex&#x2F;yacc Lex和YACC内部是如何工作的？main -&gt;yyparse() -&gt; yylex()yylex 会读取在yyin这个变量中的文件(没有则默认是stdin), yylex不断解析输入流,yyparse不断推导产生式并执行相应动作(在语法文件中定义),直到结束.注意：所以现在语法推导和lex解析算法大多都是O(N),只扫描一遍输入流不回退 lexhello world这个框架实际上会根据给定的配置,来解析字符串 1234567%&#123;#include &lt;stdio.h&gt;%&#125;%%stop printf(“Stop command received\\n”);start printf(“Start command received\\n”);%% 第一部分，位于%{和%}对之间直接包含了输出程序(stdio.h).我们需要这个程序，因为使用了printf函数，它在stdio.h中定义. 第二部分用’%%’分割开来，所以第二行起始于’stop’，一旦在输入参数中遇到了’stop’，接下来的那一行(printf()调用)将被执行. 1匹配的字符串名称 执行动作 我们这里是固定字符串stop,start 除此之外，还有’start’，其跟stop的行为差不多.执行以下命令：编译时，我们增加『-ll』编译选项，因为libl会提供main函数. 12flex helloworld.lexgcc lex.yy.c –o example –ll 正则表达式1234567%&#123;#include &lt;stdio.h&gt;%&#125;%%[0123456789]+ printf(“NUMBER\\n”);[a-zA-Z][a-zA-Z0-9]* printf(“word\\n”); 执行以下命令： 12flex regex.lexgcc lex.yy.c –o example –ll lex中的函数和变量 ytext char * 当前匹配的字符串 yleng int 当前匹配的字符串长度 yin FILE * lex当前的解析文件，默认为标准输出 yout FILE * lex解析后的输出文件，默认为标准输入 ylineno int 当前的行数信息 宏 CHO #define ECHO fwrite(yytext, yyleng, 1, yyout) 也是未匹配字符的默认动作 int yylex(void) 调用Lex进行词法分析 int yywrap(void) 在文件(或输入)的末尾调用。如果函数的返回值是1，就停止解析。 因此它可以用来解析多个文件。代码可以写在第三段，这样可以解析多个文件。 方法是使用 yyin 文件指针指向不同的文件，直到所有的文件都被解析。最后，yywrap() 可以返回1来表示解析的结束。 yaccYACC可以解析输入流中的标识符(token)，这就描述了YACC和LEX的关系，YACC并不知道『输入流』为何物，它需要事先就将输入流预加工成标识符，我们也可以自己手工写一个Tokenizer. yacc中的函数 yyerror()在YACC发现一个错误的时候被调用，我们只是简单的输出错误信息. yywrap()函数用于不断的从一个文件中读取数据，当遇到EOF时，你可以再输入一个文件，然后返回0，你也可以使得其返回1，暗示着输入结束 这里有一个main()函数，它基本什么也不做，只是调用一些函数.可以单独定义也可以就放在grammer.y中 yyparse() 会解析输入流中的token,并结合产生式推导 产生式编译原理中的表达语法的上下文无关文法,确定了字符串的生成变换规则.这里需要将固定的语法拆分成字符串变换规则来理解,如果一个字符串没办法从终结符号结合变换规则得到，则该字符串不符合语法,需要抛出sytnax error.常见的语法分析算法有递归下降,LALR等 实例(实现一个固定语法的温度控制器)我们希望实现下面的功能,如果用户输入heat on 就打开温度控制器,输入heat off就关闭温度控制器,用户还可以通过target temperature set xxx来设定温度值 lexer12345678910111213%&#123;#include &lt;stdio.h&gt;#include &quot;y.tab.h&quot;%&#125;%%[0-9]+ &#123; yylval = atoi(yytext); return NUMBER;&#125;heat return TOKHEAT;on|off return STATE;target return TOKTARGET;temperature return TOKTEMPERATURE;\\n /* ignore end of line */;[ \\t]+ /* ignore whitespace */%% lex根据正则来确定TOKEN,这个也是在yacc产生式中的终结符 grammer123456789101112131415161718192021222324252627282930313233343536373839404142%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void yywrap()&#123; return 1;&#125;void yyerror(char * errmsg)&#123; printf(&quot;%s\\n&quot;,errmsg);&#125;int main()&#123; yyparse();&#125;%&#125;//这里需要和lex中返回的token一致%token NUMBER TOKHEAT STATE TOKTARGET TOKTEMPERATURE%%commands: /* empty */ | commands command;command: heat_switch | target_set;heat_switch: TOKHEAT STATE &#123; printf(&quot;\\tHeat turned on or off\\n&quot;); &#125;;target_set: TOKTARGET TOKTEMPERATURE NUMBER &#123; //展示区别,这里给输入参数+5 printf(&quot;\\tTemperature set %d\\n&quot;,$3 + 5); &#125;;%% 输出对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑执行下列命令 123flex heat.lexbison -d heat-grammer.y --file-prefix ygcc y.tab.c lex.yy.c yacc中的union类型(这种是实际工程中才使用的)温度控制器的新语法用下面方式控制，先选择heater，再设置温度heater mainbuilding Selected ‘mainbuilding’ heater Target temperature 23 ‘mainbuilding’ heater target temperature now 23 yacc中的变量1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374%&#123;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern int yydebug = 1;char * heater=NULL;void yywrap()&#123; return 1;&#125;void yyerror(char * errmsg)&#123; printf(&quot;%s\\n&quot;,errmsg);&#125;int main()&#123; yyparse();&#125;%&#125;%token TOKHEAT TOKTARGET TOKTEMPERATURE TOKHEATER %union&#123; int number; char *string;&#125;%token &lt;number&gt; STATE%token &lt;number&gt; NUMBER%token &lt;string&gt; WORD%%commands: /* empty */ | commands command;command: heat_switch | target_set | heater_select;heat_switch: TOKHEAT STATE &#123; if ($2) printf(&quot;\\tHeat turned on\\n&quot;); else printf(&quot;\\tHeat turned off\\n&quot;); &#125;;target_set: TOKTARGET TOKTEMPERATURE NUMBER &#123; //展示区别,这里给输入参数+5 printf(&quot;\\tHeater &#x27;%s&#x27; temperature set to %d\\n&quot;, heater, $3+5); &#125;;heater_select : TOKHEATER WORD &#123; printf(&quot;\\tSelected heater ‘%s’\\n&quot;, $2); heater = $2;&#125; ;%% 这次我们在command产生式增加了heater_select,并且定义了一个全局变量来接收选择的温度控制器.token处，我们定义了一个union变量,用于处理输入中不同的数据类型.此处表示yylval是一个union类型,可用来处理不同的数据类型 语法123456789101112131415%&#123;#include &lt;stdio.h&gt;#include &quot;y.tab.h&quot;%&#125;%%[0-9]+ &#123; yylval.number = atoi(yytext); return NUMBER;&#125;heater return TOKHEATER;heat return TOKHEAT;on|off &#123; yylval.number = !strcmp(yytext, &quot;on&quot;); return STATE; &#125;target return TOKTARGET;temperature return TOKTEMPERATURE;[a-z0-9]+ yylval.string = strdup(yytext); return WORD;\\n /* ignore end of line */;[ \\t]+ /* ignore whitespace */%% 细心的同学可能已经发现了,这次对于yylval的赋值已经是具体到成员了 输出对于设定的温度,我为了展示有运算逻辑而不是直接拷贝字符串,我特意对参数做了一个加5的逻辑 yacc debug当调试你的语法时，在YACC命令行中添加—debug和—verbose选项，在你的C文件头中添加以下语句：int yydebug &#x3D; 1;这将生成一个y.output文件，其中说明了所创建的那个状态机.可以开启debug语法信息,详细查看yacc状态机和根据产生式推导的过程.这里我mark一下,以便后续自己查阅. 12-t(--debug) -vbison -t -v -d heat-grammer.y -b y 测试代码见我的github代码 推广我们发现lex和yacc可以用来处理有固定语法的字符串,那么我们可以用其来解析配置文件,解析sql,解析json等等.好啦,现在你可以去看mysql和pg的sql解析啦,为学到新知识开心.mysql yaccPostgres yacc 更深入的学习北大编译实践lex和yacc内核 引用 flex和bison flex和bison实现计算器 flex和bison中文版电子书","categories":[{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"}]},{"title":"gcc的虚函数表","slug":"C++/gcc的虚函数表","date":"2023-09-25T00:17:55.000Z","updated":"2023-09-25T03:54:30.812Z","comments":true,"path":"/2023/09/25/C++/gcc的虚函数表/","link":"","permalink":"https://dingweiqings.github.io/2023/09/25/C++/gcc%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/","excerpt":"","text":"虚函数表相关概念gcc查看虚函数表继承结构可视化https://github.com/bingseclab/VirtAnalyzer/blob/master/README.md","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++ 虚函数 编译器","slug":"C-虚函数-编译器","permalink":"https://dingweiqings.github.io/tags/C-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E5%99%A8/"}]},{"title":"std库","slug":"C++/std","date":"2023-09-20T01:29:15.000Z","updated":"2023-09-20T01:57:00.610Z","comments":true,"path":"/2023/09/20/C++/std/","link":"","permalink":"https://dingweiqings.github.io/2023/09/20/C++/std/","excerpt":"","text":"正文见我的有道云笔记https://note.youdao.com/s/TzGJhYmG","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"std库 模板","slug":"std库-模板","permalink":"https://dingweiqings.github.io/tags/std%E5%BA%93-%E6%A8%A1%E6%9D%BF/"}]},{"title":"spark","slug":"大数据/spark","date":"2023-09-19T08:48:23.000Z","updated":"2023-09-19T08:48:23.577Z","comments":true,"path":"/2023/09/19/大数据/spark/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"elasticsearch查询","slug":"大数据/elasticsearch","date":"2023-09-19T08:48:01.000Z","updated":"2023-09-19T08:48:01.644Z","comments":true,"path":"/2023/09/19/大数据/elasticsearch/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E5%A4%A7%E6%95%B0%E6%8D%AE/elasticsearch/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"系统编程","slug":"linux/linux系统编程","date":"2023-09-19T08:47:19.000Z","updated":"2023-09-19T08:47:19.179Z","comments":true,"path":"/2023/09/19/linux/linux系统编程/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/linux/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"文件系统源码","slug":"linux/linux文件系统源码","date":"2023-09-19T08:46:52.000Z","updated":"2023-09-19T08:46:52.903Z","comments":true,"path":"/2023/09/19/linux/linux文件系统源码/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/linux/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"x86汇编","slug":"汇编语言/x86汇编","date":"2023-09-19T08:46:32.000Z","updated":"2023-09-19T08:46:32.418Z","comments":true,"path":"/2023/09/19/汇编语言/x86汇编/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/x86%E6%B1%87%E7%BC%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"goyacc","slug":"编译器/goyacc实现计算器","date":"2023-09-19T08:45:46.000Z","updated":"2023-09-26T00:41:04.856Z","comments":true,"path":"/2023/09/19/编译器/goyacc实现计算器/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E7%BC%96%E8%AF%91%E5%99%A8/goyacc%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8/","excerpt":"","text":"简单介绍下编译原理词法分析-&gt;语法分析-&gt;生成中间代码-&gt;机器无关的优化-&gt;生成汇编(机器相关的优化)-&gt;交给汇编器生成机器码编译原理我当时看完了龙书+斯坦福的编译器公开课之后,对其中细节还是一知半解,当时就暂时先放下了.最开始的递归下降,nfa,dfa直接给我劝退了。AST啥的也理解不透彻. 词法分析token解析字符串流,确定一个个的token,比如在c语言中,确定是if,while这些关键字还是变量名,运算符等.最终会生成符号表。语言中关键字：这些关键字会被保存在一种表中，在解析字符流的时候，如果碰到关键字则直接保留。 词法框架根据正则表达式来定义某种特定token的规则,在解析字符串流的时候，根据正则来判断属于哪种token 常见的词法框架&#x2F;工具lex&#x2F;flex,是通过正则表达式和自定义解析字符串综合工作的 语法分析主要在于如何表达语法规则和检验语法规则. 语法规则编译器大佬提出了一种文法，只关注字符串的变换.并定义终结符号和非终结符号的概念.非终结符号则可以继续产生新符号,从而用字符串实体表达出了语言的语法规则.非终结符号到另外一个符号串叫做产生式. 产生式比如程序一开始会有一个非终结符号S,对于C语言这个语法来说,会有下面的产生式.下面给出部分产生式做说明 1234567S -&gt; void main()&#123;B&#125;B -&gt; Y;Y -&gt; Y;STATEMENT | eSTATEMENT -&gt; D | A | BLOCKD -&gt; TYPE id | TYPE* idBLOCK -&gt; IF(C)&#123;B&#125; ELSE&#123;B&#125; | while(C)&#123;B&#125;A -&gt; id + id | id -id | id * id | id /id 解释一下上面的产生式,id和e,type这些是终结符.第1行: S是非终结符号,可以变成main函数,里面是函数体第2行: 表示函数体可以是分号组成的各种语句第3行: 表示语句之间是可以不断拼接的,从而理论上可写出无限长度的程序第4行：表示语句可以有声明语句,算术运算和语句块第5行: 表示声明语句只能是类型名空格+标志符组成第6行: 表示语句块可以有条件块和循环块第7行: 表示算数运算可以有加减乘除 语法分析的实现给定一组字符串可以是递归去判断,看最终会不会达到终结符,然后比对终结符是否和字符串中的相同.但在实际中采用的是更有效率的DFA表格,预先对产生式处理,然后可以对扫一遍字符串就可以判定是否合法,并构建出语法树 语法树TODO,这块我目前还没搞懂 语法分析框架好在大佬们已经写出来好的工具来给咱们使用了.yacc是语法分析的一种实现，根据用户定义的语法规则，做对应的动作.所有的查询引擎都有这个模块,比如mysql,prometheus.根据不同语言的yacc(c语言),javacc还有goyacc goyacc做一个简单的计算器我们来2步走，主要是这2个方法 123456789type exprLexer interface &#123; Lex(lval *exprSymType) int Error(s string)&#125;type exprParser interface &#123; Parse(exprLexer) int Lookahead() int&#125; expr函数前缀,goyacc中可以自定义. 在自己的app中可以直接调用Parser来分析。但要提供lex的实现.下面实例中就可以看到 分析词法细心的同学就会发现,这里实际上实现了上面lexer的2个接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func (x *exprLex) Lex(yylval *exprSymType) int &#123; for &#123; c, _, err := x.input.ReadRune() if err != nil &#123; return eof &#125; switch c &#123; case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;: return x.num(c, yylval) case &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;: return int(c) case &#x27;×&#x27;: return &#x27;*&#x27; case &#x27;÷&#x27;: return &#x27;/&#x27; case &#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\n&#x27;, &#x27;\\r&#x27;: default: log.Printf(&quot;unrecognized character %q&quot;, c) &#125; &#125;&#125;// Lex a number.func (x *exprLex) num(c rune, yylval *exprSymType) int &#123; var b bytes.Buffer b.WriteRune(c)L: for &#123; c, _, err := x.input.ReadRune() if err != nil &#123; return eof &#125; switch c &#123; case &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;.&#x27;, &#x27;e&#x27;, &#x27;E&#x27;: b.WriteRune(c) default: _ = x.input.UnreadRune() break L &#125; &#125; yylval.num = &amp;big.Float&#123;&#125; _, ok := yylval.num.SetString(b.String()) if !ok &#123; log.Printf(&quot;bad number %q&quot;, b.String()) return eof &#125; return NUM&#125;func (x *exprLex) Error(s string) &#123; log.Println(&quot;parse error: &quot;, s)&#125; 分析语法产生式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687%&#123;package mainimport ( &quot;fmt&quot; &quot;math/big&quot;)%&#125;%union &#123; num *big.Float&#125;%type &lt;num&gt; expr expr1 expr2 expr3 // 定义在后面的符号比定义在前面的符号具有更好的优先级%token &#x27;+&#x27; &#x27;-&#x27; &#x27;*&#x27; &#x27;/&#x27; &#x27;(&#x27; &#x27;)&#x27;%token &lt;num&gt; NUM%%top:expr&#123; if $1.IsInt() &#123; fmt.Println($1.String()) &#125; else &#123; fmt.Println($1.String()) &#125;&#125;expr:expr1&#123;&#125;|&#x27;+&#x27; expr&#123; $$ = $2&#125;|&#x27;-&#x27; expr&#123; $$ = $2.Neg($2)&#125;;expr1:expr2&#123;&#125;|expr1 &#x27;+&#x27; expr2&#123; $$ = $1.Add($1, $3)&#125;|expr1 &#x27;-&#x27; expr2&#123; $$ = $1.Sub($1, $3)&#125;;expr2:expr3&#123;&#125;|expr2 &#x27;*&#x27; expr3&#123; $$ = $1.Mul($1, $3)&#125;|expr2 &#x27;/&#x27; expr3&#123; $$ = $1.Quo($1, $3)&#125;;expr3:NUM|&#x27;(&#x27; expr &#x27;)&#x27;&#123; $$ = $2&#125;%% 应用中如何调用分析器读取命令行的输入,并调用分析器 12345678910111213141516171819func main() &#123; in := bufio.NewReader(os.Stdin) a := big.Float&#123;&#125; a.String() for &#123; if _, err := os.Stdout.WriteString(&quot;&gt; &quot;); err != nil &#123; log.Println(&quot;WriteString: &quot;, err) &#125; line, err := in.ReadBytes(&#x27;\\n&#x27;) if err == io.EOF &#123; return &#125; if err != nil &#123; log.Fatalf(&quot;ReadBytes: %s&quot;, err) &#125; //调用分析器 exprParse(newExprLex(line)) &#125;&#125; 运行安装go install golang.org&#x2F;x&#x2F;tools&#x2F;cmd&#x2F;goyacc@latest goyacc使用 Usage of goyacc: -l disable line directives -o string parser output (default “y.go”) -p string name prefix to use in generated code (default “yy”) -v string create parsing tables (default “y.output”)会根据你的语法规则(.y后缀的)生成.go文件. -o指定文件的名称 -p 指定生成parse函数前缀,默认是叫yyParse,以供外部调用goyacc -o expr.go -p expr expr.y 构建go build expr.go lexer.go main.go 执行 goyacc 做json parser最主要是整理出json的产生式,然后理解下yacc框架下的整体工作流程，就可以搞出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990%&#123;package jsonparsertype pair struct &#123; key string val interface&#123;&#125;&#125;func setResult(l yyLexer, v map[string]interface&#123;&#125;) &#123; l.(*lex).result = v&#125;%&#125;%union&#123; obj map[string]interface&#123;&#125; list []interface&#123;&#125; pair pair val interface&#123;&#125;&#125;%token LexError%token &lt;val&gt; String Number Literal%type &lt;obj&gt; object members%type &lt;pair&gt; pair%type &lt;val&gt; array%type &lt;list&gt; elements%type &lt;val&gt; value%start object%%object:&#x27;&#123;&#x27; members &#x27;&#125;&#x27;&#123; $$=$2 setResult(yylex, $$)&#125;members:&#123; $$ = map[string]interface&#123;&#125;&#123;&#125;&#125;| pair&#123; $$ = map[string]interface&#123;&#125;&#123;$1.key: $1.val&#125;&#125;| members &#x27;,&#x27; pair&#123; $1[$3.key] = $3.val $$ = $1&#125;pair:String &#x27;:&#x27; value&#123; $$ = pair&#123;key: $1.(string), val: $3&#125;&#125;array: &#x27;[&#x27; elements &#x27;]&#x27;&#123; $$ = $2&#125;elements:&#123; $$=[]interface&#123;&#125;&#123;&#125;&#125;| value&#123; $$=[]interface&#123;&#125;&#123;$1&#125;&#125;|elements &#x27;,&#x27; value&#123; $$=append($1, $3)&#125;value: String| Number| Literal| object &#123; $$ = $1 &#125;| array 测试代码见https://github.com/dingweiqings/study/tree/master/goyacc-study 引用 龙书 编译原理 yacc使用","categories":[{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"}],"tags":[{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"}]},{"title":"mysql查询源码","slug":"数据库/mysql查询源码","date":"2023-09-19T08:44:52.000Z","updated":"2023-09-19T08:44:52.157Z","comments":true,"path":"/2023/09/19/数据库/mysql查询源码/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%9F%A5%E8%AF%A2%E6%BA%90%E7%A0%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"运算符重载","slug":"C++/运算符重载","date":"2023-09-19T08:41:51.000Z","updated":"2023-09-26T02:58:06.169Z","comments":true,"path":"/2023/09/19/C++/运算符重载/","link":"","permalink":"https://dingweiqings.github.io/2023/09/19/C++/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"类之间的运算这里可以利用抽象代数的观点来看待这种处理,把运算扩充到任意的集合上,而不是只在数集上.运算可以对应于某个集合下元素之间的关系,可以在运算的世界中表达逻辑.在软件工程观点来看,让代码变得简洁 C++运算符重载：用同一个运算符完成不同的运算功能。限制基本原则 C++运算符重载的相关规定如下： 1.不能改变运算符的优先级。 2.不能改变运算符的结合性。 3.默认参数不能和重载的运算符一起使用，也就是说，在设计运算符重载成员函数时不能使用默认函数。 4.不能改变运算符的操作数的个数。 5.不能创建新的运算符，只有已有运算符可以被重载 6.运算符作用于C++内部提供的数据类型时，原来含义保持不变 7. 重载的运算符至少有一个操作数是自定义类型 C++中可被重载的运算符： 不可被重载的运算符 sizeof .: 成员运算符 .* 成员指针运算符 :: 作用域运算符 ?:: 条件运算符 typeid: 运行时信息运算符 const_cast&#x2F;dynamic_cast&#x2F;static_cast&#x2F;reinterpret_cast 类型转换运算符上面这些并不是表达元素之间的运算关系,而是取成员和类型转换,这些由类的元数据决定,当一个类确定之后,这些的运算结果就应该是确定的 只可通过成员函数重载 &#x3D; 赋值 () 函数调用 [] 下表 -&gt; 通过指针访问类成员 格式123456789函数类型 operator 重载运算符（形参表）&#123; 函数体；&#125;//非成员函数friend 函数类型 operator 重载运算符（形参表）&#123; 函数体；&#125; 原理实际上都是编译器做了特定表达式&#x2F;类型下运算符-&gt;函数的转换.最终都被编译器转换成函数 实例重载自增自减运算符123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;class MyClass2&#123; int n;public: MyClass2(int i)&#123; n = i; &#125; int operator ++()&#123; n++; return n; &#125; int operator ++(int)&#123; n += 2; return n; &#125; void display() &#123; cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl; &#125;&#125;;int main()&#123; MyClass2 A(5), B(5); A++; ++B; A.display(); B.display(); return 0;&#125; 重载双目运算符成员函数假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。若把op重载为A类的成员函数，该函数只有一个形参，形参的类型是obj2所属的类型。是把op前面的看成对象,op右边的看出函数参数 1obj1.operator op(obj2) 友元函数假设有一个类A，对于双目运算符op，如果重载运算符op使之能够实现表达式“obj1 op obj2”,其中obj1和obj2均为A类的对象。 若把op重载为A类的友元函数，该函数有两个形参，经过重载之后，表达式“obj1 op obj2”解释为： 1obj1 op(obj1,obj2) 重载赋值运算符哈哈,这里不就是我们熟悉的拷贝构造函数和赋值运算符.找到理论和实际的结合点了 重载下标运算符下标运算符“[ ]”通常用于获取数组的某个元素，重载下标运算符可以实现数组下标的越界检测等。下标运算符重载只能作为类的成员函数，不能作为类的友元函数。 重载new delete换运算符new和delete只能被重载为类的成员函数，不能重载为友元。而且，无论是否使用关键字static进行修饰，重载了的new和delete均为类的静态成员函数。 运算符new重载的一般格式如下： 12345void *类名：：operator new(size_t,参数表)；void* operator new(size_t size,int x,int y,int z)&#123;……&#125;void *类名“::operator delete(void*,参数表); 使用如下: 1x*pX=new(1,2,3) X; 重载类型转换运算符这个特性是和拷贝构造函数对应的,比如有一个类Stock可以根据传入的double来构造, 1234567class Stock&#123; public: Stock(double t)&#123; value = t; &#125; int value;&#125; 那么如果要将Stock转出double呢,就要用到下面的类型转换运算符.这两个函数是一一对应的格式: 1234operator 类型名（）&#123; 函数体；&#125; 重载函数调用运算符函数调用运算符“（）”只能说明成类的非静态成员函数，该函数具有以下的一般格式： 1函数类型 类名：：operator()(参数表) 重载移位运算符按照输入流和输出流的概念,如果能有一种运算符可以让对象直接和输入流输出流交互,就不用再写printf(“%s”)这种冗余代码了,还要记类型的format.于是我们想,把移位看出向输入流和输出流传递数据,正好有左移和右移.开口大的流向开口小的.于是会有下面的代码: 12输出流 &lt;&lt; obj输入流 &gt;&gt; obj 幸运的是,C++大佬们设计出了这样的特性. 根据友元函数运算符重载的特点,对于双目操作符是将 obj1 op opj2转换成 op(obj1,obj2);并且这样还可以支持任意一种自定义类型却不用修改std库中输入流和输出流的代码.这实际上也是友元函数重载解决的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class Person &#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);public: Person(int a, int b) &#123; this-&gt;m_A = a; this-&gt;m_B = b; &#125; //成员函数 实现不了 p &lt;&lt; cout 不是我们想要的效果 //void operator&lt;&lt;(Person&amp; p)&#123; //&#125;private: int m_A; int m_B;&#125;;//全局函数实现左移重载//ostream对象只能有一个ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123; //ostream是标准的输出流，全局只能有一个，所以用引用引用的方式 out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B; return out;&#125;void test() &#123; Person p1(10, 20); cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; //链式编程&#125;int main() &#123; test(); return 0;&#125; 运算符重载的坑意外的类型转换在编程实践中,对于类型转换和拷贝构造函数有可能发生了意外的隐式转换,导致bug,所以最好是加上explict关键字,告诉编译器不要做隐式转换 重载双目运算符不满足交换律1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;class MyClass2&#123; int n;public: MyClass2(int i)&#123; n = i; &#125; MyClass2 operator +(int a)&#123; n+=a; return n; &#125; void display() &#123; cout &lt;&lt; &quot;n=&quot; &lt;&lt; n &lt;&lt; endl; &#125; friend MyClass2 operator +(MyClass2 a, int b)&#123; a.n += b; return a; &#125;&#125;;int main()&#123; MyClass2 A(5), B(5); A = 5 + A;// 会报错 A.display(); B.display(); return 0;&#125; 例子中会无法通过编译,因为双目运算符成员函数左边必须是对象，友元重载必须参数类型要匹配(按照前面双目运算符的等价函数调用来理解)。这就导致的加法不满足交换律. 过多的转换函数导致的二义性假定Stock有形参为double的拷贝构造函数,并且重载了Stock类之间的加法 1234Stock a(1.0);double b = 2.0;Stock total;total = a + b;// 将b转成Stock，再相加 如果此时还又定义了Stock到double的转换函数,那么最后一行将不知道是将a转成double还是将b转成Stock,导致歧义 测试代码见我的github 引用 C++ Prime Plus C++重载运算符实例","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"生活","slug":"生活","date":"2023-09-15T03:20:47.000Z","updated":"2023-09-25T03:56:43.145Z","comments":true,"path":"/2023/09/15/生活/","link":"","permalink":"https://dingweiqings.github.io/2023/09/15/%E7%94%9F%E6%B4%BB/","excerpt":"","text":"生活保持一颗淡泊的心,自己会变的很轻松愉快.坚持一项运动，会一生受益.坚持早睡早起,会一生受益.","categories":[{"name":"随笔","slug":"随笔","permalink":"https://dingweiqings.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"文化理解","slug":"文化理解","permalink":"https://dingweiqings.github.io/tags/%E6%96%87%E5%8C%96%E7%90%86%E8%A7%A3/"}]},{"title":"c++11新特性","slug":"C++/C++新特性","date":"2023-01-17T11:40:56.000Z","updated":"2023-09-22T02:56:09.307Z","comments":true,"path":"/2023/01/17/C++/C++新特性/","link":"","permalink":"https://dingweiqings.github.io/2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"lambda函数 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。 123456789[]：默认不捕获任何变量；[=]：默认以值捕获所有变量；[&amp;]：默认以引用捕获所有变量；[x]：仅以值捕获x，其它变量不捕获；[&amp;x]：仅以引用捕获x，其它变量不捕获；[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；[this]：通过引用捕获当前对象（其实是复制指针）；[*this]：通过传值方式捕获当前对象； 智能指针C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。实现原理是通过类达到作用域后的构造和析构来实现的 独占指针unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括： 1、拥有它指向的对象 2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作 3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象 共享指针多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。 弱指针weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。 移动语义编译器通过参数的类型实现重载函数决断，对于右值入参，优先调用形参为右值引用的函数。形参为右值引用类型的接口实现方式一般和传统接口（例如拷贝构造、拷贝赋值）实现方式不同，简单来说前者为浅拷贝，后者为深拷贝，即前者为“窃取”后者为副本复制，形如本文开篇那张图片所示（class string） 多线程支持 原子类,thread类，条件变量类 注意 本文测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/smartpoinerhttps://github.com/dingweiqings/study/tree/master/cpp_study/src/thread 引用 移动语义 https://cloud.tencent.com/developer/article/1385969 多线程 https://immortalqx.github.io/2021/12/04/cpp-notes-3/ C++智能指针 https://www.cnblogs.com/tenosdoit/p/3456704.html lambda函数 https://www.jianshu.com/p/d686ad9de817","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"面向对象","slug":"C++/面向对象","date":"2023-01-17T11:40:28.000Z","updated":"2023-09-25T03:53:32.239Z","comments":true,"path":"/2023/01/17/C++/面向对象/","link":"","permalink":"https://dingweiqings.github.io/2023/01/17/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"面向对象的软件设计方式大型软件工程中是根据需求中的实体来建模的,对象往往代表了这些实体。具有这些实体的属性，并以提供和其他对象交互的函数。有以下的优势： 逻辑容易设计和理解 可以提高代码功能逻辑的复用 代码上高内聚低耦合，面向接口依赖 提供了运行时的动态绑定 面向对象的基本概念和模式类：类是描述一类对象的特征和提供特定功能的代码实体，同时也是实例的模板，实例以类为模板实例: 具体的一个对象，具有实例变量，是类的一个具体化。类有静态属性和动态属性之分，静态属性是所有实例共享的，动态属性是每个实例特有的，又称实例属性 举个例子，以人为例1234567891011121314151617181920usingnamespace std::string;class Person&#123; private: int age; string name; string work; public: static string motherland; private: string doWork()&#123; std::cout&gt;&gt;&quot;我在做xxxjob&quot;; &#125; public: string buy(string car)&#123; std::cout&gt;&gt;&quot;买了&quot;&gt;&gt;car; &#125; &#125;;Person::motherland = &quot;中国&quot;;Person zhangsan = Person(10,&quot;张三&quot;,&quot;学生&quot;);Person lisi = Person(25,&quot;李四&quot;,&quot;程序员&quot;); 来验证前面的理论，类是实体的建模，成员是对实体属性的抽象。两个实例zhangsan和lisi是类Person的具体化，动态属性的值各不相同。但都有一个共享的静态变量。类有特定功能的函数或者说有特定行为的函数，这些函数用来和其他对象交互. 进一步的概念经过上面的例子，就可以归纳出在代码实体上的概念： 成员变量,类的属性 方法，类的特定行为的函数 成员变量和方法的权限 普通函数，和c中函数类似，不在类的代码块内部 构造函数和析构函数 继承，对象的树级关系 虚函数，子类可以重写的方法，编译器用virtual关键字来识别 纯虚函数，用来定义接口，带有纯虚函数的不能实例化,编译器用virtual关键字+方法体&#x3D;0来定义 抽象基类,用做接口定义,包含纯虚函数的类是抽象基类，不能实例化，只能被继承，实例化成他的子类 下面介绍构造函数和析构函数默认构造函数和无参构造函数默认构造函数是创建对象时默认调用的,如果没有声明，则编译器会按照一定条件来默认创建一个无参的构造函数，当然自己也可以声明无参的。自己声明了，编译器则不会再创建。编译器创建的构造函数并不会赋初始值。编译器的创建策略主要是 有非基本类型的成员(自定义类型或者string类型),并且这些成员本身有默认构造函数。这种情况是如果只有基本类型在拷贝对象时，直接拷贝内存块即可 有虚函数和虚继承，这种情况是需要虚函数表 继承的父类有默认构造函数这里推荐一个网站，可以用来查看编译后的汇编代码。https://godbolt.org/引用1中的结论我是验证过的，在gcc13.2上。记住要加-O0(减号大o后面跟个优化等级)才可以得到结果 如果自己只定义了默认构造函数，编译器是否会生成拷贝&#x2F;赋值&#x2F;移动构造函数？如果程序中有用到对象拷贝赋值则会生成并调用默认的构造函数，没有用到则不会生成 如果只定义了拷贝构造函数，还会生成默认构造函数吗？这种不会，编译会报错 析构函数在释放对象时，编译调用的函数。如果是用来继承的类，必须声明为虚函数 父子类的构造函数和析构函数顺序构造：先基类，再子类析构：先子类，再基类对上面继承时析构函数需要声明为虚函数做些说明，因为虚函数再调用时才会根据运行时状态，调用子类对象的析构函数。编译器又会自动释放基类，从而可以完整的释放这条继承链上的所有对象。不是虚函数的话，会直接调用基类的析构函数，发生内存泄露 拷贝构造函数形如下面的code 1234567891011121314//调用拷贝构造生成对象A a ;A b = A(a);//函数返回值A doSomeWork()&#123; A work; ... return work;&#125;//函数参数void doSomeWork(A other)&#123; ...&#125; 拷贝构造是一定会生成新对象的，可能是临时的，过一会被删除。这也解释了为啥函数参数推荐使用引用或者指针，避免了重复创建临时对象。关于函数的2种情况实际上可以统一，从程序的内存布局来理解，都是在调用者和被调用者栈帧之间拷贝对象，因为栈帧内的内存会用完就被释放。 赋值运算符形如下面的code 1234A a;B b;C c;c=b=a; 赋值号左右两边都是已经存在的对象，不会产生新对象 移动构造函数这个函数还是为了减少内存拷贝带来的特性。在编程中，有些类中会包含大的成员数组，或者大的成员变量。如果在拷贝赋值时可以直接将这个大的成员直接移动给目标对象，可以减少很多拷贝开销。语义上理解很像是移动或者所有权转移。那怎么去实现他呢？需要一种标志来表示程序员啥时候可以使用移动语义，现在的引用是无法转移的。于是，那些C++大牛们提出了一个另外一种引用，当参数中以这种形式的引用出现时，编译器就会按照移动语义来实现。一般文献中会称为右值引用,就可以理解为一种引用，不过是用来标志支持移动语义的。左值和右值可以相互转换 1234A (A&amp;&amp; other)&#123; array = other.array; //移动 other.array = nullptr;&#125; 移动运算符和上面类似的，运算符两边都是已经存在的对象，并且是移动语义 注意 拷贝构造&#x2F;拷贝赋值与移动构造和移动赋值如果自己提供了其中一个，则编译不会提供另一个。因为只要有一种就都可以编译通过。可通过&#x3D;default来声明 前面的测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/construct 汇编验证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;using namespace std;class Person&#123;public: Person()&#123;&#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl; &#125; Person&amp; operator=(const Person&amp; p) &#123; cout &lt;&lt; &quot;Assign&quot; &lt;&lt; endl; return *this; &#125;private: int age; string name;&#125;;void f(Person p)&#123; return;&#125;Person f1()&#123; Person p; return p;&#125;int main()&#123; Person p; Person p1 = p; // 1 Person p2; p2 = p; // 2 f(p2); // 3 p2 = f1(); // 4 Person p3 = f1(); // 5 getchar(); return 0;&#125; 将上面代码拷贝到https://godbolt.org/ C++的对象模型面向对象的语言都需要解决下面几个问题: 对象的成员数据存储和访问 对象的成员函数存储和访问 对象的静态成员和方法的存储的访问 在有继承的情况下，前面1，2，3怎么处理 对于多态的运行时绑定策略 对象的创建和释放 几种可能的实现 简单对象模型暴力一点，对每个实例，都把成员数据和成员函数都都拷贝一份，这样不就都可以访问到了吗？静态成员还是要单独存储。继承把父类的成员数据和函数都拷贝一份，因为每个实例有自己独立的拷贝，所以多态是自然支持的 基于表格的模型第一种的内存消耗太大，虽然访问都是固定时间.于是，我们产生了第二种想法，可以将成员函数和成员数据分开来存储。把成员函数放入一个表格之中，这样成员函数就可以被所有实例共享。成员数据还是随每个实例存储，每个成员额外增加一个指向成员函数表格的指针。想法是根据成员函数有共享性，成员数据是独立性。这里先记住2个名字，函数表指针和函数表 C++的成员变量存储和访问静态变量和静态函数静态变量是转变成global变量，但会由编译器控制可见性。就类似于普通定义的全局变量.所以访问也是和普通变量类似,通过地址直接访问 无继承的情况类似于c结构体的存储,按照声明变量的顺序和大小，从低地址到高地址存储。当然中间可能会由于体系结构要求的对齐。这里C++并未规定，变量必须连续存储，只要按照变量声明的顺序即可。也就是说，可以在成员变量缝隙间插入特定的内容.详细可见《深入探索对象模型》的第3章3.2节 123456class A&#123; public: int a; int b; virtual void function();&#125; 先忽略虚函数表的内容，后面会再介绍 单一继承的情况子类会将父类实例成员拷贝一份.类似于包馅饼。因为这样才可以完整的实现多态，否则向上转型取字段就不对了。 多重继承(继承树上无重复)就包多次馅饼,从小到大包.所以此时,如果有重名变量和方法，需要明确指定基类.比如:两个基类中有重名的方法和变量,SetWeight,则需要用完全限定名称 123SleepSofa a;a.Bed::SetWeight(1);a.Sofa::SetWeight(2); 多重继承(继承树上有重复)这种情况，如果还是包馅饼,对于继承树上重复出现会被多个子节点包进去,造成内存的浪费，也会导致访问和修改的歧义。C++大佬们又想了个办法，(后面你会发现和虚函数的处理策略是类似的).增加了共享继承的机制，用现有的关键字virtual，语义同虚函数相同。在类对象中增加一个虚基类指针，用以指向虚基类在实例中的偏移量。虚基类指针在内存中放在哪里呢？有2种放置策略 将所有虚继承的父类都搞一个指针放在实例中,指向基类在实例中的内存位置，以用来访问成员。这种每个实例都有额外的指针存储，在基类很多的情况下，开销较大 多个虚继承的父类就搞一个虚继承表(和虚函数表很像),指代基类在实例中的偏移量。由于类的布局是固定的，所以只需要准备一份这个表即可。(根据候捷大佬《深入探索C++模型》原文中说微软编译器是这样做的) 和虚函数表放在一起，gcc和clang是这样做的，下面会详细分析gcc的虚函数表 C++的成员函数存储和调用静态函数静态函数就是只能访问静态变量的函数，除此之外函数的存储和调用和其他成员函数无区别，静态函数不能是虚函数，编译期就可以得到地址. 继承树中所有类都无虚函数这种和普通非成员函数调用无区别，编译期就可以确定 虚函数无继承编译器会创建一个虚函数表,在实例中增加一个隐藏成员,这个成员指向虚函数表的位置 123456789101112131415161718class Base &#123; Base() = default; virtual ~Base() = default; void FuncA() &#123;&#125; virtual void FuncB() &#123; printf(&quot;FuncB\\n&quot;); &#125; int a; int b;&#125;;int main() &#123; Base a; return 0;&#125; 注意 详细介绍一下虚函数表中的概念， 整个虚函数表,是一个数组,每一项8字节（64位架构下）固定长度,所以可以按照偏移量来索引 function pointer 存储虚函数的区域,每一项都是一个内存地址,指向函数的入口,按照源码顺序来排列 virtual base offset 虚函数表中有些项存储的是虚基类的偏移量 offset to top 这种项记录的是和当前实际类型的开头的偏移量下面给出一个简单vtable例子,有个简单的印象12345Vtable for AA::vtable for A: 3 entries0 (int (*)(...))08 (int (*)(...))(&amp; typeinfo for A)16 (int (*)(...))A::af 单继承的情况(这种很重要,平常用的最多,而且是理解后续模型的基础)12345678910111213141516171819202122class Base &#123; Base() = default; virtual ~Base() = default; void FuncA() &#123;&#125; virtual void FuncB() &#123; printf(&quot;Base FuncB\\n&quot;); &#125; int a; int b;&#125;;class Derive : public Base&#123;&#125;;int main() &#123; Base a; Derive d; return 0;&#125; 注意 这里可以发现,如果子类有覆盖父类的方法,虚函数表中就填子类的,如果没有就把父类的拷贝过来.每个类都有自己的虚函数表,并不是通过共享虚函数表来实现继承的. 多重继承这种是每个继承树上的每一个类在实例内存中指向自己类的function pointer,这样在调用基类虚函数时，会查找到实际类型的函数地址,从而实现多态下面会详细介绍如果根据虚函数表查找实际类型的函数地址 虚继承在继承树上有重复类的时候,根据前面对象数据成员内存布局,需要添加一个基类的偏移量来表示每个基类在实例中的内存位置.gcc是把基类指针放在虚函数表中,下面会详细介绍虚函数表 虚函数表这些内容比较复杂,另起一篇文章gcc的虚函数表https://github.com/bingseclab/VirtAnalyzer/blob/master/README.md gcc查看虚函数表内容见gcc的虚函数表https://github.com/bingseclab/VirtAnalyzer/blob/master/README.md gdb打印对象内存布局gdb命令 每行打印一个结构体成员可以执行set print pretty on命令，这样每行只会显示结构体的一名成员，而且还会根据成员的定义层次进行缩进 按照派生类打印对象set print object on 查看虚函数表通过如下设置：set print vtbl on 之后执行如下命令查看虚函数表：info vtbl 对象或者info vtbl 指针或引用所指向或绑定的对象 c++名称转换GNU提供的从name mangling后的名字来找原函数的方法，c++filt工具,执行c++filt _ZTV1A在线反修饰名称的网站http://demangler.com/ 汇编查看实例函数调用汇编中会额外增加一个this指针,一般是放在rdi寄存器中 补充MSVC ABI和Itanium ABI(gcc和clang遵循这个标准)C++ Itanium ABI 主要分为四大板块： 指导程序中的各种数据结构如何正确而一致地在内存中布局（Data Layout）；指导在二进制层面如何调用其他函数（调用约定，Calling Convention）；为 C++ 的异常处理机制提供正确的实现（Exception Handling）；定义输入到链接器的对象文件的格式（Linkage &amp; Object Files） 引用 gcc生成默认构造器的策略 gcc生成拷贝构造和默认构造的策略 深入探索C++对象模型-候捷 图解对象内存模型 gcc deveploper option 打印对象vtable内存布局 gdb 打印内存布局 Itanuim ABI","categories":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"}]},{"title":"LSM树","slug":"数据结构/LSM树","date":"2022-11-22T02:14:57.000Z","updated":"2023-09-16T00:31:39.307Z","comments":true,"path":"/2022/11/22/数据结构/LSM树/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LSM%E6%A0%91/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"LSM","slug":"LSM","permalink":"https://dingweiqings.github.io/tags/LSM/"}]},{"title":"线性同余","slug":"算法/线性同余","date":"2022-11-22T02:12:32.000Z","updated":"2023-09-14T00:11:08.223Z","comments":true,"path":"/2022/11/22/算法/线性同余/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"素数","slug":"算法/素数","date":"2022-11-22T02:12:14.000Z","updated":"2023-09-14T00:11:08.223Z","comments":true,"path":"/2022/11/22/算法/素数/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/%E7%AE%97%E6%B3%95/%E7%B4%A0%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"线程池","slug":"java/线程池","date":"2022-11-22T01:49:13.000Z","updated":"2023-09-15T03:12:14.631Z","comments":true,"path":"/2022/11/22/java/线程池/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"https://dingweiqings.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"java 线程池","slug":"java-线程池","permalink":"https://dingweiqings.github.io/tags/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"jvm-gc","slug":"java/jvm-gc","date":"2022-11-22T01:41:49.000Z","updated":"2023-09-16T00:30:16.762Z","comments":true,"path":"/2022/11/22/java/jvm-gc/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/jvm-gc/","excerpt":"","text":"","categories":[{"name":"jvm","slug":"jvm","permalink":"https://dingweiqings.github.io/categories/jvm/"}],"tags":[{"name":"jvm gc","slug":"jvm-gc","permalink":"https://dingweiqings.github.io/tags/jvm-gc/"}]},{"title":"TreeMap","slug":"java/TreeMap","date":"2022-11-22T01:41:23.000Z","updated":"2023-09-16T00:31:13.795Z","comments":true,"path":"/2022/11/22/java/TreeMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/TreeMap/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"红黑树 平衡搜索树","slug":"红黑树-平衡搜索树","permalink":"https://dingweiqings.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"TransferQueue","slug":"java/TransferQueue","date":"2022-11-22T01:41:08.000Z","updated":"2023-09-16T00:30:45.643Z","comments":true,"path":"/2022/11/22/java/TransferQueue/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/TransferQueue/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"非阻塞队列 java queue","slug":"非阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"}]},{"title":"ConcurrentHashMap","slug":"java/ConcurrentHashMap","date":"2022-11-22T01:40:46.000Z","updated":"2023-09-14T00:11:08.223Z","comments":true,"path":"/2022/11/22/java/ConcurrentHashMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/ConcurrentHashMap/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"HashMap","slug":"java/HashMap","date":"2022-11-22T01:40:38.000Z","updated":"2023-09-16T00:29:31.474Z","comments":true,"path":"/2022/11/22/java/HashMap/","link":"","permalink":"https://dingweiqings.github.io/2022/11/22/java/HashMap/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"hashmap 哈希表","slug":"hashmap-哈希表","permalink":"https://dingweiqings.github.io/tags/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"算法/crc学习","slug":"算法/crc学习","date":"2022-11-21T03:26:27.000Z","updated":"2023-09-14T00:11:08.223Z","comments":true,"path":"/2022/11/21/算法/crc学习/","link":"","permalink":"https://dingweiqings.github.io/2022/11/21/%E7%AE%97%E6%B3%95/crc%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"奇偶校验磁盘冗余阵列数学原理多项式代数和多项式除法高等代数中的多项式代数知识 12M/N=Q...R 这里容易得到，R会比N幂次要低，就和整数除法m&#x2F;n&#x3D;q..r ，0&lt;&#x3D;r&lt;n 一样 除法规则-竖式除法每次消去余数最高项，直到余数最高次项小于除数!除法 大牛在1961年发布的论文 https://en.wikipedia.org/wiki/W._Wesley_Peterson 算法 朴素的竖式多项式除法的翻译这里主要思路是用商消去最高位，然后在输入的数组上减去商*生成多项式，因此余数也是保存在输入的被除多项式位置 1234567891011121314151617181920212223242526272829303132int divide( double num[], int nlen, double den[], int dlen, double quotient[], int *qlen )&#123; int n, d, q; // The lengths are one more than the last index; decrement them // here so the call is less confusing nlen--; dlen--; q = 0; // when n &gt; dlen, the result is no longer a polynomial // (e.g. trying to divide x by x^2 for ( n = nlen; n &gt;= dlen; n-- ) &#123; // First, divide the nth element of numerator with the last element // of the denominator quotient[ n - dlen ] = num[ n ] / den[ dlen ]; q++; // Now, multiply each element of the denominator by each // corresponding element of the numerator and subtract the // result for ( d = dlen; d &gt;= 0; d-- ) &#123; num[ n - ( dlen - d ) ] -= den[ d ] * quotient[ n - dlen ]; //采用模2除法，需要修改成这行代码 num[ n - ( denlen - d ) ] = fabs( num[ n - ( denlen - d ) ] ); &#125; &#125; *qlen = q; return ( nlen - *qlen + 1 );&#125; 使用异或来计算这里比较难理解，让我想了很久，还是基于竖式除法的思路，从竖式除法我们可以发现，32位的生成多项式最高位可以不存储，因为每次都是消去最高项；可以用一个32位int来保存余数，长度小于32位的二进制序列余数就是它自己，因此需要在右端补上32位；从竖式除法中我们可以发现，做减法的次数等于被除数长度-除数长度+1； 123456789101112131415161718192021222324unsigned long int compute_crc( unsigned long input, int len, unsigned long divisor )&#123; //要做被除数长度-除数长度+1=24+32-33+1=24 while ( len-- ) &#123; //如果最高位是1，那么这位是要被消去，余数等于剩下的和除数异或；如果最高位是0，我们发现最高位死0，实际上是 //商为0，和全0异或等于它自己，等效于直接左移 input = ( input &amp; 0x80000000 ) ? divisor ^ ( input &lt;&lt; 1 ) : ( input &lt;&lt; 1 ); &#125; //余数存储在32位，这里实际上等价于竖式多项式的低32位；因为运算过程中，余数始终保存在input位置 return input;&#125;... unsigned long int crc32_divisor = 0x04C11DB7; //下面的input按ABC实际上的值字节做了反转，多项式是低字节在低位，为了位对齐 // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, // C // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, // B // 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 // A unsigned long int input = 0x8242C200; // ABC; backwards &amp; left aligned printf( &quot;%lx\\n&quot;, compute_crc( input, 24, crc32_divisor ); // 5A5B433A 常见组件关于crc的实现 mariadb中用的是查表，或者使用cpu的sse来计算 zlib 引用 这是大牛的ppt讲解，https://pdfs.semanticscholar.org/44c1/4780d58015f8411fb85efa58a4aa3747a6ad.pdf 论文原版https://apt.cs.manchester.ac.uk/ftp/pub/apt/papers/Peterson-Brown_61.pdf https://www.shuxuele.com/algebra/polynomials-division-long.html 模2除法https://blog.csdn.net/weixin_39450145/article/details/83987836 gcc中crc32的实现 mysql中crc32的实现 crc32 校验和 https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art008 常用的除数多项式 github doc https://github.com/komrad36/CRC","categories":[],"tags":[]}],"categories":[{"name":"编译器","slug":"编译器","permalink":"https://dingweiqings.github.io/categories/%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/categories/C/"},{"name":"随笔","slug":"随笔","permalink":"https://dingweiqings.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"数据结构","slug":"数据结构","permalink":"https://dingweiqings.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"技术","slug":"技术","permalink":"https://dingweiqings.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"jvm","slug":"jvm","permalink":"https://dingweiqings.github.io/categories/jvm/"}],"tags":[{"name":"yacc","slug":"yacc","permalink":"https://dingweiqings.github.io/tags/yacc/"},{"name":"C++ 虚函数 编译器","slug":"C-虚函数-编译器","permalink":"https://dingweiqings.github.io/tags/C-%E8%99%9A%E5%87%BD%E6%95%B0-%E7%BC%96%E8%AF%91%E5%99%A8/"},{"name":"std库 模板","slug":"std库-模板","permalink":"https://dingweiqings.github.io/tags/std%E5%BA%93-%E6%A8%A1%E6%9D%BF/"},{"name":"C++","slug":"C","permalink":"https://dingweiqings.github.io/tags/C/"},{"name":"文化理解","slug":"文化理解","permalink":"https://dingweiqings.github.io/tags/%E6%96%87%E5%8C%96%E7%90%86%E8%A7%A3/"},{"name":"LSM","slug":"LSM","permalink":"https://dingweiqings.github.io/tags/LSM/"},{"name":"java 线程池","slug":"java-线程池","permalink":"https://dingweiqings.github.io/tags/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"jvm gc","slug":"jvm-gc","permalink":"https://dingweiqings.github.io/tags/jvm-gc/"},{"name":"红黑树 平衡搜索树","slug":"红黑树-平衡搜索树","permalink":"https://dingweiqings.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"非阻塞队列 java queue","slug":"非阻塞队列-java-queue","permalink":"https://dingweiqings.github.io/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97-java-queue/"},{"name":"hashmap 哈希表","slug":"hashmap-哈希表","permalink":"https://dingweiqings.github.io/tags/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8/"}]}
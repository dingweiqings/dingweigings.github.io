<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dingweiqings.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"up","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="猫猫攻城狮的博客">
<meta property="og:url" content="https://dingweiqings.github.io/page/4/index.html">
<meta property="og:site_name" content="猫猫攻城狮的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="KurtDing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dingweiqings.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>猫猫攻城狮的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">猫猫攻城狮的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/dingweiqings" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dingweiqings.github.io/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LSM%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KurtDing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫猫攻城狮的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/LSM%E6%A0%91/" class="post-title-link" itemprop="url">LSM树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-22 10:14:57" itemprop="dateCreated datePublished" datetime="2022-11-22T10:14:57+08:00">2022-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-16 08:31:39" itemprop="dateModified" datetime="2023-09-16T08:31:39+08:00">2023-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dingweiqings.github.io/2023/01/17/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KurtDing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫猫攻城狮的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/17/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">面向对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-17 19:40:28" itemprop="dateCreated datePublished" datetime="2023-01-17T19:40:28+08:00">2023-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-05 11:36:47" itemprop="dateModified" datetime="2023-10-05T11:36:47+08:00">2023-10-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="面向对象的软件设计方式">面向对象的软件设计方式</h1>
<p>大型软件工程中是根据需求中的实体来建模的,对象往往代表了这些实体。具有这些实体的属性，并以提供和其他对象交互的函数。有以下的优势： 1. 逻辑容易设计和理解 2. 可以提高代码功能逻辑的复用 3. 代码上高内聚低耦合，面向接口依赖 4. 提供了运行时的动态绑定 # 面向对象的基本概念和模式 类：类是描述一类对象的特征和提供特定功能的代码实体，同时也是实例的模板，实例以类为模板 实例: 具体的一个对象，具有实例变量，是类的一个具体化。 类有静态属性和动态属性之分，静态属性是所有实例共享的，动态属性是每个实例特有的，又称实例属性 ## 举个例子，以人为例 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usingnamespace std::string;</span><br><span class="line">class Person&#123;</span><br><span class="line">    private:</span><br><span class="line">      int age;</span><br><span class="line">      string name;</span><br><span class="line">      string work;</span><br><span class="line">    public:  </span><br><span class="line">      static string motherland;</span><br><span class="line">    private:</span><br><span class="line">      string doWork()&#123;</span><br><span class="line">        std::cout&gt;&gt;&quot;我在做xxxjob&quot;;</span><br><span class="line">      &#125;  </span><br><span class="line">    public:</span><br><span class="line">      string buy(string car)&#123;</span><br><span class="line">        std::cout&gt;&gt;&quot;买了&quot;&gt;&gt;car;</span><br><span class="line">      &#125;  </span><br><span class="line">&#125;;</span><br><span class="line">Person::motherland = &quot;中国&quot;;</span><br><span class="line">Person zhangsan = Person(10,&quot;张三&quot;,&quot;学生&quot;);</span><br><span class="line">Person lisi = Person(25,&quot;李四&quot;,&quot;程序员&quot;);</span><br></pre></td></tr></table></figure> 来验证前面的理论，类是实体的建模，成员是对实体属性的抽象。两个实例zhangsan和lisi是类Person的具体化，动态属性的值各不相同。但都有一个共享的静态变量。类有特定功能的函数或者说有特定行为的函数，这些函数用来和其他对象交互. ## 进一步的概念 经过上面的例子，就可以归纳出在代码实体上的概念： - 成员变量,类的属性 - 方法，类的特定行为的函数 - 成员变量和方法的权限 - 普通函数，和c中函数类似，不在类的代码块内部 - 构造函数和析构函数 - 继承，对象的树级关系 - 虚函数，子类可以重写的方法，编译器用virtual关键字来识别 - 纯虚函数，用来定义接口，带有纯虚函数的不能实例化,编译器用virtual关键字+方法体=0来定义 - 抽象基类,用做接口定义,包含纯虚函数的类是抽象基类，不能实例化，只能被继承，实例化成他的子类 ## 类型兼容原则 所指的替代包括以下情况： 1. 子类对象可以当作父类对象使用 2. 子类对象可以直接赋值给父类对象 3. 子类对象可以直接初始化父类对象 4. 父类指针可以直接指向子类对象 5. 父类引用可以直接引用子类对象 ### 下面介绍构造函数和析构函数 #### 默认构造函数和无参构造函数 默认构造函数是创建对象时默认调用的,如果没有声明，则编译器会按照一定条件来默认创建一个无参的构造函数，当然自己也可以声明无参的。自己声明了，编译器则不会再创建。<strong>编译器创建的构造函数并不会赋初始值</strong>。编译器的创建策略主要是 1. 有非基本类型的成员(自定义类型或者string类型),并且这些成员本身有默认构造函数。这种情况是如果只有基本类型在拷贝对象时，直接拷贝内存块即可 2. 有虚函数和虚继承，这种情况是需要虚函数表 3. 继承的父类有默认构造函数 这里推荐一个网站，可以用来查看编译后的汇编代码。https://godbolt.org/ 引用1中的结论我是验证过的，在gcc13.2上。记住要加-O0(减号大o后面跟个优化等级)才可以得到结果</p>
<ul>
<li>如果自己只定义了默认构造函数，编译器是否会生成拷贝/赋值/移动构造函数？ 如果程序中有用到对象拷贝赋值则会生成并调用默认的构造函数，没有用到则不会生成</li>
<li>如果只定义了拷贝构造函数，还会生成默认构造函数吗？ 这种不会，编译会报错 #### 析构函数 在释放对象时，编译调用的函数。如果是用来继承的类，必须声明为虚函数 #### 父子类的构造函数和析构函数顺序 构造：先基类，再子类 析构：先子类，再基类 对上面继承时析构函数需要声明为虚函数做些说明，因为虚函数再调用时才会根据运行时状态，调用子类对象的析构函数。编译器又会自动释放基类，从而可以完整的释放这条继承链上的所有对象。不是虚函数的话，会直接调用基类的析构函数，发生<strong>内存泄露</strong> #### 拷贝构造函数 形如下面的code <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//调用拷贝构造生成对象</span><br><span class="line">A a ;</span><br><span class="line">A b = A(a);</span><br><span class="line">//函数返回值</span><br><span class="line">A doSomeWork()&#123;</span><br><span class="line">  A work;</span><br><span class="line">  ...</span><br><span class="line">  return work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数参数</span><br><span class="line">void doSomeWork(A other)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 拷贝构造是一定会生成新对象的，可能是临时的，过一会被删除。这也解释了为啥函数参数推荐使用引用或者指针，避免了重复创建临时对象。 关于函数的2种情况实际上可以统一，从程序的内存布局来理解，都是在调用者和被调用者栈帧之间拷贝对象，因为栈帧内的内存会用完就被释放。</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<p>形如下面的code <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line">c=b=a;</span><br></pre></td></tr></table></figure> 赋值号左右两边都是已经存在的对象，不会产生新对象</p>
<h4 id="移动构造函数">移动构造函数</h4>
<p>这个函数还是为了减少内存拷贝带来的特性。在编程中，有些类中会包含大的成员数组，或者大的成员变量。如果在拷贝赋值时可以直接将这个大的成员 直接移动给目标对象，可以减少很多拷贝开销。语义上理解很像是移动或者所有权转移。那怎么去实现他呢？需要一种标志来表示程序员啥时候可以使用移动语义，现在的引用是无法转移的。于是，那些C++大牛们提出了一个另外一种引用，当参数中以这种形式的引用出现时，编译器就会按照移动语义来实现。 一般文献中会称为右值引用,就可以理解为一种引用，不过是用来标志支持移动语义的。左值和右值可以相互转换 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A (A&amp;&amp; other)&#123;</span><br><span class="line">  array  = other.array; //移动</span><br><span class="line">  other.array = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="移动运算符">移动运算符</h4>
<p>和上面类似的，运算符两边都是已经存在的对象，并且是移动语义</p>
<p><strong>注意</strong> 拷贝构造/拷贝赋值与移动构造和移动赋值如果自己提供了其中一个，则编译不会提供另一个。因为只要有一种就都可以编译通过。可通过=default来声明</p>
<p>前面的测试代码见https://github.com/dingweiqings/study/tree/master/cpp_study/src/construct ### 汇编验证 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person()&#123;&#125;</span><br><span class="line">	Person(const Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Person&amp; operator=(const Person&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;Assign&quot; &lt;&lt; endl;</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	int age;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void f(Person p)</span><br><span class="line">&#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person f1()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	Person p1 = p;    // 1</span><br><span class="line">	Person p2;</span><br><span class="line">	p2 = p;           // 2</span><br><span class="line">	f(p2);            // 3</span><br><span class="line"></span><br><span class="line">	p2 = f1();        // 4</span><br><span class="line"></span><br><span class="line">	Person p3 = f1(); // 5</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 将上面代码拷贝到https://godbolt.org/ <img src="/img/copy-construct.png" alt="结果" /> # C++的对象模型 面向对象的语言都需要解决下面几个问题: 1. 对象的成员数据存储和访问 2. 对象的成员函数存储和访问 3. 对象的静态成员和方法的存储的访问 4. 在有继承的情况下，前面1，2，3怎么处理 5. 对于多态的运行时绑定策略 6. 对象的创建和释放 ## 几种可能的实现 - 简单对象模型 暴力一点，对每个实例，都把成员数据和成员函数都都拷贝一份，这样不就都可以访问到了吗？静态成员还是要单独存储。 继承把父类的成员数据和函数都拷贝一份，因为每个实例有自己独立的拷贝，所以多态是自然支持的 - 基于表格的模型 第一种的内存消耗太大，虽然访问都是固定时间.于是，我们产生了第二种想法，可以将成员函数和成员数据分开来存储。把成员函数放入一个表格之中，这样成员函数就可以被所有实例共享。成员数据还是随每个实例存储，每个成员额外增加一个指向成员函数表格的指针。想法是根据成员函数有共享性，成员数据是独立性。这里先记住2个名字，函数表指针和函数表 ## C++的成员变量存储和访问 ### 静态变量和静态函数 静态变量是转变成global变量，但会由编译器控制可见性。就类似于普通定义的全局变量.所以访问也是和普通变量类似,通过地址直接访问</p>
<h3 id="无继承的情况">无继承的情况</h3>
<p>类似于c结构体的存储,按照声明变量的顺序和大小，从低地址到高地址存储。当然中间可能会由于体系结构要求的对齐。这里C++并未规定，变量必须连续存储，只要按照变量声明的顺序即可。也就是说，可以在成员变量缝隙间插入特定的内容.详细可见《深入探索对象模型》的第3章3.2节 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  public:</span><br><span class="line">  int a;</span><br><span class="line">  int b;</span><br><span class="line">  virtual void function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 先忽略虚函数表的内容，后面会再介绍 <img src="/img/object-data.png" alt="单一对象" /></p>
<h3 id="单一继承的情况">单一继承的情况</h3>
<p>子类会将父类实例成员拷贝一份.类似于包馅饼。因为这样才可以完整的实现多态，否则向上转型取字段就不对了。 <img src="/img/object-single.png" alt="单一继承" /></p>
<h3 id="多重继承继承树上无重复">多重继承(继承树上无重复)</h3>
<p>就包多次馅饼,从小到大包. 所以此时,如果有重名变量和方法，需要明确指定基类.比如: 两个基类中有重名的方法和变量,SetWeight,则需要用完全限定名称 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SleepSofa a;</span><br><span class="line">a.Bed::SetWeight(1);</span><br><span class="line">a.Sofa::SetWeight(2);</span><br></pre></td></tr></table></figure> <img src="/img/object-multi.png" alt="多重继承" /></p>
<h3 id="多重继承继承树上有重复">多重继承(继承树上有重复)</h3>
<p>这种情况，如果还是包馅饼,对于继承树上重复出现会被多个子节点包进去,造成内存的浪费，也会导致访问和修改的歧义。C++大佬们又想了个办法，(后面你会发现和虚函数的处理策略是类似的).增加了共享继承的机制，用现有的关键字virtual，语义同虚函数相同。在类对象中增加一个虚基类指针，用以指向虚基类在实例中的偏移量。 虚基类指针在内存中放在哪里呢？有2种放置策略 1. 将所有虚继承的父类都搞一个指针放在实例中,指向基类在实例中的内存位置，以用来访问成员。这种每个实例都有额外的指针存储，在基类很多的情况下，开销较大 2. 多个虚继承的父类就搞一个虚继承表(和虚函数表很像),指代基类在实例中的偏移量。由于类的布局是固定的，所以只需要准备一份这个表即可。(根据候捷大佬《深入探索C++模型》原文中说微软编译器是这样做的) 3. 和虚函数表放在一起，gcc和clang是这样做的，下面会详细分析gcc的虚函数表</p>
<figure>
<img src="/img/object-multi-offset.png" alt="共享继承" /><figcaption>共享继承</figcaption>
</figure>
<h2 id="c的成员函数存储和调用">C++的成员函数存储和调用</h2>
<h3 id="静态函数">静态函数</h3>
<p>静态函数就是只能访问静态变量的函数，除此之外函数的存储和调用和其他成员函数无区别，静态函数不能是虚函数，编译期就可以得到地址. ### 继承树中所有类都无虚函数 这种和普通非成员函数调用无区别，编译期就可以确定</p>
<h3 id="虚函数">虚函数</h3>
<h4 id="无继承">无继承</h4>
<p>编译器会创建一个虚函数表,在实例中增加一个隐藏成员,这个成员指向虚函数表的位置 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">   Base() = default;</span><br><span class="line">   virtual ~Base() = default;</span><br><span class="line">   </span><br><span class="line">   void FuncA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   virtual void FuncB() &#123;</span><br><span class="line">       printf(&quot;FuncB\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   int a;</span><br><span class="line">   int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   Base a;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="/img/function-single.png" alt="无继承" /> <strong>注意</strong> 详细介绍一下虚函数表中的概念， 1. 整个虚函数表,是一个数组,每一项8字节（64位架构下）固定长度,所以可以按照偏移量来索引 1. function pointer 存储虚函数的区域,每一项都是一个内存地址,指向函数的入口,按照源码顺序来排列 2. virtual base offset 虚函数表中有些项存储的是虚基类的偏移量 3. offset to top 这种项记录的是和当前实际类型的开头的偏移量 下面给出一个简单vtable例子,有个简单的印象 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vtable for A</span><br><span class="line">A::vtable for A: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; typeinfo for A)</span><br><span class="line">16    (int (*)(...))A::af</span><br></pre></td></tr></table></figure></p>
<h4 id="单继承的情况这种很重要平常用的最多而且是理解后续模型的基础">单继承的情况(这种很重要,平常用的最多,而且是理解后续模型的基础)</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">   Base() = default;</span><br><span class="line">   virtual ~Base() = default;</span><br><span class="line">   </span><br><span class="line">   void FuncA() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   virtual void FuncB() &#123;</span><br><span class="line">       printf(&quot;Base FuncB\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   int a;</span><br><span class="line">   int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derive : public Base&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   Base a;</span><br><span class="line">   Derive d;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/function-single-no.png" alt="无覆盖" /> <img src="/img/function-single-override.png" alt="有覆盖" /></p>
<p><strong>注意</strong> 这里可以发现,父类的vptr指针指向的也是子类的vtable.如果子类有覆盖父类的方法,虚函数表中就填子类的,如果没有就把父类的拷贝过来.每个类都有自己的虚函数表,并不是通过共享虚函数表来实现继承的.</p>
<h4 id="多重继承">多重继承</h4>
<p>这种是每个继承树上的每一个类在实例内存中指向自己类的function pointer,这样在调用基类虚函数时，会查找到实际类型的函数地址,从而实现多态 下面会详细介绍如果根据虚函数表查找实际类型的函数地址 <strong>注意</strong> 这里有个主基类的说法，编译器会在继承的父类中找一个有虚方法的父类，复用他的vptr,在调用主基类的方法时不需要调整this指针。下面虚函数表的会详细解释 <img src="/img/object-multi-function.png" alt="多重继承" /></p>
<h4 id="虚继承">虚继承</h4>
<p>在继承树上有重复类的时候,根据前面对象数据成员内存布局,需要添加一个基类的偏移量来表示每个基类在实例中的内存位置.gcc是把基类指针放在虚函数表中,下面会详细介绍虚函数表</p>
<figure>
<img src="/img/object-multi-offset.png" alt="虚继承" /><figcaption>虚继承</figcaption>
</figure>
<figure>
<img src="/img/object-multi-offset-2.png" alt="虚继承" /><figcaption>虚继承</figcaption>
</figure>
<h1 id="虚函数表">虚函数表</h1>
<p>这些内容比较复杂,另起一篇文章 <a href="/2023/09/25/C++/gcc的虚函数表">gcc的虚函数表</a></p>
<h1 id="gcc查看虚函数表">gcc查看虚函数表</h1>
<p><a href="/2023/09/25/C++/gcc的虚函数表">gcc的虚函数表</a></p>
<h1 id="gdb打印对象内存布局">gdb打印对象内存布局</h1>
<h2 id="gdb命令">gdb命令</h2>
<ol type="1">
<li><p>每行打印一个结构体成员 可以执行set print pretty on命令，这样每行只会显示结构体的一名成员，而且还会根据成员的定义层次进行缩进</p></li>
<li><p>按照派生类打印对象 set print object on</p></li>
<li><p>查看虚函数表 通过如下设置：set print vtbl on</p></li>
</ol>
<p>之后执行如下命令查看虚函数表：info vtbl 对象或者info vtbl 指针或引用所指向或绑定的对象</p>
<ol start="4" type="1">
<li>c++名称转换 GNU提供的从name mangling后的名字来找原函数的方法，c++filt工具,执行c++filt _ZTV1A 在线反修饰名称的网站http://demangler.com/</li>
</ol>
<figure>
<img src="/img/object-in-memory.png" alt="对象布局" /><figcaption>对象布局</figcaption>
</figure>
<figure>
<img src="/img/object-vtbl.png" alt="对象布局" /><figcaption>对象布局</figcaption>
</figure>
<h1 id="汇编查看实例函数调用">汇编查看实例函数调用</h1>
<p>汇编中会额外增加一个this指针,一般是放在rdi寄存器中</p>
<h1 id="总结">总结</h1>
<p>基本要解决的问题是下面几个？ 1. 如何保证子类可以继承父类的成员和非虚方法？这两种是编译期就可以决定访问地址的,主要思想是包馅饼，vtable和成员都是类似的思想 2. 如何保证子类调用自己重载的虚方法？每个基类都有一个指针，指向子类的vtable,并在调用非主要基类的子类方法时调整this指针</p>
<h1 id="补充">补充</h1>
<p>MSVC ABI和Itanium ABI(gcc和clang遵循这个标准) C++ Itanium ABI 主要分为四大板块：</p>
<p>指导程序中的各种数据结构如何正确而一致地在内存中布局（Data Layout）； 指导在二进制层面如何调用其他函数（调用约定，Calling Convention）； 为 C++ 的异常处理机制提供正确的实现（Exception Handling）； 定义输入到链接器的对象文件的格式（Linkage &amp; Object Files）</p>
<h1 id="引用">引用</h1>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiuguolu1108/article/details/114797246">gcc生成默认构造器的策略</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/shltsh/article/details/45959271">gcc生成拷贝构造和默认构造的策略</a></li>
<li>深入探索C++对象模型-候捷</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qg-whz/p/4909359.html">图解对象内存模型</a></li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/Developer-Options.html">gcc deveploper option 打印对象vtable内存布局</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/v4if/blog/issues/15">gdb 打印内存布局</a></li>
<li><a target="_blank" rel="noopener" href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">Itanuim ABI</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://dingweiqings.github.io/2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="KurtDing">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫猫攻城狮的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/17/C++/C++%E6%96%B0%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">c++11新特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-17 19:40:56" itemprop="dateCreated datePublished" datetime="2023-01-17T19:40:56+08:00">2023-01-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-22 10:56:09" itemprop="dateModified" datetime="2023-09-22T10:56:09+08:00">2023-09-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="lambda函数">lambda函数</h1>
<p>利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[]：默认不捕获任何变量；</span><br><span class="line">[=]：默认以值捕获所有变量；</span><br><span class="line">[&amp;]：默认以引用捕获所有变量；</span><br><span class="line">[x]：仅以值捕获x，其它变量不捕获；</span><br><span class="line">[&amp;x]：仅以引用捕获x，其它变量不捕获；</span><br><span class="line">[=, &amp;x]：默认以值捕获所有变量，但是x是例外，通过引用捕获；</span><br><span class="line">[&amp;, x]：默认以引用捕获所有变量，但是x是例外，通过值捕获；</span><br><span class="line">[this]：通过引用捕获当前对象（其实是复制指针）；</span><br><span class="line">[*this]：通过传值方式捕获当前对象；</span><br></pre></td></tr></table></figure> # 智能指针 C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。实现原理是通过类达到作用域后的构造和析构来实现的 ## 独占指针 unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权，包括：</p>
<p>1、拥有它指向的对象</p>
<p>2、无法进行复制构造，无法进行复制赋值操作。即无法使两个unique_ptr指向同一个对象。但是可以进行移动构造和移动赋值操作</p>
<p>3、保存指向某个对象的指针，当它本身被删除释放的时候，会使用给定的删除器释放它指向的对象</p>
<h2 id="共享指针">共享指针</h2>
<p>多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h2 id="弱指针">弱指针</h2>
<p>weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p>
<h1 id="移动语义">移动语义</h1>
<p>编译器通过参数的类型实现重载函数决断，对于右值入参，优先调用形参为右值引用的函数。形参为右值引用类型的接口实现方式一般和传统接口（例如拷贝构造、拷贝赋值）实现方式不同，简单来说前者为浅拷贝，后者为深拷贝，即前者为“窃取”后者为副本复制，形如本文开篇那张图片所示（class string）</p>
<h1 id="多线程支持">多线程支持</h1>
<p>原子类,thread类，条件变量类</p>
<p><strong>注意</strong> 本文测试代码见 https://github.com/dingweiqings/study/tree/master/cpp_study/src/smartpoiner https://github.com/dingweiqings/study/tree/master/cpp_study/src/thread</p>
<p># 引用 1. 移动语义 https://cloud.tencent.com/developer/article/1385969 2. 多线程 https://immortalqx.github.io/2021/12/04/cpp-notes-3/ 3. C++智能指针 https://www.cnblogs.com/tenosdoit/p/3456704.html 4. lambda函数 https://www.jianshu.com/p/d686ad9de817</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">KurtDing</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dingweiqings" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dingweiqings" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/dingweiqings@163.com" title="E-Mail → dingweiqings@163.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KurtDing</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://dingweiqings.github.io/page/4/',]
      });
      });
  </script>


</body>
</html>
